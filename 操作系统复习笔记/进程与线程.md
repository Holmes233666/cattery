# 进程与线程

进程：对正在运行的程序的一个**抽象**。

进程是操作系统最古老也是最重要的抽象之一，是对**计算的抽象**。即使可用的CPU只有一个，那么也有支持（伪）并发的能力。

![进程与线程](https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/进程与线程.png)

## 2.1 进程

并发的必要性、并行的概念。

**并发：伪并行**。CPU由一个进程快速切换到另一个进程，造成并行的错觉。

多处理器系统可以做到真正的并行。但是很难对并行的活动进行跟踪，操作系统的设计者提出了**顺序进程（进程）**的概念模型。

### 2.1.1 进程模型

进程：一个正在执行的程序实例。包括程序计数器、寄存器和变量的当前值。

每个进程有自己的虚拟CPU，真正的CPU在各个进程之间来回切换。这种快速的切换称为**多道程序设计**。

#### 2.1.1.1 关于逻辑程序计数器与物理程序计数器

​        4道程序被抽象为4个拥有自己控制流程（每个程序有自己的逻辑程序计数器）的进程，并且每个程序都独立的运行。实际上，<u>只有一个物理的程序计数器</u>，在每个程序运行时，他的逻辑程序计数器被装入实际的程序计数器中。当程序执行结束时，物理计数器的值被保存在进程的逻辑程序计数器中。在观察一段时间后，所有的进程都运行了，但是任何一个给定的瞬间仅有一个进程真正在执行。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220831153525353.png" alt="image-20220831153525353" style="zoom:50%;" />

#### 2.1.1.2 关于实时要求

CPU在不同的进程之间来回切换，每个进程的执行速度是不一定的。在对进程进行编程时，绝对不能对时序做出任何想当然的假设。

Example：10000次空循环后读取磁盘的第一条记录，但是10000次空循环期间已经切换到别的进程。

#### 2.1.1.3 进程和程序的关系

程序：用适当形式描述的算法

进程：正在执行的程序，一个程序运行两遍那么是两个进程

### 2.1.2 进程的创建

#### 2.1.2.1 进程创建的情景

4种主要的事件会导致进程的创建：

- 系统初始化

  系统初始化时会创建若干进程，包括前台和后台。

- 正在运行的进程执行创建进程的系统调用

  一个正在运行的进程创建一个或者多个新进程协助其工作。

- 用户请求创建一个新的进程

  Windows

- 一个批处理作业的初始化

  用户在这种操作系统中，提交批处理作业。在操作系统认为有资源可以运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。

从技术上看，所有的上述情形，都是**由一个已经存在的进程执行了一个创建进程的系统调用**。

#### 2.1.2.2 UNIX系统和Windows系统的进程创建命令

##### （1）UNIX

`fork`：创建一个与调用进程相同的副本。在调用了`fork`后两个进程有相同的内存映像、同样的环境字符串和同样的打开文件

`execve`：修改内存映像

##### （2）Windows

`CreateProcess`：既处理进程的创建，也负责把程序装入新的进程。

##### （3）二者共同点

进程创建之后，父进程和子进程有不同的**地址空间**，如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。

在UNIX中：

- 子进程的初始**地址空间**是父进程的一个副本，但是这里涉及两个不同的地址空间，不可写的内存区是共享的。某些UNIX的实现使得程序正文在两者间共享，因为它不能被修改。——完全分离可写和不可写的区域
- 或者，子进程共享父进程的所有内存，但是这种情况下通过**写时复制**共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有的内存区域。——写时复制

在Windows中：

- 从一开始，父进程的地址空间和子进程的地址空间就是不同的

### 2.1.3 进程的终止

#### 2.1.3.1 进程终止的条件

进程终止的条件：

- 正常退出（自愿的）
- 出错退出（自愿的）
- 严重错误（非自愿）
- 被其他进程杀死（非自愿）

#### 2.1.3.2 UNIX和Windows进程终止命令

##### （1）正常终止

多数进程是由于完成了他们的工作而终止：

example：当编译器完成了给定程序的编译之后，编译器执行一个系统调用，通知操作系统他的工作已经完成。

- 在UNIX中，该系统调用是`exit`
- 在Windows中，相关的调用是`ExitProcess`。

##### （2）出错退出

如<u>执行非法指令</u>、<u>引用不存在的内存</u>或者<u>除数是零</u>等。

在UNIX中，进程可以通知操作系统，它希望自行处理某些类型的错误，在这类错误中，**进程会受到信号（被中断）**，而不是在出现这类错误时终止。

##### （3）严重错误

编译器编译不存在的文件，直接终止。

##### （4）被其他进程杀死

UNIX中的系统调用是`kill`，Windows中的系统调用是`TerminateProcess`。

### 2.1.4 进程的层次结构

在某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持联系。子进程本身可以创建更多的进程，组成一个进程的层次结构。

#### 2.1.4.1 UNIX进程组

进程可以与他的子进程以及之后的后裔组成一个进程组。当用户从键盘发出一个信号时，该信号被送给与键盘相关的进程中的所有成员（他们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号，忽略该信号或者采取默认的动作，即该进程被杀死。

UNIX进程组参考`init`的例子。

#### 2.1.4.2 Windows进程组

Windows没有进程层次的概念，所有的进程地位都是相同的。但是在创建进程的时候，父进程得到一个特别的**令牌**（称为**句柄**），该句柄可以用来控制子进程。

### 2.1.5 进程的状态

每个进程是一个独立的实体，有自己的程序计数器和内部状态，但是，进程之间经常需要相互作用。一个进程的输出结果可能作为另一个进程的输入。

- 运行态：该时刻进程实际占用CPU
- 就绪态：可运行，但因为其他进程正在运行而暂停停止
- 阻塞态：除非某种外部事件发生，否则不能进行

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220831222558273.png" alt="image-20220831222558273" style="zoom:50%;" />

#### 2.1.5.1 进程的调度

2、3的转换通过调度程序进行。调度程序的工作就是决定应当让哪个进程运行，何时运行，应该运行多长时间等。有较多的算法。

#### 2.1.5.2 进程模型

操作系统的最底层是调度程序，因为它上面有所有的进程。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220831224147346.png" alt="image-20220831224147346" style="zoom:50%;" />

### 2.1.6 进程的实现

#### 2.1.6.1 进程表

操作系统维护着一张表格，进程表。每个进程占用一个进程表项。（或者称为进程控制块）

表项包含了进程状态的重要信息：**程序计数器**、**堆栈指针**、**内存分配情况**、**所打开文件的状态**、**账号**和**调度信息**，以及其他在进程由运行态转换到就绪态或者阻塞态时必须保存的信息。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220831225513365.png" alt="image-20220831225513365" style="zoom:50%;" />

#### 2.1.6.2 中断

与每一I/O类关联的是一个称为中断向量的位置。它包含中断服务程序的入口地址。假设一个磁盘中断发生时，进程3正在运行。则中断硬件将程序计数器、程序状态字、有时还有一个或者多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的位置。这些都是硬件完成的所有操作，然后中断服务例程接管一系列剩余的工作。

所有的中断都从保存寄存器开始，对于当前进程而言，通常是**保存在进程表项（PCB）**中。随后，会从堆栈中删除由中断硬件机制存入堆栈的那些信息，并且将堆栈指针指向一个由进程处理程序所使用的临时堆栈。

该例程结束后，会调用一个C过程处理某个特定中断类型剩下的工作。在完成有关工作时，某些进程就绪，接着调用调度程序，决定随后该运行哪个进程。

一个进程在执行过程中可能被中断数千次，但每次中断后，都能回到与中断发生前完全相同的状态。

### 2.1.7 多道程序设计模型

多道程序设计可以提高CPU利用率。

假设：

- 进程等待I/O操作的时间与其停留在内存中的时间的比为p
- 内存中有n个进程
- n个进程都在等待I/O操作的概率是$p^n$

那么CPU的利用率由下面的公式给出：
$$
CPU利用率 = 1-p^n
$$
<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220831233948265.png" alt="image-20220831233948265" style="zoom: 33%;" />

## 2.2 线程

在传统操作系统中，每个进程有一个**地址空间**和一个**控制线程**。不过经常存在一个地址空间中准并行运行多个控制线程的情形，这些线程就像（差不多）分离的进程（共享地址空间除外）。

### 2.2.1 线程的使用

使用多线程的原因：

- **程序设计模型**：在许多应用中同时发生着多种活动。其中某些活动会随着时间的推移被**阻塞**。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得简单。
- **创建和撤销的开销**：线程比进程更加轻量级，比进程更加容易创建，也更加容易撤销。在有大量线程需要动态和快速修改时，具有这一特性是非常重要的。
- **性能考虑**：若多个线程都是CPU密集型的，那么并不能获得性能的增强，但是如果存在大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，会加速程序执行的速度
- 多线程使真正的并行成为可能[CH8]

多线程模型中：并行实体有共享**同一个地址空间**和所有**可用数据**的能力。

> Example：文件编辑器的例子——三个线程能够代替三个进程
>
> ![image-20220901153232202](https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220901153232202.png)

### 2.2.2 经典的线程模型

进程模型基于两种独立的概念：资源分组处理与执行。将这两种概念分开，就引入了“线程”的概念。

#### 2.2.2.1 理解进程的角度：资源分组

理解进程的一个角度是：用某种方法将相关的资源集中在一起。

进程有存放程序正文和数据以及其他资源的地址空间，这些资源中包含打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等。把他们都放到进程中更容易管理。

#### 2.2.2.2 理解进程的角度：线程

进程拥有一个执行的线程，通常简写为线程。线程中有：

- 一个程序计数器，用来记录接着要执行哪条指令
- 寄存器，用来保存线程当前的工作变量
- 堆栈，用来记录执行历史

进程用于将资源集中在一起，线程是在CPU上被调度的实体。

##### （1）多线程理解

同一个进程中并行运行多个线程，是对在同一台计算机中并行运行多个进程的模拟。

- 多个线程共享同一个地址空间和其他资源。
- 多个进程共享物理内存，磁盘，打印机和其他资源

在2-11a中，可以看到三个传统的进程。每个进程都有自己的地址空间和单个控制线程。每个线程在不同的地址空间中运行。

在2-11b中，可以看到一个进程带有三个控制线程。每个线程在相同的地址空间中运行。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220901174345963.png" alt="image-20220901174345963" style="zoom:50%;" />

进程中的线程，所有线程有**相同的地址空间**，共享**同样的全局变量**。一个线程可以读、写另一个线程的堆栈，甚至可以清除另一个线程的堆栈。**线程之间是没有保护的**。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220901175549093.png" alt="image-20220901175549093" style="zoom:50%;" />

##### （2）线程的状态

线程的状态和进程一样：

- 就绪
- 运行
- 阻塞

##### （3）线程堆栈

每个线程的堆栈有一帧，供各个被调用但是还没有从中返回的过程使用。在该栈帧中存放了相应过程的局部变量以及过程调用完成之后使用的返回地址。

通常每个线程会调用不同的过程，从而有一个各自不同的执行历史，故每个线程都要有自己的堆栈。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220901194929053.png" alt="image-20220901194929053" style="zoom:50%;" />

##### （4）线程的创建

多线程的情况下，进程通常会从当前的单个线程开始。线程调用库函数（如`thread_create`）创建。`thread_create()`参数指定了新线程要运行的过程名。

线程之间是平等的，不论有无层次关系，创建线程通常都会返回一个线程标识符，该标识符是新线程的名字。

##### （5）线程的退出

- `thread_exit`

线程完成工作后，可以通过一个库过程（如`thread_exit`）退出，接着该线程消失，不再可调度。这种情况下，现成的创建和终止类似于进程的创建和终止。

- `thread_join`

某些线程调用中，例如`thread_join`，可以线程可以等待一个（特定）线程退出。这个过程堵塞调用直到那个特殊的线程退出。

- `thread_yeild`

允许线程自动放弃CPU从而让另一个线程运行。

因为线程不同于进程，所以无法利用时钟中断强制线程让出CPU。

### 2.2.3 POSIX线程

IEEE定义了线程的标准。定义的线程包叫做`pthread`。大部分UNIX支持该标准。

所有`pthread`线程都有某些特性。每一个都有一个标识符，一组寄存器和一组存储在结构中的属性。这些属性包括堆栈大小、调度参数以及其他线程需要的项目。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220901204049858.png" alt="image-20220901204049858" style="zoom:50%;" />

- `pthread_attr_init`

  建立一个线程的属性结构，并初始化成默认值。

- `pthread_attr_destory`

  删除一个线程的属性数据结构，释放它占用的内存。不会影响调用它的线程，这些线程会继续存在。

### 2.2.4 线程的实现

有两种主要的方式实现线程包：在用户空间和在内核中。这两种方法互有利弊，不过混合实现的方式也有可能。

#### 2.2.4.1 在用户空间中实现线程

把整个线程包放在用户空间中，内核对线程包一无所知。从内核的角度考虑，就是按照正常的方式进行管理：**单线程进程**。线程在一个运行时系统的上层运行，该**运行时系统**是一个**管理线程的过程的集合**。如：`pthread_create`，`pthread_exit`，`pthread_join`和`pthread_yeild`等。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220901205640181.png" alt="image-20220901205640181" style="zoom:50%;" />

在用户空间管理线程时，每个进程需要有其专用的**线程表**，用来跟踪该进程中的线程。线程表与进程表相似，不过仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态等。线程表由运行时系统管理。

在用户空间实现的优点：

- 用户线程包可以在不支持线程的操作系统上实现
- 允许每个进程有自己定制的调度算法
- 线程切换至少比陷入内核要快一个数量级：`thread_yeild`后调用线程调度程序来选择另一个要运行的程序，调度是本地过程。

在用户空间实现的缺点：

- 无法实现阻塞系统调用，因为会阻塞所有的线程
- 如果一个线程引起了缺页中断，那么整个进程都会被阻塞直到I/O完成，尽管有其他的线程可以执行
- 如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU

#### 2.2.4.2 在内核中实现线程

在内核中实现线程，不再需要运行时系统，进程中也没有线程表。

内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或者撤销一个已有的线程时，他进行一个系统调用，这个系统调用通过对线程表的更新完成线程的创建或者撤销。

线程表维护的信息：

- 寄存器
- 状态
- 其他信息

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220901231001645.png" alt="image-20220901231001645" style="zoom:50%;" />

与在用户空间中一样。另外，内核维护了传统的进程表，以跟踪进程的状态。

优点：

- 所有能够阻塞线程的调用都以系统调用的形式实现。当一个线程阻塞时，可以运行进程中的另一个线程。
- 缺页中断类似

缺点：

但是内核中创建或者撤销线程的代价比较大

#### 2.2.4.3 混合实现

引入内核级线程，然后将用户线程与全部内核线程多路复用起来。

编程人员可以决定多少个内核级线程和多少个用户级线程彼此多路复用。带来了最大的灵活度。

内核只识别内核级线程，并对其进行调用。一个内核线程会被多个用户级线程多路复用。每个内核级线程有一个可以轮流使用的用户线程集合。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220901233120160.png" alt="image-20220901233120160" style="zoom:50%;" />

### 2.2.5 弹出式线程

分布式系统中处理到来的消息：如服务请求。

传统：将进程与线程阻塞在`receive`系统调用上，等待消息到达。消息到达时，系统调用接收消息。

弹出式线程：一个消息的到达导致创建一个处理该消息的线程。好处是线程新，没有历史，可以快速创建。消息的到达和处理时间非常短。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220901235557180.png" alt="image-20220901235557180" style="zoom:50%;" />



## 2.3 进程间通信

进程经常需要与其他进程通信。进程间通信的问题：

- 进程如何把信息传递给另一个
- 确保两个或者更多的进程在关键活动中不会出现交叉
- 通信的正确顺序

第一个问题对于线程来说比较容易，因为它们共享一个地址空间。但是另外两个问题同样适用于线程。

### 2.3.1 竞争条件

Example：假脱机目录的例子

竞争条件：两个或者多个进程读写某些**共享数据**，而最后的结果取决于进程运行的**精确时序**，称为竞争条件。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220902142257371.png" alt="image-20220902142257371" style="zoom:50%;" />

### 2.3.2 临界区

凡涉及**共享内存**、**共享文件**以及**共享任何资源**的情况都会引起与前面类似的错误。

解决关键：需要互斥（mutual exclusion），即以某种手段确保当一个进程在使用一个共享变量或者文件时，其他进程不能进行相似的操作。

**临界区**：对共享内存进行访问的片段称为临界区（critical region）。

目标：适当安排，使得两个进程不同时处于临界区中。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220902142658963.png" alt="image-20220902142658963" style="zoom:50%;" />



对于一个好的解决方案，需要满足下面4个条件：

- 任何两个进程不能同时处于其临界区中
- 不应对CPU的速度和数量做任何的假设
- 临界区外运行的进程不得阻塞其他进程
- 不得使进程无期限的等待进入临界区

### 2.3.3 忙等待的互斥

实现互斥的方案

#### 2.3.3.1 屏蔽中断

进程进入临界区后屏蔽所有中断，离开之前再打开中断。

屏蔽中断后时钟中断也被屏蔽，只有发生时钟中断时才会进行进程切换，因此屏蔽之后CPU不会再切换到别的进程。

缺点：屏蔽中断的权利交给用户进程是不明智的。

#### 2.3.3.2 锁变量

设想有一个共享（锁）变量，其初始值为0。当一个进程想进入临界区时，他首先测试这把锁。

- 锁的值为0，那么进程将其设置为1，并进入临界区
- 锁的值为1，那么进程等待直到其值变为0

缺点：与脱机目录一样的疏漏。

#### 2.3.3.3 严格轮换法

用于忙等待的锁称为**自旋锁（spin lock）**

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220902150957380.png" alt="image-20220902150957380" style="zoom:50%;" />

该方案要求两个进程严格轮流进入临界区。

#### 2.3.3.4 Peterson解法

使用共享变量。

```cpp
#define FALSE 0
#define TRUE 1
#define N 2 													/* number of processes */

int turn; 														/* whose turn is it? */
int interested[N]; 												/* all values initially 0 (FALSE) */

void enter region(int process) 									/* process is 0 or 1 */
{
    int other; 													/* number of the other process */
    other = 1 − process; 										/* the opposite of process */
    interested[process] = TRUE; 								/* show that you are interested */
    tur n = process; 											/* set flag */
    while (turn == process && interested[other] == TRUE); 		/* null statement */ ;
}
void leave region(int process) 									/* process: who is leaving */
{
	interested[process] = FALSE; 						/* indicate departure from critical region */
}
```

#### 2.3.3.5 TSL指令

硬件支持的方案，有下面的指令：

`TSL RX, LOCK`

称为测试并加锁，将一个内存字lock读到寄存器RX中，然后在该内存地址上存一个非零值。读字和写字的操作保证是不可分割的，即该指令结束之前其他处理器不允许访问该内存字。执行TSL指令的CPU将锁住内存总线，以进制其他CPU在本指令结束之前访问该内存字。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220902165507974.png" alt="image-20220902165507974" style="zoom:50%;" />

一个可以替代`TSL`的指令是`XCHG`，它原子性的交换了两个位置的内容。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220902165811414.png" alt="image-20220902165811414" style="zoom:50%;" />

### 2.3.4 睡眠与唤醒

Peterson解法和TSL或者XCHG解法都是正确的，但是都有忙等待的缺点。忙等待解法本质上是：当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。

忙等待可能造成**优先级反转问题**：两个进程H和L，H优先级高于L，H在就绪态时H可以随时运行。某一时刻，L处于临界区中，此时H变到就绪态，准备运行（例如，一条I/O操作结束）。现在H开始忙等待，但由于当H就绪时L不会被调度，也就无法离开临界区，所以H将永远一直等下去。被称为优先级反转问题。

进程间通信原语：无法进入临界区时将**阻塞**，**而不是忙等待**。最简单的是`sleep`和`wake up`。

- `sleep`：引起调用进程阻塞的系统调用，即被挂起，直到有另一个进程将其唤醒。
- `wake up`：有一个参数，即要被唤醒的进行。

#### 2.3.4.1 生产者-消费者问题

生产者：把信息放入缓冲区；缓冲区已满时休眠

消费者：从缓冲区中取出信息；缓冲区已空时休眠

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220902224020602.png" alt="image-20220902224020602" style="zoom:50%;" />

上述的程序存在竞争条件：当count=0时，消费者读取count，判断得count=0，此时时间片轮转到生产者，生产者读取为0，进行生产；产出1后`wake up`消费者。但是此时消费者并为逻辑上进入睡眠，所以`wake up`信号量丢失，然后当消费者下次运行时，他读到的count是0，所以睡眠。而生产者迟早会填满整个缓冲区，然后睡眠。这样一来，两个进程都将永远睡眠下去。

### 2.3.5 信号量

- `down`操作：

  检查信号量的值是否大于零

  - 若大于0，则将其值减1（即用掉一个保存的唤醒信号）并继续；
  - 若该值为0，则进程睡眠

  检查数值、修改变量值以及可能发生的睡眠均为一个**单一的，不可分割的原子操作**。

- `up`操作：

  检查信号量的值增加1，唤醒一个进程。

  对一个有进程在其上睡眠的信号量执行一次up操作后，该信号量的值仍是0，但在其上睡眠的进程却少了一个。

  信号量的增加和进程的唤醒同样也是不可分割的。不会有进程因为执行`up`而阻塞。

`down`和`up`操作也可以称为`P`操作和`V`操作。

#### 2.3.5.1 用信号量解决生产者-消费者问题

通过`up`和`down`作为系统调用实现，而且操作系统只需在执行以下操作时屏蔽所有中断：测试信号量、更新信号量以及在需要的时候使某个进程睡眠。

该方法使用了三个信号量：

- `full`：记录充满的缓冲槽的数目；初值为0
- `empty`：记录空缓冲槽的数目；初值为缓冲区中槽的数目
- `mutex`：确保生产者和消费者不会同时访问缓冲区

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220902234147412.png" alt="image-20220902234147412" style="zoom:50%;" />

信号量的另一种用途是用来实现同步。信号量`full`和`empty`用来保证某种事件顺序发生或者不发生。

### 2.3.6 互斥量

互斥量是信号量的简化版本、互斥量仅仅适用于管理共享资源或指责一小段代码。

互斥量是一个可以处于两态之一的变量：解锁和加锁。实际上常常食用一个整型量，0表示解锁，其他的所有值表示加锁。

互斥量有两个过程，当一个线程（或进程）访问临界区时，他调用mutex_lock。

- 如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入该临界区

- 如果互斥量已经加锁，那么调用线程被阻塞，直到在临界区的线程完成并调用mutex_unlock

  如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁

`mutex_lock`和`mutex_unlock`的实现代码如下：

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220903122930470.png" alt="image-20220903122930470" style="zoom:50%;" />

#### 2.3.6.1 快速用户区互斥`futex`

`futex`：Linux的一个特性，实现了基本的锁（很像互斥锁），但避免了陷入内核。

因为来回切换到内核花销很大，所以这样做可观地改善了性能。
$$
futex包含两个部分\begin{cases}一个内核服务\\一个用户库\end{cases}
$$

- 内核服务

  提供一个等待队列，允许多个进程在一个锁上等待。

- 用户库

#### 2.3.6.2 `pthread`中的互斥量

`pthread`提供了一系列的用来同步线程的函数。

- 基本机制是使用一个可以被锁定和解锁的互斥量保护每个临界区

  互斥量在允许或阻塞对临界区的访问上很有用

  <img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220903155532661.png" alt="image-20220903155532661" style="zoom:50%;" />

- 提供了另一种同步机制**条件变量**

  条件变量则允许线程由于一些未达到的条件而阻塞

  - `pthread_cond_wait`：阻塞调用线程直到另一个线程向它发起信号
  - `pthread_cond_signal`：发起唤醒

  <img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220903155732213.png" alt="image-20220903155732213" style="zoom:50%;" />

**条件变量与互斥量经常一起使用。这种模式用于让一个线程锁住一个互斥量，然后当它不能获得他所期待的结果时等待一个条件变量。**

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220903173039077.png" alt="image-20220903173039077" style="zoom:50%;" />

### 2.3.7 管程 Monitor

管程：高级同步原语，是一个由**过程、变量及数据结构**组成的集合。

任何一个时刻，管程中只能有一个活跃进程，可以有效完成互斥。

互斥：使用互斥量和信号量；编译器安排互斥，操作概率小很多

无法运行时阻塞：条件变量以及相关的两个操作`wait`和`signal`

### 2.3.8 消息传递

消息传递是机器间的信息交换方法。这种进程间通信方法使用两条原语：`send`和`receive`。

`send(destination,&message)`：向一个给定的目标发送消息

和

`receive(source,&message)`：从一个源接收一个消息。

如果没有消息可用，则接收者可能被阻塞，直到一条消息到达，或者带着一个错误码返回。

#### 2.3.8.1 消息传递系统的设计要点

区分新老消息：序号

消息丢失：发送确认

### 2.3.10 避免锁：读-复制-更新

有些情况下可以允许写操作来更新数据结构，即便有其他的进程正在使用它。<u>关键在于确保每个读操作要么读取旧的版本要么读取新的版本，但绝不能是新旧数据的一些奇怪组合。</u>



<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220903202630366.png" alt="image-20220903202630366" style="zoom:50%;" />

## 2.4 调度

存在多个进程竞争CPU的情况，必须要选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序，该程序使用的算法称为**调度算法**。

线程的处理与进程相似，先讨论进程，然后讨论线程调度的独特文体。

### 2.4.1 调度简介

批处理阶段：依次运行磁带上的每一个作业

多道程序设计：批处理和分时服务相结合

个人计算机：两个方向：唯一进程（不用调度选择）；或者多个调度程序但是先后顺序或者时间要求可能没那么严格。

网络服务器：多个进程经常竞争CPU

#### 2.4.1.1 进程行为

几乎所有的进程I/O请求好计算都是交替突发的。如下图，某些进程花费了大多数时间在计算上（图a），而其他进程（如图b）则在等待I/O上花费了绝大多数的时间。根据进程在等待I/O上花费的时间，前者称为**计算密集型（compute-bound）**，后者称为**I/O密集型（I/O-bound）**。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220903212448425.png" alt="image-20220903212448425" style="zoom:50%;" />

随着CPU变得越来越快，更多的进程倾向于I/O密集型。这种现象之所以发生是因为CPU改进得比磁盘快，其结果是，未来对I/O密集型进程的调度处理更为重要。

基本思想：如果要运行I/O密集型进程，那么应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌。

#### 2.4.1.2 何时调度

- 创建一个新进程后：运行父进程or子进程
- 在一个进程退出后
- 当一个进程阻塞在I/O和信号量上，或者因为其他原因阻塞时
- 当一个I/O中断发生时

两种调度算法：

- 非抢占式调度：挑选一个进程运行，直到该进程被阻塞或者自动放弃CPU
- 抢占式调度：挑选一个进程，并且让进程运行至某个固定时间段的最大值。如果该时间段结束时，进程仍在运行，他就被挂起，调度程序选择另一个进程运行。

#### 2.4.1.3 调度算法分类

不同的环境需要不同的调度算法，列举三种环境：
$$
不同的环境\begin{cases}批处理：非抢占式也是可以接受的\\交互式：抢占是必须的\\实时：抢占有时是不必要的\end{cases}
$$

#### 2.4.1.4 调度算法的目标

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220903225239423.png" alt="image-20220903225239423" style="zoom:50%;" />

吞吐量：每小时完成的作业数量

周转时间：从一个批处理作业提价到完成时刻为止的统计平均时间。该数据度量了用户得到输出所需的平均等待时间

响应时间：发出命令到得到响应的时间

### 2.4.2 批处理系统中的调度

#### 2.4.2.1 先来先服务

进程按照它们请求CPU的顺序使用CPU，有一个**就绪进程的单一队列**。作业不会因为运行时间太长而被中断。当其他作业进入时，它们排列到队列队尾。

优点：易于理解，便于应用

缺点：

- 不利于短作业及I/O密集型进程

#### 2.4.2.2 最短作业优先

非抢占式批处理算法，平均周转时间最短。

只有在所有作业都可以同时运行时，最短作业优先算法才是最优化的。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220904103020750.png" alt="image-20220904103020750" style="zoom:50%;" />

#### 2.4.2.3 最短剩余时间优先

最短作业优先的抢占式版本。

选择剩余运行时间最短的进程运行。

### 2.4.3 交互式系统中的调度

#### 2.4.3.1 轮转调度

每个进程被分配一个时间片，允许该进程在该时间片中运行。

- 如果时间片结束时该进程还在运行，将剥夺CPU并分配给另一个进程。
- 如果该进程在时间片结束前阻塞或者结束，即CPU立即进行切换。

时间片轮转中唯一有趣的是时间片的长度从一个进程切换到另一个进程是需要一定时间的——保存装入寄存器值集内存映像、更新各种表格和列表、清除和重新调入内存高速缓存等。需要考虑真正工作时间与切换开销（上下文切换）耗费的时间的比值。

![image-20220904110621877](https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220904110621877.png)

#### 2.4.3.2 优先级调度

轮转调度做了一个隐含的假设：所有的进程同等重要。

优先级调度基本思想：每个进程被赋予一个优先级，允许**优先级最高**的进程可以最先运行。

为防止高优先级的进程无休止的运行下去：

- 调度程序可能在每个时钟中断时降低当前进程的优先级，如果这一行为导致该进程的优先级低于次高优先级的进程，则进行进程切换。
- 另一种方法是：给每个进程赋予一个允许运行的最大时间片，当用完这个时间片时，次高优先级的进程便获得运行机会。

优先级调度的一种实现：一组进程分成若干类，并且在各类之间采用优先级调度，而在各个进程内部采用轮转调度：

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220904110641159.png" alt="image-20220904110641159" style="zoom:50%;" />

#### 2.4.3.3 多级队列

设立优先级类，属于最高优先级的进程类运行1个时间片，属于次高优先级类的进程运行2个时间片，再次一级运行4个时间片，以此类推，当一个进程用完分配的时间片后，他被移到下一类。

#### 2.4.3.4 最短进程优先

对于批处理系统：最短作业意味着最短响应时间。

交互式进程通常遵循下列模式：等待命令、执行命令、等待命令、执行命令，不断重复。如果将每个命令看做一个独立的“作业”，可以通过最短作业优先来使响应时间最短。唯一的问题是如何从当前进程中找到那个最短的进程。

找到最短进程的方法：

- 老化技术

  运行估计运行时间最短的那个。假设每条命令的预估运行时间为$T_0$。假设下一次运行时间为$T_1$，用这两个值加权来进行最短时间估计时间：$aT_0+(1-a)T_1$。通过选择a的值来决定是尽快忘掉老的运行时间还是在较长一段时间内记住他们。当$a=\frac{1}{2}$时，可以得到下面的序列：
  $$
  T_0,\quad T_1/2+T_0/2,\quad T_2/2+T_1/4+T_0/4,\quad T_3/2+T_2/4+T_1/8+T_0/8
  $$
  可以看到，在三轮过后，$T_0$在新的估计值中占的比例是$1/8$

  有时把这种通过当前测量值和先前估计值加权得到下一个新的估计值的技术称为老化（aging）。

### 2.4.4 实时系统中的调度

实时系统是一种时间起着主导作用的系统。

实时系统通常可以分为硬实时和软实时：

- 硬实时：必须满足绝对的截止时间
- 软实时：虽然不希望偶尔错失截止时间，但可以容忍

**可调度**的实时系统：

实时系统可以按照响应方式进一步分类成**周期性事件**和**非周期性事件**。一个系统可能响应多个周期性的事件流。根据每个事件要处理的时间长短，系统甚至可能无法处理完所有的事件。例如：有m个周期事件，事件$i$以周期$P_i$发生，并需要$C_i$秒CPU处理一个事件，那么可以处理事件的条件是：
$$
\sum\limits_{i=1}^m\frac{C_i}{P_i}\leq 1
$$
满足这个条件的系统称为可调度的。

### 2.4.5 策略和机制

调度机制与调度策略分离：调度算法以某种形式参数化，参数由用户进程填写。

### 2.4.6 线程调度

用户级线程：

由运行时系统将上述进程的调度算法应用在线程上。

## 2.5 经典的IPC问题

### 2.5.1 哲学家就餐问题

问题背景：

哲学家的生活中有两种交替活动时段：吃饭和思考。饿了时，试图分两次去拿左边和右边的叉子，每次拿一把，不分次序。如果成功得到两把叉子，就开始吃饭，吃完后放下叉子继续思考。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220904170743060.png" alt="image-20220904170743060" style="zoom:50%;" />

**饥饿（starvation）**：所有程序都在不停地运行，但都无法取得进展，称为饥饿。

```cpp
#define N 5 					/* number of philosophers */
#define LEFT (i+N−1)%N 			/* number of i’s left neighbor */
#define RIGHT (i+1)%N 			/* number of i’s right neighbor */
#define THINKING 0 				/* philosopher is thinking */
#define HUNGRY 1 				/* philosopher is trying to get for ks */
#define EATING 2 				/* philosopher is eating */
typedef int semaphore; 			/* semaphores are a special kind of int */
int state[N]; 					/* array to keep track of everyone’s state */
semaphore mutex = 1; 			/* mutual exclusion for critical regions */
semaphore s[N]; 				/* one semaphore per philosopher */
void philosopher(int i) 		/* i: philosopher number, from 0 to N−1 */
{
    while (TRUE) { 					/* repeat forever */
        think(); 						/* philosopher is thinking */
        take_forks(i); 					/* acquire two for ks or block */
        eat(); 						/* yum-yum, spaghetti */
        put_forks(i); 					/* put both for ks back on table */
	}
}
void take forks(int i) 			/* i: philosopher number, from 0 to N−1 */
{
    down(&mutex); 				/* enter critical region */
    state[i] = HUNGRY; 			/* record fact that philosopher i is hungry */
    test(i); 					/* try to acquire 2 for ks */
    up(&mutex); 				/* exit critical region */
    down(&s[i]);	 			/* block if for ks were not acquired */
}
void put forks(i) 				/* i: philosopher number, from 0 to N−1 */
{
    down(&mutex); 				/* enter critical region */
    state[i] = THINKING; 		/* philosopher has finished eating */
    test(LEFT); 				/* see if left neighbor can now eat */
    test(RIGHT); 				/* see if right neighbor can now eat */
    up(&mutex); 				/* exit critical region */
}
void test(i) 					/* i: philosopher number, from 0 to N−1 */
{
    if (state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING) 
    {
        state[i] = EATING;
        up(&s[i]);
	}
}
```

### 2.5.2 读者-写者问题

读者写者问题，为数据库访问建立了一个模型。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220904190613755.png" alt="image-20220904190613755" style="zoom: 67%;" />

第一个读者对信号量`db`执行`down`操作，随后的读者只是递增一个计数器`rc`。当读者离开时，他们递减这个计数器，而最后一个读者则对信号量执行`up`操作，这样允许一个被阻塞的写者（如果存在的话）可以访问数据库。

## 2.6 面试常见问题



