# 进程与线程

进程：对正在运行的程序的一个**抽象**。

进程是操作系统最古老也是最重要的抽象之一，是对**计算的抽象**。即使可用的CPU只有一个，那么也有支持（伪）并发的能力。

## 2.1 进程

并发的必要性、并行的概念。

**并发：伪并行**。CPU由一个进程快速切换到另一个进程，造成并行的错觉。

多处理器系统可以做到真正的并行。但是很难对并行的活动进行跟踪，操作系统的设计者提出了**顺序进程（进程）**的概念模型。

### 2.1.1 进程模型

进程：一个正在执行的程序实例。包括程序计数器、寄存器和变量的当前值。

每个进程有自己的虚拟CPU，真正的CPU在各个进程之间来回切换。这种快速的切换称为**多道程序设计**。

#### 2.1.1.1 关于逻辑程序计数器与物理程序计数器

​        4道程序被抽象为4个拥有自己控制流程（每个程序有自己的逻辑程序计数器）的进程，并且每个程序都独立的运行。实际上，<u>只有一个物理的程序计数器</u>，在每个程序运行时，他的逻辑程序计数器被装入实际的程序计数器中。当程序执行结束时，物理计数器的值被保存在进程的逻辑程序计数器中。在观察一段时间后，所有的进程都运行了，但是任何一个给定的瞬间仅有一个进程真正在执行。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220831153525353.png" alt="image-20220831153525353" style="zoom:50%;" />

#### 2.1.1.2 关于实时要求

CPU在不同的进程之间来回切换，每个进程的执行速度是不一定的。在对进程进行编程时，绝对不能对时序做出任何想当然的假设。

Example：10000次空循环后读取磁盘的第一条记录，但是10000次空循环期间已经切换到别的进程。

#### 2.1.1.3 进程和程序的关系

程序：用适当形式描述的算法

进程：正在执行的程序，一个程序运行两遍那么是两个进程

### 2.1.2 进程的创建

#### 2.1.2.1 进程创建的情景

4种主要的事件会导致进程的创建：

- 系统初始化

  系统初始化时会创建若干进程，包括前台和后台。

- 正在运行的进程执行创建进程的系统调用

  一个正在运行的进程创建一个或者多个新进程协助其工作。

- 用户请求创建一个新的进程

  Windows

- 一个批处理作业的初始化

  用户在这种操作系统中，提交批处理作业。在操作系统认为有资源可以运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。

从技术上看，所有的上述情形，都是**由一个已经存在的进程执行了一个创建进程的系统调用**。

#### 2.1.2.2 UNIX系统和Windows系统的进程创建命令

##### （1）UNIX

`fork`：创建一个与调用进程相同的副本。在调用了`fork`后两个进程有相同的内存映像、同样的环境字符串和同样的打开文件

`execve`：修改内存映像

##### （2）Windows

`CreateProcess`：既处理进程的创建，也负责把程序装入新的进程。

##### （3）二者共同点

进程创建之后，父进程和子进程有不同的**地址空间**，如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。

在UNIX中：

- 子进程的初始**地址空间**是父进程的一个副本，但是这里涉及两个不同的地址空间，不可写的内存区是共享的。某些UNIX的实现使得程序正文在两者间共享，因为它不能被修改。——完全分离可写和不可写的区域
- 或者，子进程共享父进程的所有内存，但是这种情况下通过**写时复制**共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有的内存区域。——写时复制

在Windows中：

- 从一开始，父进程的地址空间和子进程的地址空间就是不同的

### 2.1.3 进程的终止

#### 2.1.3.1 进程终止的条件

进程终止的条件：

- 正常退出（自愿的）
- 出错退出（自愿的）
- 严重错误（非自愿）
- 被其他进程杀死（非自愿）

#### 2.1.3.2 UNIX和Windows进程终止命令

##### （1）正常终止

多数进程是由于完成了他们的工作而终止：

example：当编译器完成了给定程序的编译之后，编译器执行一个系统调用，通知操作系统他的工作已经完成。

- 在UNIX中，该系统调用是`exit`
- 在Windows中，相关的调用是`ExitProcess`。

##### （2）出错退出

如<u>执行非法指令</u>、<u>引用不存在的内存</u>或者<u>除数是零</u>等。

在UNIX中，进程可以通知操作系统，它希望自行处理某些类型的错误，在这类错误中，**进程会受到信号（被中断）**，而不是在出现这类错误时终止。

##### （3）严重错误

编译器编译不存在的文件，直接终止。

##### （4）被其他进程杀死

UNIX中的系统调用是`kill`，Windows中的系统调用是`TerminateProcess`。

### 2.1.4 进程的层次结构

在某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持联系。子进程本身可以创建更多的进程，组成一个进程的层次结构。

#### 2.1.4.1 UNIX进程组

进程可以与他的子进程以及之后的后裔组成一个进程组。当用户从键盘发出一个信号时，该信号被送给与键盘相关的进程中的所有成员（他们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号，忽略该信号或者采取默认的动作，即该进程被杀死。

UNIX进程组参考`init`的例子。

#### 2.1.4.2 Windows进程组

Windows没有进程层次的概念，所有的进程地位都是相同的。但是在创建进程的时候，父进程得到一个特别的**令牌**（称为**句柄**），该句柄可以用来控制子进程。

### 2.1.5 进程的状态

每个进程是一个独立的实体，有自己的程序计数器和内部状态，但是，进程之间经常需要相互作用。一个进程的输出结果可能作为另一个进程的输入。

- 运行态：该时刻进程实际占用CPU
- 就绪态：可运行，但因为其他进程正在运行而暂停停止
- 阻塞态：除非某种外部事件发生，否则不能进行

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220831222558273.png" alt="image-20220831222558273" style="zoom:50%;" />

#### 2.1.5.1 进程的调度

2、3的转换通过调度程序进行。调度程序的工作就是决定应当让哪个进程运行，何时运行，应该运行多长时间等。有较多的算法。

#### 2.1.5.2 进程模型

操作系统的最底层是调度程序，因为它上面有所有的进程。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220831224147346.png" alt="image-20220831224147346" style="zoom:50%;" />

### 2.1.6 进程的实现

#### 2.1.6.1 进程表

操作系统维护着一张表格，进程表。每个进程占用一个进程表项。（或者称为进程控制块）

表项包含了进程状态的重要信息：**程序计数器**、**堆栈指针**、**内存分配情况**、**所打开文件的状态**、**账号**和**调度信息**，以及其他在进程由运行态转换到就绪态或者阻塞态时必须保存的信息。

<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220831225513365.png" alt="image-20220831225513365" style="zoom:50%;" />

#### 2.1.6.2 中断

与每一I/O类关联的是一个称为中断向量的位置。它包含中断服务程序的入口地址。假设一个磁盘中断发生时，进程3正在运行。则中断硬件将程序计数器、程序状态字、有时还有一个或者多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的位置。这些都是硬件完成的所有操作，然后中断服务例程接管一系列剩余的工作。

所有的中断都从保存寄存器开始，对于当前进程而言，通常是**保存在进程表项（PCB）**中。随后，会从堆栈中删除由中断硬件机制存入堆栈的那些信息，并且将堆栈指针指向一个由进程处理程序所使用的临时堆栈。

该例程结束后，会调用一个C过程处理某个特定中断类型剩下的工作。在完成有关工作时，某些进程就绪，接着调用调度程序，决定随后该运行哪个进程。

一个进程在执行过程中可能被中断数千次，但每次中断后，都能回到与中断发生前完全相同的状态。

### 2.1.7 多道程序设计模型

多道程序设计可以提高CPU利用率。

假设：

- 进程等待I/O操作的时间与其停留在内存中的时间的比为p
- 内存中有n个进程
- n个进程都在等待I/O操作的概率是$p^n$

那么CPU的利用率由下面的公式给出：
$$
CPU利用率 = 1-p^n
$$
<img src="https://cdn.jsdelivr.net/gh/Holmes233666/blogImage@main/img/image-20220831233948265.png" alt="image-20220831233948265" style="zoom:50%;" />

