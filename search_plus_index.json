{"./":{"url":"./","title":"简介","keywords":"","body":"Summary 软工大三下笔记 算法分析与设计笔记 CH1：Introduction CH2：算法入门 CH2：算法入门_review CH3：Growth of Functions CH3：Growth of Functions_review CH4：Recurrences var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/about.html":{"url":"算法/about.html","title":"算法分析与设计","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH1：Introduction.html":{"url":"算法/CH1：Introduction.html","title":"CH1：Introduction","keywords":"","body":"CH1：Introduction 1.1 Factors of Programming programming language IDE software achitecture 架构： 架构的类型： \\begin{cases}C2\\ Style：conponent\\ \\& \\ connector\\\\Pipe-Fliter\\ Style:输入\\rightarrow 输出\\\\Repositories\\ Style：以某一数据源为中心的操作\\end{cases} 成熟的模式：逐步产生商业架构 Java EE CORBA .NET（与javaEE类似） 1.2 More Important 1.2.1 Transaction finish or null 1.2.2 Security 1.3 DS and Algorithm 1.3.1 Algorithm Concept：A well-Defined computational procedure that takes some value, or set of values, as input and proceduces some value, or set of values, as output. Broadly：a step-step procedure for solving a problem or accomplishing some end especially by a computer. issues： correctness efficiency(amount of work done and space used) storage(simplicity, clarity) optimality 1.3.2 Promblem that can be solved by algorithm 基因工程 网络 电子商务 生产 一个经典的问题：you are given n integers(there may be negative ones but not all) a1, a2, ..., an, determine i and j which maximize the sum from $a_i$ to $a_j$. Case：6 integers：(-2, 11, -4, 13, -5, -2) Ans：i = 2, j = 4, max sum is 20 1.3.3 Importance of algorithms 问题：给1000,000个整数排序 数据量 主频 算法时间复杂度 计算时间 1000000 1GHz $2n^2$ $2\\times 10^5\\ seconds$ 1000000 100MHz $50nlgn$ $105\\ seconds$ 加之主频的提升不大，算法更为重要 1.3.4 About course Design and Analysis 怎么找算法？ 评价算法，定量 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH2：算法入门.html":{"url":"算法/CH2：算法入门.html","title":"CH2：算法入门","keywords":"","body":"CH2：算法入门 The problem of sorting input：sequence of n natural numbers output：permutation such that $a_1'\\leq a_2'\\leq ....\\leq a_n'$ 2.1 Insert Sort 算法： for(i = 2; i = 1 and A[j] > key){ A[j+1] = A[j]; // 后移 j--; } A[j+1] = key; } 2.2 Kinds of Analysis worstest - case（usually）：最坏情况优先考虑 Average - case（sometimes） Best - case（bogus） 2.2.1 循环不变式 loop-invariants Proving correctness Using Loop-invariants【外层为循环】 需要证明的三个性质： 初始化：它在循环的第一轮迭代开始时，应该是正确的 保持：如果在某一次的迭代开始前是正确的，那么在下一次迭代开始前，他也应该保持正确 终止：不变式给了一个有用的性质，表明算法是正确的 2.2.2 运行时间 （1）Running Time 运行时间的取决因素： 输入序列：已经排列好的序列【数据特征】 数据规模：更短的序列更容易排好 通常，我们考虑运行时间的上界，因为这是一个保证 （2）Machine-independent time 插入排序的最差时间取决于计算机的速度： 相对速度（on the same machine）——关注算法 绝对速度（on different machine） 通常我们忽视机器相关时间的限制，关注“the growth of T(n) as n → ∞” 称为渐近分析“Asympotic Analysis” （3）$\\theta-$notation 关心增长率，低阶和常数丢弃 Drop low-order terms; ignore leading constants Example：$3n^3+90n^2-5n+6046 = \\theta(n^3)$ 当n变得足够大时，一个$\\theta(n^2)$的算法总会打败一个$\\theta(n^3)$的算法 2.2.3 Insertion Sort Analysis Worest case：Input reverse sorted【逆序的序列】 T(n) = \\sum\\limits_{j = 2,...,n}\\theta(j) = \\theta(n^2) Average case：All permutations equally likely T(n) = \\sum\\limits_{j = 2,...,n}\\theta(j/2)=\\theta(n^2) 2.3 Analysis Algorithm Analysis An Algorithm： 算法分析指的是对一个算法所需的资源进行分析，预测算法所需的资源，包括内存、通信带宽或计算机硬件等。 但是通常我们更想测量计算时间。 2.3.1 RAM RAM：单处理机，随机存储模型 random-access-machine（RAM） Model with no concurrent operations 不考虑并发 executed as an atom operation 不考虑中断，原子操作 每条指令需要固定时间 内存容量足够大 在RAM模型下，对基础的操作进行计数即可 count fundamental operation。 2.3.2 Analysis of Insert Operation 插入排序的时间计算如下： T(n) = c_1n+c_2(n-1) + c_4(n-1)+c_5\\sum\\limits_{j=2}^nt_j+c_6\\sum\\limits_{j=2}^n(t_j-1) + c_7\\sum\\limits_{j=2}^n(t_j-1)+c_8(n-1)\\\\ best case：数组是有序的 **$t_j = 1$，检查一次，不需要后移** T(n) = c_1n+c_2(n-1) + c_4(n-1)+c_5(n-1)+c_8(n-1)\\\\=(c_1+c_2+c_4+c_5+c_8)n-(c_2+c_4+c_5+c_8) 运行时间是n的线性函数 worest case：数组是倒序的 **$t_j = j$，检查一次，不需要后移** T(n) = c_1n+c_2(n-1)+c_4(n-1)+c_5(n(n+1)/2-1)+c_6(n(n-1)/2)+c_7(n(n-1)/2)+c_8(n-1)\\\\=(c_5/2+c_6/2+c_7/2)n^2+(c_1+c_2+c_4+c_5/2-c_6/2-c_7/2+c_8)n-(c_2+c_4+c_5+c_8) 运行时间是n的二次函数。 note： 对于某些算法来说，最坏情况经常发生 平均情况有时候和一般情况一样糟糕 2.3.3 Order of Growth 我们只考虑运行时间的增长顺序: 我们可以忽略低阶项，因为对于非常大的n，它们相对不重要。 我们也可以忽略前项的常系数，因为对于非常大的n，它们对计算效率的增长速度并不重要。 我们刚刚说过，最好的情况是n的线性而最坏/平均的情况是n的二次型。 2.4 Designing Algorithm 2.4.1 Divide and Conquer To solve P： Divide P into smaller problems P_1, P_2, ... , P_k Conquer by solving the (smaller) subproblems recursively Combine the solutions to P_1,P_2,...,P_k into the solution for P （1）Merge Sort Using Divide and Conquer, we can obtain a merge sort algorithm Divide：divide n elements into two subsequences of n/2 elements each Conquer：Solve the two subsequences recursively Combine：Merge the two sorted subsequences to produce the sorted answer Merge-Sort(A，p，r) INPUT: a sequence of n numbers stored in array A OUTPUT: an ordered sequence of n numbers MergeSort(A,p,r) if p Actions of Merge Sort： 2.4.2 Analysis divide and conquer Algorithm $T(n)$ running time on a problem of size n 【n ：问题规模】 假设把原问题分成a个子问题，每个子问题是原问题规模的$1/b$ 对于MergeSort来说，a = 2，每个问题的规模是原问题的1/b $D(n)$ 分解的开销 $C(n)$ 合并的开销 子问题 --合并-->原问题 MergeSort Recurrence Equation T(n) = \\begin{cases}\\Theta(1)\\quad if\\ n≤c\\\\ aT(n/b)+D(n) + C(n)\\quad otherwise\\end{cases} 对于MergeSort来说，递归式如下： T(n) = \\begin{cases}\\Theta(1)\\quad if\\ n≤c\\\\ 2T(n/2)+\\Theta(n)\\quad otherwise\\end{cases} Claim： T(n) = nlog_2^n 所有情况下均为nlog_2^n 最好 最坏 平均 $log_2^n+1$是针对结点的，若是针对边则是$log_2^n$。每层的和是一定的，都是cn 所以总的花费时间为： \\sum_{i=1}^{log_2^n} cn = cn·log_2^n Proof by Telescoping T(n) = 2T(n/2)+n = 2(2T(n/4) + n/2)+n = 4T(n/4)+2n\\\\ =......=nT(n/n)+log_2^n n=nT(1)+nlog_2^n var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH2：算法入门_review.html":{"url":"算法/CH2：算法入门_review.html","title":"CH2：算法入门_review","keywords":"","body":"CH2 算法入门 MindMap 排序问题： 输入：序列$$ 输出：非降序排列：$$，满足$a_1'\\leq a_2'\\leq...\\leq a_n'$ 2.1 Insert Sort 程序： void insertSort(vector& vec) { for (int i = 2; i 0 && vec[j] > key) { vec[j+1] = vec[j]; // 后移操作 j--; } vec[j+1] = key; } } 注意后移操作：A[j+1] = A[j] 若位置0处数字为负无穷，那么while循环中将不用写条件j>0。 2.2 Analysis of algorithms 2.2.1 运行时间 Running Time： 数据的初始特征 数据规模 we seek upper bounds on the running time Kinds of Analysis： Worst - case（usually 最坏情况最优先考虑） Average - case（sometimes） Best - case（bogus） 2.2.2 loop-invariant Proving correctness using loop-invariant：最外层必须是循环，证明某一性质每一次循环都不变 需要证明的三个性质 初始化：他在循环的第一轮迭代开始前，应该是正确的 保持：如果在某一次的迭代开始前是正确的，那么在下一次的迭代开始前他也应该保持正确 终止：循环结束时，不变式给了一个有用的性质，表明算法是正确的 使用循环不变式证明插入排序 证明：在每次迭代开始前子数组A[1...j-1]中元素为原数组中的A[1...j-1]，但是是有序的 初始化 j = 2 保持：A[j - 1], A[j - 2],… are moved one at a time till the proper position for A[j] is found. 结束：当j=n+1时，整个序列有序 2.2.3 机器独立时间 machine independent time relative time：在相同的机器上——关注算法 absolute time：在不同的机器上 忽略机器相关的约束，直接考虑 $n\\rightarrow \\infty$时的$T(n)$ —— 渐近分析 Asymptotic Analysis 2.2.4 $\\Theta-Notation$ （1）定义 $\\Theta$表示法的定义： 数学定义：$\\Theta(g(n)) = {存在正整数c_1和c_2，并且n_0>0，满足当所有的n\\geq n_0时，0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n)}$ 工程上：关心增长率，低阶和常数项丢弃 Example：$3n^3 + 9n^2-5n+8344 = \\Theta(n^3)$ （2）Asyptotic Performance 当n变得足够大的时候，一个$\\Theta(n^2)$的算法一定比一个$\\theta(n^3)$的算法要好 2.2.5 Insertion sort analysis 最差情况：输入是逆序的——每个数都要前移 T(n) = \\sum_{j=2..n}\\Theta(j)=\\Theta(n^2) 平均情况： T(n) = \\sum_{j=2..n}\\Theta(j/2)=\\Theta(n^2) 2.3 算法分析的入门 2.3.1 算法分析的概念 算法分析指的是对一个算法所需的资源进行分析，内存，通信带宽或者计算机硬件是主要关心的，但通常希望测量计算时间。 在我们分析算法之前，我们必须有一个将要使用的实现技术的模型，包括该技术的资源及其成本的模型 算法实现的技术模型：单处理器，随机存储模型[RAM] 2.3.2 Random Access Model 不考虑并发 不考虑中断，原子操作 假设每条指令花费常数时间 内存足够大 …… 在RAM模型下，需要考虑的是基本操作的次数 counting fundamental operations 2.3.3 Analysis of insert operation $cost$：每次基本操作花费的代价 $t_j$：假设第$j$次迭代需要检查$while$循环条件的次数为$t_j$ T(n) = c_1n+c_2(n-1) + c_4(n-1) +c_5\\sum_{j=2}^n t_j+c_6\\sum_{j=2}^n (t_j-1)+c_7\\sum_{j=2}^n (t_j-1)+c_8(n-1) best-case：数组是有序的，$t_j=1$检查一次while，不需要后移 T(n) = c_1n+c_2(n-1) + c_4(n-1) +c_5(n-1)+c_8(n-1) = (c_1+c_2+c_4+c_5+c_8)n -(c_2+c_4+c_5+c_8) 即，最好情况下插入排序开销为线性开销。 worest-case：数组是逆序的，那么$t_j = j$（$i=0$也会检查） \\begin{aligned} T(n)=& c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5}(n(n+1) / 2-1)+c_{6}(n(n-1) / 2) \\\\ & c_{7}(n(n-1) / 2)+c_{8}(n-1) \\\\ =&\\left(c_{5} / 2+c_{6} / 2+c_{7} / 2\\right) n^{2} \\\\ &+\\left(c_{1}+c_{2}+c_{4}+c_{5} / 2-c_{6} / 2-c_{7} / 2+c_{8}\\right) n-\\left(c_{2}+c_{4}+c_{5}+c_{8}\\right) \\end{aligned} 运行时间是平方级开销。 在一些算法中，最坏情况经常发生，比如查询数据库 有时候平均情况和最差情况一样糟糕 Order of Growth 忽略低阶项 忽略常数项 2.4 Designing Algorithms Insert Sort：增量法 2.4.1 Divide-and-Conquer To solve P: Divide P into smaller problems P1 , P2 , …, Pk . Conquer by solving the (smaller) subproblems recursively. Combine the solutions to P1 , P2 , …, Pk into the solution for P. note：解决问题前想一想：该问题难以解决是否是因为规模太大了，若是规模足够小，那么是不是可以解决 2.4.2 Merge Sort 使用分治策略，我们首先分析归并排序。 Divide：把n个元素分成两个子序列，每个子序列有$n/2$个元素 Conquer：递归求解两个子问题 Solve the two subsequences recursively Combine：合并两个子序列，得到有序的结果 （1）Merge-Sort函数 假设我们有一个Merge(A,p,q,r)函数，他把两个有序的数组A[p……q]和A[q+1……r]合并 Merge-Sort 输入：需要排序的n个数序列A 输出：有序序列 #include #include #include using namespace std; void Merge_Sort(vector& vec, int start, int end); // 分治算法主体 void Merge(vector& A, int start, int mid, int end); // 合并的过程，重点在合并 void printVec(vector& vec); int main() { vector nums = {8,5,9,10,3,6,2,7}; Merge_Sort(nums, 0, nums.size()-1); printVec(nums); return 0; } void Merge_Sort(vector& vec, int start, int end) { if (start & A, int start, int mid, int end) { int n1 = mid - start + 1; // 数组1个数 int n2 = end - (mid + 1) + 1; // 数组2元素个数 vector vec1(n1+1), vec2(n2+1); // 临时数组初始化 // 数组末尾设为无穷大简化了扫尾工作 vec1[n1] = 99999; vec2[n2] = 99999; // 数组赋值 for (int i = start; i & vec) { for (int i = 0; i 注意分治时采取自上而下的递归处理时，每个分支执行的顺序，如下： 2.4.3 Analysis divide-and-conquer Algorithm （1）符号定义 $T(n)$：$\\text{running time on a problem of size n}$， 问题的运行时间，n为问题规模 $D(n)$：分解的时间开销 $C(n)$：合并的开销 $子问题\\rightarrow 原问题$ 统一模式： T(n)=\\begin{cases}\\Theta(1)&& if\\ n\\leq c\\\\ D(n) + aT(n/b) + C(n)&& otherwise\\end{cases} 当问题规模足够小时，不需要分治。 否则递归求解 （2）MergeSort Analysis T(n)=\\begin{cases}\\Theta(1)&& if\\ n\\leq c\\\\ 2T(n/2) + C(n)=2T(n/2) + \\Theta(n)&& otherwise\\end{cases} 在归并排序中，分解时分解为2个子问题，每个问题的规模是原来的$n/2$。 Claim：$T(n) = nlog2^n$，所有情况下均为$nlgn$【平均、最好、最坏】 证明： 递归到何时终止？$n/x == 1$时终止，次数：除法$log_2^n$，树高$log_2^n+1$ T(n) = cn·lg^n + c'n 代入法证明 Proof by Telescoping T(n) =2T(n/2) + n\\\\ =2(2T(n/4)+n/2) +n=4T(n/4)+2n\\\\ =4(2T(n/8) + n/4) + 2n = 8T(n/8) + 3n\\\\ =……\\\\=nT(n/2^k) + kn\\\\=……\\\\ =nT(n/2^{lgn}) + nlgn 数学归纳法证明 T(n) = nlgn var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH3：Growth of Functions.html":{"url":"算法/CH3：Growth of Functions.html","title":"CH3：Growth of Functions","keywords":"","body":"CH3：Growth of Functions Topics： Growth of Functions O/\\Theta/\\Omega notations Asymptotic Growth： We want to express rate of growth of standard functions: the leading term with respect to n 【第一项】 ignoring constants in front of it 【忽略常数项】 3.1 Asymptotic Notation 3.1.1 O-notation O(g(n)) = {f(n) ：There exist positive constants c and n_0 such that 0≤f(n) ≤cg(n) for all $n≥n_0$} O(.) 用来渐近表示计算时间的上届 —— 【最坏情况】 O(.) is used to bound worest-case running time 将f(n)用简洁的O(.)来表示 任何一个二次多项式都是$O(n^2)$ Note： When we say \"the running time is O(n)\"：the worest case running time is O(n) We often write f(n) = O(g(n)), instead of f(n) ∈ O(g(n)) Use O(n) in equations：2n^2+3n+1 = 2n^2+O(n) 3.1.2 $\\Omega-notation$ \\Omega(g(n)) = \\{\\text{There exist positive constants c and n0 such that 0=n0}\\} 【大于g（n）的整数倍】 \\Omega-notation用于给出函数的下界 任何一个二次多项式都是\\Omega(n^2)的。 3.1.3 \\Theta-notation \\Theta(g(n)) = \\{\\text{There exist positive constants c and n0 such that } 0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n)\\ \\text{for all n>=n0}\\} \\Theta(g(n))提供了函数的一个tight bound 紧致界 $f(n) = \\Theta(g(n))$当且仅当f(n) = O(g(n))并且f(n) =\\Omega(g(n)) 只要最高次项，那就是$\\Theta(.)$ Note： We often think of f(n) = O(g(n)) as corresponding to f(n)≤ g(n) f(n) = \\Theta(g(n)) corresponds to f(n) = g(n) f(n) = \\Omega(g(n)) corresponds to f(n) ≥ g(n) Example： 4n^3 + 3n^2 + 2n + 1 = 4n^3 + 3n^2 + Θ(n)= 4n^3 + Θ(n^2) = Θ(n^3) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH3：Growth of Functions_review.html":{"url":"算法/CH3：Growth of Functions_review.html","title":"CH3：Growth of Functions_review","keywords":"","body":"CH3：Growth of Functions MindMap Asymptotic Growth 分析算法时我们对算法输入规模为n时的最坏情况下运行时间函数感兴趣 不考虑常数项 不考虑低阶项 3.1 Asymptotic Notation 3.1.1 O-Notation （1）定义 O(g(n)) = \\{f(n):\\text{There exists positive c and }n_0\\text{ such that } 0\\leq f(n)\\leq cg(n)\\text{ for all }n\\geq n_0\\} 正整数c 正整数n0 g(n)是最高次项 exists：存在即可 **$O(g(n))$是一个满足上述条件的运行时间函数的集合** $O(.)$：用于渐进上界函数 $\\text{is used to asymptotic upper bound a function}$ $O(.)$：用来表示最坏情况的运行时间$\\text{is used to bound worst-case running time}$ （2）Example （3）使用情况 当我们说道“运行时间是O(n)”时，我们指的是最坏情况下的运行时间是O(n) 通常写为：$f(n) = O(g(n))$，而不是$f(n)\\in O(g(n))$——虽然是个集合 我们也在等式中使用$O(n)$，例子： 2n^2+3n +1 = 2n^2 +O(n) $O(1)$表示常数时间 3.1.2 $\\Omega-Notation$ （1）定义 \\Omega(g(n)) = \\{f(n):\\text{There exists positive c and }n_0\\text{ such that } 0\\leq cg(n)\\leq f(n) \\text{ for all }n\\geq n_0\\} 我们使用$\\Omega(.)$来表示运行时间的下界 （2）Example when we say “the running time is $Ω(n^2 )$” we mean that the best-case running time is $Ω(n^2)$ ——the worst case might be worse. 3.1.3 $\\Theta-Notation$ （1）定义 \\Theta(g(n)) = \\{f(n):\\text{There exists positive }c_1，c_2\\text{ and }n_0\\text{ such that } 0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n) \\text{ for all }n\\geq n_0\\} 我们使用$\\Theta-Notation$来表示紧致界 充要条件：$f(n) = Θ(g(n))\\ if\\ and\\ only\\ if\\ f(n) =O(g(n))\\ \\ and\\ \\ f(n) = Ω(g(n))$ （2）Example 3.1.4 总结 （1）表示法 （2）在等式中的使用 使用$O、\\Theta、\\Omega$在函数中替换低阶项简化函数表达 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"markdown 简洁优雅的排版语言,简化版的 HTML,加强版的 TXT,详情请参考 https://xinwuyun.github.io/markdown/ git 分布式版本控制系统,详情请参考 https://xinwuyun.github.io/git/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"}}