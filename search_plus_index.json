{"./":{"url":"./","title":"简介","keywords":"","body":"Summary 软工大三下笔记 算法分析与设计笔记 CH1：Introduction CH2：算法入门 CH2：算法入门_review CH3：Growth of Functions CH3：Growth of Functions_review CH4：Recurrences CH6：HeapSort CH7：QuickSort CH8：Sorting in linear time CH9：Medians and Order Statistics CH10：Divide and Conquer：More Algorithms 软件体系结构 CH2：Achitecture_Style CH4：理解质量属性 CH5：ATMA var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/about.html":{"url":"算法/about.html","title":"算法分析与设计","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH1：Introduction.html":{"url":"算法/CH1：Introduction.html","title":"CH1：Introduction","keywords":"","body":"CH1：Introduction 1.1 Factors of Programming programming language IDE software achitecture 架构： 架构的类型： \\begin{cases}C2\\ Style：conponent\\ \\& \\ connector\\\\Pipe-Fliter\\ Style:输入\\rightarrow 输出\\\\Repositories\\ Style：以某一数据源为中心的操作\\end{cases} 成熟的模式：逐步产生商业架构 Java EE CORBA .NET（与javaEE类似） 1.2 More Important 1.2.1 Transaction finish or null 1.2.2 Security 1.3 DS and Algorithm 1.3.1 Algorithm Concept：A well-Defined computational procedure that takes some value, or set of values, as input and proceduces some value, or set of values, as output. Broadly：a step-step procedure for solving a problem or accomplishing some end especially by a computer. issues： correctness efficiency(amount of work done and space used) storage(simplicity, clarity) optimality 1.3.2 Promblem that can be solved by algorithm 基因工程 网络 电子商务 生产 一个经典的问题：you are given n integers(there may be negative ones but not all) a1, a2, ..., an, determine i and j which maximize the sum from $a_i$ to $a_j$. Case：6 integers：(-2, 11, -4, 13, -5, -2) Ans：i = 2, j = 4, max sum is 20 1.3.3 Importance of algorithms 问题：给1000,000个整数排序 数据量 主频 算法时间复杂度 计算时间 1000000 1GHz $2n^2$ $2\\times 10^5\\ seconds$ 1000000 100MHz $50nlgn$ $105\\ seconds$ 加之主频的提升不大，算法更为重要 1.3.4 About course Design and Analysis 怎么找算法？ 评价算法，定量 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH2：算法入门.html":{"url":"算法/CH2：算法入门.html","title":"CH2：算法入门","keywords":"","body":"CH2：算法入门 The problem of sorting input：sequence of n natural numbers output：permutation such that $a_1'\\leq a_2'\\leq ....\\leq a_n'$ 2.1 Insert Sort 算法： for(i = 2; i = 1 and A[j] > key){ A[j+1] = A[j]; // 后移 j--; } A[j+1] = key; } 2.2 Kinds of Analysis worstest - case（usually）：最坏情况优先考虑 Average - case（sometimes） Best - case（bogus） 2.2.1 循环不变式 loop-invariants Proving correctness Using Loop-invariants【外层为循环】 需要证明的三个性质： 初始化：它在循环的第一轮迭代开始时，应该是正确的 保持：如果在某一次的迭代开始前是正确的，那么在下一次迭代开始前，他也应该保持正确 终止：不变式给了一个有用的性质，表明算法是正确的 2.2.2 运行时间 （1）Running Time 运行时间的取决因素： 输入序列：已经排列好的序列【数据特征】 数据规模：更短的序列更容易排好 通常，我们考虑运行时间的上界，因为这是一个保证 （2）Machine-independent time 插入排序的最差时间取决于计算机的速度： 相对速度（on the same machine）——关注算法 绝对速度（on different machine） 通常我们忽视机器相关时间的限制，关注“the growth of T(n) as n → ∞” 称为渐近分析“Asympotic Analysis” （3）$\\theta-$notation 关心增长率，低阶和常数丢弃 Drop low-order terms; ignore leading constants Example：$3n^3+90n^2-5n+6046 = \\theta(n^3)$ 当n变得足够大时，一个$\\theta(n^2)$的算法总会打败一个$\\theta(n^3)$的算法 2.2.3 Insertion Sort Analysis Worest case：Input reverse sorted【逆序的序列】 T(n) = \\sum\\limits_{j = 2,...,n}\\theta(j) = \\theta(n^2) Average case：All permutations equally likely T(n) = \\sum\\limits_{j = 2,...,n}\\theta(j/2)=\\theta(n^2) 2.3 Analysis Algorithm Analysis An Algorithm： 算法分析指的是对一个算法所需的资源进行分析，预测算法所需的资源，包括内存、通信带宽或计算机硬件等。 但是通常我们更想测量计算时间。 2.3.1 RAM RAM：单处理机，随机存储模型 random-access-machine（RAM） Model with no concurrent operations 不考虑并发 executed as an atom operation 不考虑中断，原子操作 每条指令需要固定时间 内存容量足够大 在RAM模型下，对基础的操作进行计数即可 count fundamental operation。 2.3.2 Analysis of Insert Operation 插入排序的时间计算如下： T(n) = c_1n+c_2(n-1) + c_4(n-1)+c_5\\sum\\limits_{j=2}^nt_j+c_6\\sum\\limits_{j=2}^n(t_j-1) + c_7\\sum\\limits_{j=2}^n(t_j-1)+c_8(n-1)\\\\ best case：数组是有序的 **$t_j = 1$，检查一次，不需要后移** T(n) = c_1n+c_2(n-1) + c_4(n-1)+c_5(n-1)+c_8(n-1)\\\\=(c_1+c_2+c_4+c_5+c_8)n-(c_2+c_4+c_5+c_8) 运行时间是n的线性函数 worest case：数组是倒序的 **$t_j = j$，检查一次，不需要后移** T(n) = c_1n+c_2(n-1)+c_4(n-1)+c_5(n(n+1)/2-1)+c_6(n(n-1)/2)+c_7(n(n-1)/2)+c_8(n-1)\\\\=(c_5/2+c_6/2+c_7/2)n^2+(c_1+c_2+c_4+c_5/2-c_6/2-c_7/2+c_8)n-(c_2+c_4+c_5+c_8) 运行时间是n的二次函数。 note： 对于某些算法来说，最坏情况经常发生 平均情况有时候和一般情况一样糟糕 2.3.3 Order of Growth 我们只考虑运行时间的增长顺序: 我们可以忽略低阶项，因为对于非常大的n，它们相对不重要。 我们也可以忽略前项的常系数，因为对于非常大的n，它们对计算效率的增长速度并不重要。 我们刚刚说过，最好的情况是n的线性而最坏/平均的情况是n的二次型。 2.4 Designing Algorithm 2.4.1 Divide and Conquer To solve P： Divide P into smaller problems P_1, P_2, ... , P_k Conquer by solving the (smaller) subproblems recursively Combine the solutions to P_1,P_2,...,P_k into the solution for P （1）Merge Sort Using Divide and Conquer, we can obtain a merge sort algorithm Divide：divide n elements into two subsequences of n/2 elements each Conquer：Solve the two subsequences recursively Combine：Merge the two sorted subsequences to produce the sorted answer Merge-Sort(A，p，r) INPUT: a sequence of n numbers stored in array A OUTPUT: an ordered sequence of n numbers MergeSort(A,p,r) if p Actions of Merge Sort： 2.4.2 Analysis divide and conquer Algorithm $T(n)$ running time on a problem of size n 【n ：问题规模】 假设把原问题分成a个子问题，每个子问题是原问题规模的$1/b$ 对于MergeSort来说，a = 2，每个问题的规模是原问题的1/b $D(n)$ 分解的开销 $C(n)$ 合并的开销 子问题 --合并-->原问题 MergeSort Recurrence Equation T(n) = \\begin{cases}\\Theta(1)\\quad if\\ n≤c\\\\ aT(n/b)+D(n) + C(n)\\quad otherwise\\end{cases} 对于MergeSort来说，递归式如下： T(n) = \\begin{cases}\\Theta(1)\\quad if\\ n≤c\\\\ 2T(n/2)+\\Theta(n)\\quad otherwise\\end{cases} Claim： T(n) = nlog_2^n 所有情况下均为nlog_2^n 最好 最坏 平均 $log_2^n+1$是针对结点的，若是针对边则是$log_2^n$。每层的和是一定的，都是cn 所以总的花费时间为： \\sum_{i=1}^{log_2^n} cn = cn·log_2^n Proof by Telescoping T(n) = 2T(n/2)+n = 2(2T(n/4) + n/2)+n = 4T(n/4)+2n\\\\ =......=nT(n/n)+log_2^n n=nT(1)+nlog_2^n var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH2：算法入门_review.html":{"url":"算法/CH2：算法入门_review.html","title":"CH2：算法入门_review","keywords":"","body":"CH2 算法入门 MindMap 排序问题： 输入：序列$$ 输出：非降序排列：$$，满足$a_1'\\leq a_2'\\leq...\\leq a_n'$ 2.1 Insert Sort 程序： void insertSort(vector& vec) { for (int i = 2; i 0 && vec[j] > key) { vec[j+1] = vec[j]; // 后移操作 j--; } vec[j+1] = key; } } 注意后移操作：A[j+1] = A[j] 若位置0处数字为负无穷，那么while循环中将不用写条件j>0。 2.2 Analysis of algorithms 2.2.1 运行时间 Running Time： 数据的初始特征 数据规模 we seek upper bounds on the running time Kinds of Analysis： Worst - case（usually 最坏情况最优先考虑） Average - case（sometimes） Best - case（bogus） 2.2.2 loop-invariant Proving correctness using loop-invariant：最外层必须是循环，证明某一性质每一次循环都不变 需要证明的三个性质 初始化：他在循环的第一轮迭代开始前，应该是正确的 保持：如果在某一次的迭代开始前是正确的，那么在下一次的迭代开始前他也应该保持正确 终止：循环结束时，不变式给了一个有用的性质，表明算法是正确的 使用循环不变式证明插入排序 证明：在每次迭代开始前子数组A[1...j-1]中元素为原数组中的A[1...j-1]，但是是有序的 初始化 j = 2 保持：A[j - 1], A[j - 2],… are moved one at a time till the proper position for A[j] is found. 结束：当j=n+1时，整个序列有序 2.2.3 机器独立时间 machine independent time relative time：在相同的机器上——关注算法 absolute time：在不同的机器上 忽略机器相关的约束，直接考虑 $n\\rightarrow \\infty$时的$T(n)$ —— 渐近分析 Asymptotic Analysis 2.2.4 $\\Theta-Notation$ （1）定义 $\\Theta$表示法的定义： 数学定义：$\\Theta(g(n)) = {存在正整数c_1和c_2，并且n_0>0，满足当所有的n\\geq n_0时，0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n)}$ 工程上：关心增长率，低阶和常数项丢弃 Example：$3n^3 + 9n^2-5n+8344 = \\Theta(n^3)$ （2）Asyptotic Performance 当n变得足够大的时候，一个$\\Theta(n^2)$的算法一定比一个$\\theta(n^3)$的算法要好 2.2.5 Insertion sort analysis 最差情况：输入是逆序的——每个数都要前移 T(n) = \\sum_{j=2..n}\\Theta(j)=\\Theta(n^2) 平均情况： T(n) = \\sum_{j=2..n}\\Theta(j/2)=\\Theta(n^2) 2.3 算法分析的入门 2.3.1 算法分析的概念 算法分析指的是对一个算法所需的资源进行分析，内存，通信带宽或者计算机硬件是主要关心的，但通常希望测量计算时间。 在我们分析算法之前，我们必须有一个将要使用的实现技术的模型，包括该技术的资源及其成本的模型 算法实现的技术模型：单处理器，随机存储模型[RAM] 2.3.2 Random Access Model 不考虑并发 不考虑中断，原子操作 假设每条指令花费常数时间 内存足够大 …… 在RAM模型下，需要考虑的是基本操作的次数 counting fundamental operations 2.3.3 Analysis of insert operation $cost$：每次基本操作花费的代价 $t_j$：假设第$j$次迭代需要检查$while$循环条件的次数为$t_j$ T(n) = c_1n+c_2(n-1) + c_4(n-1) +c_5\\sum_{j=2}^n t_j+c_6\\sum_{j=2}^n (t_j-1)+c_7\\sum_{j=2}^n (t_j-1)+c_8(n-1) best-case：数组是有序的，$t_j=1$检查一次while，不需要后移 T(n) = c_1n+c_2(n-1) + c_4(n-1) +c_5(n-1)+c_8(n-1) = (c_1+c_2+c_4+c_5+c_8)n -(c_2+c_4+c_5+c_8) 即，最好情况下插入排序开销为线性开销。 worest-case：数组是逆序的，那么$t_j = j$（$i=0$也会检查） \\begin{aligned} T(n)=& c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5}(n(n+1) / 2-1)+c_{6}(n(n-1) / 2) \\\\ & c_{7}(n(n-1) / 2)+c_{8}(n-1) \\\\ =&\\left(c_{5} / 2+c_{6} / 2+c_{7} / 2\\right) n^{2} \\\\ &+\\left(c_{1}+c_{2}+c_{4}+c_{5} / 2-c_{6} / 2-c_{7} / 2+c_{8}\\right) n-\\left(c_{2}+c_{4}+c_{5}+c_{8}\\right) \\end{aligned} 运行时间是平方级开销。 在一些算法中，最坏情况经常发生，比如查询数据库 有时候平均情况和最差情况一样糟糕 Order of Growth 忽略低阶项 忽略常数项 2.4 Designing Algorithms Insert Sort：增量法 2.4.1 Divide-and-Conquer To solve P: Divide P into smaller problems P1 , P2 , …, Pk . Conquer by solving the (smaller) subproblems recursively. Combine the solutions to P1 , P2 , …, Pk into the solution for P. note：解决问题前想一想：该问题难以解决是否是因为规模太大了，若是规模足够小，那么是不是可以解决 2.4.2 Merge Sort 使用分治策略，我们首先分析归并排序。 Divide：把n个元素分成两个子序列，每个子序列有$n/2$个元素 Conquer：递归求解两个子问题 Solve the two subsequences recursively Combine：合并两个子序列，得到有序的结果 （1）Merge-Sort函数 假设我们有一个Merge(A,p,q,r)函数，他把两个有序的数组A[p……q]和A[q+1……r]合并 Merge-Sort 输入：需要排序的n个数序列A 输出：有序序列 #include #include #include using namespace std; void Merge_Sort(vector& vec, int start, int end); // 分治算法主体 void Merge(vector& A, int start, int mid, int end); // 合并的过程，重点在合并 void printVec(vector& vec); int main() { vector nums = {8,5,9,10,3,6,2,7}; Merge_Sort(nums, 0, nums.size()-1); printVec(nums); return 0; } void Merge_Sort(vector& vec, int start, int end) { if (start & A, int start, int mid, int end) { int n1 = mid - start + 1; // 数组1个数 int n2 = end - (mid + 1) + 1; // 数组2元素个数 vector vec1(n1+1), vec2(n2+1); // 临时数组初始化 // 数组末尾设为无穷大简化了扫尾工作 vec1[n1] = 99999; vec2[n2] = 99999; // 数组赋值 for (int i = start; i & vec) { for (int i = 0; i 注意分治时采取自上而下的递归处理时，每个分支执行的顺序，如下： 2.4.3 Analysis divide-and-conquer Algorithm （1）符号定义 $T(n)$：$\\text{running time on a problem of size n}$， 问题的运行时间，n为问题规模 $D(n)$：分解的时间开销 $C(n)$：合并的开销 $子问题\\rightarrow 原问题$ 统一模式： T(n)=\\begin{cases}\\Theta(1)&& if\\ n\\leq c\\\\ D(n) + aT(n/b) + C(n)&& otherwise\\end{cases} 当问题规模足够小时，不需要分治。 否则递归求解 （2）MergeSort Analysis T(n)=\\begin{cases}\\Theta(1)&& if\\ n\\leq c\\\\ 2T(n/2) + C(n)=2T(n/2) + \\Theta(n)&& otherwise\\end{cases} 在归并排序中，分解时分解为2个子问题，每个问题的规模是原来的$n/2$。 Claim：$T(n) = nlog2^n$，所有情况下均为$nlgn$【平均、最好、最坏】 证明： 递归到何时终止？$n/x == 1$时终止，次数：除法$log_2^n$，树高$log_2^n+1$ T(n) = cn·lg^n + c'n 代入法证明 Proof by Telescoping T(n) =2T(n/2) + n\\\\ =2(2T(n/4)+n/2) +n=4T(n/4)+2n\\\\ =4(2T(n/8) + n/4) + 2n = 8T(n/8) + 3n\\\\ =……\\\\=nT(n/2^k) + kn\\\\=……\\\\ =nT(n/2^{lgn}) + nlgn 数学归纳法证明 T(n) = nlgn var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH3：Growth_of_Functions.html":{"url":"算法/CH3：Growth_of_Functions.html","title":"CH3：Growth of Functions","keywords":"","body":"CH3：Growth of Functions Topics： Growth of Functions O/\\Theta/\\Omega notations Asymptotic Growth： We want to express rate of growth of standard functions: the leading term with respect to n 【第一项】 ignoring constants in front of it 【忽略常数项】 3.1 Asymptotic Notation 3.1.1 O-notation O(g(n)) = {f(n) ：There exist positive constants c and n_0 such that 0≤f(n) ≤cg(n) for all $n≥n_0$} O(.) 用来渐近表示计算时间的上届 —— 【最坏情况】 O(.) is used to bound worest-case running time 将f(n)用简洁的O(.)来表示 任何一个二次多项式都是$O(n^2)$ Note： When we say \"the running time is O(n)\"：the worest case running time is O(n) We often write f(n) = O(g(n)), instead of f(n) ∈ O(g(n)) Use O(n) in equations：2n^2+3n+1 = 2n^2+O(n) 3.1.2 $\\Omega-notation$ \\Omega(g(n)) = \\{\\text{There exist positive constants c and n0 such that 0=n0}\\} 【大于g（n）的整数倍】 \\Omega-notation用于给出函数的下界 任何一个二次多项式都是\\Omega(n^2)的。 3.1.3 \\Theta-notation \\Theta(g(n)) = \\{\\text{There exist positive constants c and n0 such that } 0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n)\\ \\text{for all n>=n0}\\} \\Theta(g(n))提供了函数的一个tight bound 紧致界 $f(n) = \\Theta(g(n))$当且仅当f(n) = O(g(n))并且f(n) =\\Omega(g(n)) 只要最高次项，那就是$\\Theta(.)$ Note： We often think of f(n) = O(g(n)) as corresponding to f(n)≤ g(n) f(n) = \\Theta(g(n)) corresponds to f(n) = g(n) f(n) = \\Omega(g(n)) corresponds to f(n) ≥ g(n) Example： 4n^3 + 3n^2 + 2n + 1 = 4n^3 + 3n^2 + Θ(n)= 4n^3 + Θ(n^2) = Θ(n^3) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH3：Growth_of_Functions_review.html":{"url":"算法/CH3：Growth_of_Functions_review.html","title":"CH3：Growth of Functions_review","keywords":"","body":"CH3：Growth of Functions MindMap Asymptotic Growth 分析算法时我们对算法输入规模为n时的最坏情况下运行时间函数感兴趣 不考虑常数项 不考虑低阶项 3.1 Asymptotic Notation 3.1.1 O-Notation （1）定义 O(g(n)) = \\{f(n):\\text{There exists positive c and }n_0\\text{ such that } 0\\leq f(n)\\leq cg(n)\\text{ for all }n\\geq n_0\\} 正整数c 正整数n0 g(n)是最高次项 exists：存在即可 **$O(g(n))$是一个满足上述条件的运行时间函数的集合** $O(.)$：用于渐进上界函数 $\\text{is used to asymptotic upper bound a function}$ $O(.)$：用来表示最坏情况的运行时间$\\text{is used to bound worst-case running time}$ （2）Example （3）使用情况 当我们说道“运行时间是O(n)”时，我们指的是最坏情况下的运行时间是O(n) 通常写为：$f(n) = O(g(n))$，而不是$f(n)\\in O(g(n))$——虽然是个集合 我们也在等式中使用$O(n)$，例子： 2n^2+3n +1 = 2n^2 +O(n) $O(1)$表示常数时间 3.1.2 $\\Omega-Notation$ （1）定义 \\Omega(g(n)) = \\{f(n):\\text{There exists positive c and }n_0\\text{ such that } 0\\leq cg(n)\\leq f(n) \\text{ for all }n\\geq n_0\\} 我们使用$\\Omega(.)$来表示运行时间的下界 （2）Example when we say “the running time is $Ω(n^2 )$” we mean that the best-case running time is $Ω(n^2)$ ——the worst case might be worse. 3.1.3 $\\Theta-Notation$ （1）定义 \\Theta(g(n)) = \\{f(n):\\text{There exists positive }c_1，c_2\\text{ and }n_0\\text{ such that } 0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n) \\text{ for all }n\\geq n_0\\} 我们使用$\\Theta-Notation$来表示紧致界 充要条件：$f(n) = Θ(g(n))\\ if\\ and\\ only\\ if\\ f(n) =O(g(n))\\ \\ and\\ \\ f(n) = Ω(g(n))$ （2）Example 3.1.4 总结 （1）表示法 （2）在等式中的使用 使用$O、\\Theta、\\Omega$在函数中替换低阶项简化函数表达 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH4：Recurrences.html":{"url":"算法/CH4：Recurrences.html","title":"CH4：Recurrences","keywords":"","body":"CH4：Recurrences MindMap Review： MergeSort 分析MergeSort的时间复杂度 递归树 Picture of Recursion Tree 迭代法 Telescoping 数学归纳法 Mathematical Induction 渐近分析 $O-Notation$ $\\Omega-Notation$ $\\Theta-Notation$ 算法包含对自身的调用时，其运行时间可以用递归式表示： $MergeSort：T(n) = aT(n/b) +D(n) +C(n) = 2T(n/2) + O(n)$ 3种求解递归函数的方法： 代换法-------------Substitution 递归树法----------Recursion Tree 主方法-------------Master Method 4.1 Substitution Method 代换法 （1）步骤 步骤： 猜测一个解的形式 Guess the form of solution 使用数学归纳法证明 Verify by induction 求解常数项 Solve for constants （2）例子 Example1：$T(n) = 4T(n/2) + 100n$ 猜测：$O(n^3)$（如果要证明$\\Theta$的话，那么要分别证明O和$\\Omega$） 归纳基础：$T(1) = \\Theta(1)$ 归纳假设：$T(k) \\leq ck^3 $在$k 使用数学归纳法证明：$T(n) \\leq cn^3$ 证明： \\begin{aligned} \\mathrm{T}(\\mathrm{n}) &=4 \\mathrm{~T}(\\mathrm{n} / 2)+100 n \\\\ & \\leq 4 \\mathrm{c}(\\mathrm{n} / 2)^{3}+100 n \\\\ &=(\\mathrm{c} / 2) n^{3}+100 n \\\\ &=\\mathrm{cn}^{3}-\\left((\\mathrm{c} / 2) n^{3}-100 n\\right)\\\\ &\\leq\\mathrm{cn}^{3} \\end{aligned} 最后确定c和n的值即可： Example2：$T(n) = 2T(\\lfloor n/2\\rfloor) + n$ 要严格遵守证明的结果的模式，下面的证明是错误的： Example3：尝试变量替换 考虑：$T(n) = 2T(\\sqrt{n}) + lgn$ Rename：$m = lgn\\Rightarrow T(2^m) = 2T(2^{\\frac{m}{2}})+m$ 令$S(m) = T(2^m)$，则有：$S(m) = 2S(m/2) + m$ 设当$m_0\\leq m$时有：$S(m_0)\\leq cm_0lgm_0$ S(m) = 2S(m/2) + m\\\\ \\leq 2c(m/2)lg(m/2) + m\\\\ =cmlg(m/2)+m\\\\=cmlgm-cm + m\\\\ =cmlgm-(c-1)m\\\\=O(mlgm) 转换回来 $T(2^m) = S(m) = O(mlgm)$ $T(m) = O(lgmlgm)$ $T(n) = O(lgnlglgn)$ （3）猜测方法 使用代换法的一个重要技巧是要猜测 猜测的方式： 递归树的方法帮助猜测 与先前见过的相似 先整较松的上届然后缩小区间 降低上届，提高下界，缩小不确定区间 4.2 Recursion-tree Method 递归树是一个好的猜测的直接方法 递归树方法可能不可靠，就像任何使用省略号的方法一样 4.2.1 例子说明 $T(n) = 3T(n/4) + \\Theta(n^2)$ （1）递归树猜测上界 最后一层叶子数：$3^{log_4^n} = n^{log_4^3}$ 每层开销：$((\\frac{3}{16})^icn^2)$ 总开销：$cn^2 + (\\frac{3}{16})cn^2+(\\frac{3}{16})^2cn^2+......+(\\frac{3}{16})^{log_4^n-1}cn^2 + O(n^{log_4^3})=\\frac{1\\times (1-(\\frac{3}{16})^{log_4^n+1})}{1-\\frac{3}{16}}+O(n^{log_4^3})$ 使用等比数列的上界作为上限： cn^2\\sum_{i=0}^{log_4^n-1}(\\frac{3}{16})^i = \\frac{cn^2}{1-\\frac{3}{16}}=\\frac{13}{16}cn^2 所以： T(n) =cn^2 + (\\frac{3}{16})cn^2+(\\frac{3}{16})^2cn^2+......+(\\frac{3}{16})^{log_4^n-1}cn^2 + O(n^{log_4^3})=\\frac{1\\times (1-(\\frac{3}{16})^{log_4^n+1})}{1-\\frac{3}{16}}+O(n^{log_4^3})\\\\ \\leq \\frac{13}{16}cn^2 +O(n^{log_4^3}) = O(n^2) （2）迭代法证明 递归基础：$T(1) = O(1)$ 归纳假设：$T(k) \\leq ck^2，当k 证明：$T(n) \\leq cn^2$ T(n) = 3T(n/4) + d(n^2)\\\\ \\leq 3c(n/4)^2 + d(n^2)\\\\ =\\frac{3}{16}cn^2 + d(n^2)\\\\ \\leq cn^2 当$d\\geq \\frac{16}{13}c$时成立。 4.3 Master Method “cook book” Method for solving recurrences of the form: T(n) = aT(n/b) + f(n)\\\\ 其中a \\geq 1 , b >1 叶子的个数：$a^h = a^{log_b^n} = n^{log_b^a}$ 比较树根$f(n)$和$n^{log_b^a}$ 三种情况： 由根到叶子\\begin{cases}减少\\\\不变\\\\增大\\end{cases} 4.3.1 Compare f(n) with $n^{log_b^a}$ （1）$f(n) = O(n^{log_{b}^{a}-\\epsilon})$ 叶子开销严格大于树根 $f(n)$多项式增长慢于$n^{log_b^a}(by\\ an\\ n^{\\epsilon}\\ factor)$ $Solution:T(n) = \\Theta(n^{log_b^a})$ 注意是$\\Theta$ （2）$f(n) = O(n^{log_{b}^{a}}(lgn)^k)$ 树根开销为叶子开销的$lgn$的$k$次方倍 其中$k\\geq 0$，整数 $Solution:T(n) = \\Theta(n^{log_b^a}lgn^{k+1})$最终结果多乘以一个树高的k次方 （3）$f(n) = O(n^{log_{b}^{a}+\\epsilon})$ 叶子开销小于树根开销 需要额外满足$af(n/b)\\leq cf(n)$ $T(n)=\\Theta(f(n))$树根量级 4.3.2 Conclusion （1）方法总结 树根和叶子比较，同时要注意什么时候写$O$，什么时候写$\\Omega$，什么时候 例题： Example1 T(n) = 9T(n/3) + n $f(n) = n = O(n^{log_b^{a}-\\epsilon})= n^{2-\\epsilon}$，其中$\\epsilon = 1$ 所以$T(n) = \\Theta(n^2)$ Example2 T(n) = T(2n/3) + 1 $f(n) = 1 = \\Theta(n^{log_{\\frac{3}{2}}^1}lg^kn)$，其中$k=1$ 所以$T(n) = \\Theta(lgn)$ Example3 T(n) = 3T(n/4) +nlgn $f(n) = nlgn = \\Omega(n^{log_4^3}+\\epsilon)$，其中$\\epsilon ≈ 0.2$ 且$af(n/b) = 3f(n/4) = 3\\frac{n}{4}lg{\\frac{n}{4}}=\\frac{3n}{4}(lgn-2)\\leq cnlgn$ 当$c = \\frac{3}{4}, n\\geq 1$时成立。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH6：HeapSort.html":{"url":"算法/CH6：HeapSort.html","title":"CH6：HeapSort","keywords":"","body":"CH6：HeapSort MindMap Topics： Heaps HeapSort Priority queue Recap and Overview 强调稳定性时多关注的是多关键字排序。 插入排序 时间复杂度是$O(n^2)$，原地排序 归并排序 时间复杂度是$O(nlgn)$，需要辅助存储空间 堆排序 时间复杂度是$\\Theta(nlgn)$，原地排序 快排 平均情况的时间复杂度是$O(nlgn)$，原地排序 线性时间的排序 6.1 Heap 6.1.1 堆存储和堆数据结构 （1）堆内存的使用 堆的使用： 内存的分类 \\begin{cases}栈内存：局部变量，方法和函数\\\\ 堆内存：malloc\\ new\\\\ 静态方法区：全局变量\\end{cases} （2）堆数据结构的使用 堆数据结构： 元素按照下标索引——堆数据结构的实现是一个一维数组 每个元素支持：PARENT，LEFT和RIGHT操作 父子关系的映射逻辑为： 若数组下标从1开始，那么父子映射关系函数为： $PARENT(i) = \\lfloor i/2 \\rfloor$ $LEFT(i) = 2i$ $RIGHT(i) = 2i+1$ 若数组下标从0开始，那么父子映射关系函数为： $PARENT(i) = \\lceil i/2 \\rceil -1$ $LEFT(i) = 2i+1$ $RIGHT(i) = 2i+2$ int getParent(int child) { return ceil(child / 2.0) - 1; } int getLeft(int parent) { return parent * 2 + 1; } int getRight(int parent) { return parent * 2 + 2; } 堆中父子的大小关系 \\begin{cases}大顶堆：A[PARENT(i)]\\geq A[i]\\\\ 小顶堆：A[PARENT(i)]\\leq A[i]\\end{cases} 堆中的第一个元素是$A[0]$或者$A[1]$，对应两种不同的情况 结点的高度是从该结点到叶子结点的最长路径。 堆的高度是树根的高度。 叶子结点的高度为0，树根的高度为树的高度。 有n个结点的树的高度为$\\lfloor lgn\\rfloor$ （3）时间复杂度概述 MAX-HEAPIFY：保证堆是一个大顶堆，时间复杂度是$O(lgn)$ Build-Max-Heap：建堆，时间复杂度是$O(n)$ 堆排序：堆排序时，我们首先要建成一个大顶堆，然后反复执行，取下结点后调用MAX-HEAPIFY的过程，时间复杂度是$O(nlgn)$ 6.1.2 堆的建立 建堆两种方式：递归建堆和非递归建堆 （1）递归建堆 递归建堆三个步骤：分、治、合并 分：分解成子树 治：递归处理左子树和右子树 合并：MaxHeapify void buildMaxHeap(int parent, vector& vec) { if (parent （2）非递归建堆 非递归建堆过程采用循环的建堆方式，从最后一个非叶子结点开始，逐步建堆 最后一个非叶子结点的下标：$\\lfloor vec.size()/2\\rfloor$ void buildMaxHeap_iteration(vector& vec) { int last_non_leaf = vec.size() / 2; for (int i = last_non_leaf; i >= 0; i--) { maxHeapify(vec, i); } } （3）合并过程：MAXHEAPIFY MaxHeapify()时间复杂度为$O(h)$，其中$h$是树的高度，$h = \\lfloor lgn \\rfloor $ 递归写法 写成递归处理的形式如下： void maxHeapify(vector& vec, int parent) { int largest = parent; int left = getLeft(parent); int right = getRight(parent); // 找到父子之间最大值的位置 if (left vec[largest]) { // 注意短路判决 largest = left; } if (right vec[largest]) { // 注意短路判决 largest = right; } // 更换位置 if (largest != parent) { int temp = vec[largest]; vec[largest] = vec[parent]; vec[parent] = temp; // 接着maxheapify处理子树 maxHeapify(vec, largest); } } 循环写法 上述的写法是在结束的时候调用递归处理，这种写法很容易改成循环的形式。如下： void maxHeapify(vector& vec, int parent) { int largest = parent; bool ifChange = true; while(ifChange) { int left = getLeft(parent); int right = getRight(parent); // 找到父子之间最大值的位置 if (left vec[largest]) { // 注意短路判决 largest = left; } if (right vec[largest]) { // 注意短路判决 largest = right; } // 更换位置 if (largest != parent) { // 需要交换 int temp = vec[largest]; vec[largest] = vec[parent]; vec[parent] = temp; ifChange = true; }else{ ifChange = false; } } } （4）运行时间分析 若采取直接的方式分析运行时间，那么时间将会是： T(n) = O(n/2)\\times O(lgn) = O(nlgn) **key observation：** T(n) = 2T(n/2) + O(lgn) $f(n) = lgn = O(n^{log_2^2-\\epsilon})=O(n^{1-\\epsilon})$ 所以堆排序的时间复杂度为$\\Theta(n)$ 6.1.3 堆排序 堆排序策略：每次取出堆顶的元素，使用堆中最后一个元素与堆顶元素交换，然后调用MaxHeapify void HeapSort(vector& vec) { int size = vec.size(); // 从0开始的 for (int i = size - 1; i >= 1; i--) { // 从最后一个结点开始 int temp = vec[i]; vec[i] = vec[0]; vec[0] = temp; size = size - 1; maxHeapify(vec, 0, size); } } 时间复杂度：$O(nlgn)$ 原地排序 inplace 不稳定排序 6.2 PriorityQueue 6.2.1 应用 最大值优先队列的应用： 在共享计算机上调度工作 实现优先队列 最小值优先队列应用： 迪杰特斯拉算法 Prim 最小生成树算法 哈夫曼编码 6.2.2 优先队列 操作： 插入一个元素Insert(S, x) 获得最大值MAXIMUM(S) 取出最大值EXTRACT-MAX(S) INCREASE-KEYS(S, x, k) 将位置x的元素正大为key （1）获得最大元素 MAXMUM(A) return A[0]; （2）去除最大元素 先检查溢出 最后一个元素与第一个元素交换 maxHeapify调整 int PriorityQueue::extract_max() { if (vec.size() （3）增大元素 首先判断是否是增大 一直和父亲换，直到父亲的值更大 void PriorityQueue::increase_key(int index, int key) { if (key 0 && vec[parent(index)] （4）插入元素 堆大小加一 将末尾元素设置为无穷小 调用增大元素的函数进行处理 void PriorityQueue::insert(int key) { // 放到最后 vec.push_back(key); // 向上比较调整 increase_key(vec.size()-1, key); } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH7：QuickSort.html":{"url":"算法/CH7：QuickSort.html","title":"CH7：QuickSort","keywords":"","body":"CH7：QuickSort 7.1 Description of QuickSort 7.1.1 Randomized algorithm 随机的应用： QuickSort rand()：产生0~1之间随机数 为什么使用随机？——没有更好的解决方法 7.1.2 快排的概述 分治的结果：分解时做得少，那么合并时就要做的多。反之，分解时做得多，那么合并时做得少。 Divide：利用pivot将数组分为两半，一半比pivot大，一半比pivot小 Conquer：递归求解子数组 Combine：Trival 7.1.2.1 Divide and Conquer （1）QuickSort 主算法：quickSort(A, p, r) 主要做分治，分解问题时做较多的石墙：每次确定pivot的位置 pivot位置确定后，分别递归求解左边和右边的数组 算法为原地排序，不需要合并 void quickSort(vector& vec, int start, int end) { if (start （2）Partition 注意i的初始化 注意各个区间的表示含义： 程序如下： int partition(vector& vec, int start, int end) { // pivot的选择 int pivot = vec[end]; // 选择最后一个元素充当pivot int i = start - 1; for (int j = start; j 有多少个比pivot小的，那么就加几次1 7.1.2.2 快排的分析 假设每个元素是不一样的，现实中，如果有重复的元素，那么有更好的算法存在。 （1）快排的最坏情况 我们假设$T(n)$是最坏情况下的运行时间，那么： 最坏情况发生在pivot是最大或者最小的元素时，此时，问题分解成两个问题，其中一个问题的规模为0，另一个问题的规模为n-1。 一次只会减少规模1. T(n) = T(n-1) + T(0) +\\Theta(n) 递归树如下： （2）快排的最好情况 快排的最好情况发生在每次选取的pivot为中位数时， T(n) = 2T(n/2) +\\Theta(n) 此时，递归树如下： 时间复杂度与归并相同。 （3）1:9情况 假设pivot每次把数组分为1:9的两个数组，那么递归式如下： T(n) = T(9n/10)+T(n/10) +\\Theta(n) 此时的递归树如下： 每次都除以$9/10$，那么树高为$log_{\\frac{10}{9}}^{n}$ 总代价小于$cnlog_{\\frac{10}{9}}^{n}$，所以时间复杂度$T(n) = O(nlgn)$ （4）引入随机的快排 随机选择一个元素作为Pivot。 // 引入随机 int RandomizedPartition(vector& vec, int start, int end) { int p = rand() % (end - start + 1) + start; // 随机选择一个作为pivot int temp = vec[p]; vec[p] = vec[end]; vec[end] = temp; return partition(vec, start, end); } 每次都选到最大或者最小的数的概率为： $\\frac{2}{100}\\times\\frac{2}{99}.......\\times \\frac{2}{2}$ excepted time 为$O(nlgn)$ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH8：Sorting_in_linear_time.html":{"url":"算法/CH8：Sorting_in_linear_time.html","title":"CH8：Sorting in linear time","keywords":"","body":"CH8：Sorting in linear time Comparision Sort 比较排序：在排序的最终结果中，各元素的次序依赖于他们之间的比较。 任何的比较排序最好的最坏情况下经过$\\Omega(nlgn)$次比较，归并，堆排都是最优的。 8.1 排序算法的下界 $Sort$ 判定树：Decision Tree 内部节点：$i：j$标识，满足$1\\leq i,j\\leq n$ 叶子结点为一个排序序列：$$ 算法的执行对应一条从根节点到叶子结点的路径，每个内部节点标识一次比较$a_i\\leq a_j$。 树包含所有可能出现的结果。 上树表示的是直接插入排序的结果。 从根节点到达任意一个可达叶子结点直接的最简单路径的长度：最坏情况下的比较次数。 所有情况：叶子数量为$n$的全排列，即$n!$ h\\geq lg(n!) \\geq lg(n/e)^n\\\\ =nlgn-nlge=\\Omega(nlgn) 归并排序和堆排序是渐进分析框架下的最优比较排序算法。 不可能比$\\Omega(nlgn)$更好 ------------------------------------------>不靠比大小排序，数据具有特殊性 8.2 Counting Sort 计数排序 8.1.1 算法思路 输入：小范围内整数，重复值较多。数据范围为$[1……n]$ 输出：另一个顺序数组$[1...n]$已排序 辅助数组：C[1...k] 算法思想： For x in A, if there are 17 elements less than x in A, then x belongs in output position 18. How if several elements in A have the same value? – Put the 1st in position 18, 2nd in position 19,3rd in position 20,… How if there are 17 elements not greater than x in A? – Put the last one in position 17, the penultimate one in position 16,… 利用数据特殊性，使用k个计数器。 vector countingSort(vector& vec, int k) { // 计数器初始化为全0 vector C(k+1, 0); // 初始化计数器 vector result = vec; // 初始化结果数组 // 统计等于该数的数据数量 for (int i = 1; i = 1; i--) { // 从原数组的最后一个开始向前扫描：保证稳定排序 result[C[vec[i]]] = vec[i]; // 三重嵌套，注意 C[vec[i]]--; // 使用一次减一回 } return result; } 8.1.2 算法分析 （1）时间复杂度分析 该算法如果输入的数据是小范围的，k不超过n，那么时间复杂度为$\\Theta(n)$，最坏情况下也是$\\Theta(n)$ （2）偏移考虑 数组范围： 如果范围是$0……k$，那么计数器C[0]也使用即可 如果范围是$[2……k]$，那么计数器$C[1]$不用 如果范围是$[5000……5100]$，那么计数器所有的$C[vec[i]-偏移量]$ // 给定某个范围，比如5000~5015 void counting_sort2(vector& vec, vector& result, int start, int k) { vector counter(k - start + 1, 0); // 初始化为待排序数组的范围个0：0~k个0 for (int i = 0; i =0; i--) { result[counter[vec[i] - start]-1] = vec[i]; counter[vec[i] - start]--; } print(counter); } （3）扫描顺序 最后一步填入结果数组时，从原数组的最后向前扫描，保证稳定性。 8.3 Radix Sort 基数排序 8.3.1 算法思路 Digit by Digit Sort：按位排序 基数排序：使用辅助数组的稳定排序，首先对最低有效位进行排序 对每一位进行排序时使用的都是稳定排序，最后结果稳定。 RADIX-SORT(A, d) for (int i = 1; i 若位数不固定：采用最大的位数。 counting sort 合适。 8.2.2 时间复杂度分析 时间复杂度为$\\Theta(dO(n))$，其中$d$是一个常数，时间复杂度为$\\Theta(n)$ 8.4 BucketSort 8.4.1 算法思路 数据特殊性表现在：数据均匀分布。每个区间的数出现的概率相等。 （1）步骤 为每一个值分配一个桶 将$A[i]$插入到桶$B[\\lfloor nA[i]\\rfloor]$中，桶范围为$0~n-1$ 映射关系保证，桶n-k内的数一定比桶n-k-r内的数大 对于每一个桶，内部使用直接插入排序 满足均匀分布，数字较少，插入排序可以认为为常数时间 将各个桶合并 常数时间 （2）算法实现 实际实现时桶的数据结构需要考虑用链表数组来实现。首先给出伪代码： #include #include #include #include using namespace std; class LinkNode{ public: double val; LinkNode *next; LinkNode() : val(0), next(nullptr) {}; LinkNode(double x): val(x), next(nullptr) {} LinkNode(int x, LinkNode *next) : val(x), next(next) {} }; void printVec(vector& vec) { for(int i = 0; i& vec, int a, int b, int n) { // 产生a到b之间均匀分布的n个随机数 srand((unsigned int)time(NULL)); for(int i = 0; i & vec, vector& res, int start, int end) { vector linklist_vec; int n = vec.size(); // 处理链表数组的头结点，头结点不放置数据 for(int i = 0; i next != nullptr and head->next->valnext; } // 找到要插入的位置 LinkNode* next_Pointer = head->next; head->next =new LinkNode(vec[i]); head->next->next = next_Pointer; } // 将非空桶中的数据取出，得到最终的顺序 // 扫描并连接链表 for(int i = 0; i next != nullptr) { head = head->next; res.push_back(head->val); } } } int main() { vector vec; int start = 2, end = 5, n = 30; // 准备随机数 random_generation(vec, start, end, n); // 桶排序 vector res; bucket_sort(vec, res, start, end); printVec(res); } 8.4.2 算法分析 算法的时间复杂度为$O(n)$，插入的时间和内部排序的时间都视作常数。 若区间不在0~1之间，那么要进行修改： [0~2]：$B[\\lfloor nA[i]/2\\rfloor]$ [a, b]：B[\\lfloor n(A[i]-a)/(b-a)\\rfloor] 想一下怎么把这个数变到0~1就行了。 8.5 总结 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH9：Medians_and_Order_Statistics.html":{"url":"算法/CH9：Medians_and_Order_Statistics.html","title":"CH9：Medians and Order Statistics","keywords":"","body":"CH9：Medians and Order Statistics MindMap 9.1 Order Statistics 9.1.1 背景介绍 OrderStatistics 排位统计：集合中第i小的元素 中位数：快排中找中位数，代价大 寻找集合中第i小的元素： 最大：i = n 最小：i = 1 中位数 我们可以多快解决这个问题？ 最大或者最小：O(n) 排序：O(nlgn) 下面尝试用O(n)解决 9.1.2 Randomized algorithm for finding the i th element 随机算法 （1）算法思路 算法思路： 利用带有随机的partition算法确定pivot的位置，按照pivot位置和要找的元素的排名对对应的部分进行递归 终止条件：区间长度为1或者是pivot位置就是rank位置 递归找左还是右不要搞错 算法实现： int randomizedSelect(vector& vec, int start, int end, int rank) { if (start == end) return vec[start]; int pivot_index = randomizedPartition(vec, start, end); int pivot_rank = pivot_index - start + 1; if (pivot_rank == rank) { return vec[pivot_index]; } if (rank （2）算法分析 最坏情况下时间复杂度：$T(n) = T(n-1) +\\Theta(n) = \\Theta(n^2)$ 与快排区别，快排是两个子问题。 9.1.3 对于快排的优化 对于快排的时间复杂度，若找中值是线性开销，那么： T(n) = 2T(n/2) + O(n) + O(n) =\\Theta(nlgn) 若找中值是最坏情况： T(n) = 2T(n/2) + O(n) +O(n^2) 线性的找中值： 每5个一组，快速通过直接插入排序找到中值，每组中值的中值作为pivot。 T(n) = T(n/5) + \\Theta(n) + T(7n/10) = \\Theta(n) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件体系结构/about.html":{"url":"软件体系结构/about.html","title":"软件体系结构","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件体系结构/CH2：Achitecture_Style.html":{"url":"软件体系结构/CH2：Achitecture_Style.html","title":"CH2：Achitecture_Style","keywords":"","body":"CH2：Achitecture Style 2.1 架构风格的定义 不存在统一的定义： 架构风格 Achitecture Style = 组件 component 连接件Connector vocabulary 约束Semantic Constraint 如何描述的？重点要看 分类法： 纯粹的体系结构在现实中很难遇到，实际上的系统通常： 经常偏离学术定义 典型的，融合很多的体系风格的特色 作为一个架构师，必须理解“纯”的风格，理解优点和缺点，理解背离这种风格会带来什么结果 没有完备的列表 风格彼此是重叠的 一个系统通常表现出来多种风格 2.2 Data Flow 2.2.1 数据流风格概述 （1）风格 数据流系统： 数据控制计算 the availability of data controls the computation 系统结构由数据在处理之间的有序移动决定 the structure of the design is dominated by orderly motion of data from process to process 数据流系统的结构是显而易见的 纯数据流系统中，处理之间除了数据交换，没有其他的别的交互，变化的是： 如何施加控制——数据的控制方式 pull 拉 消费者角度 push 推 从数据源角度 并行的程度 一条数据流，多条数据流 topology 顺序，循环 （2）Component & Connector & System Component 组件接口是输入端口和输出端口 Interfaces are input ports and output ports Connector：Data Stream 通常是异步的，有缓冲。同步的容易阻塞 System 任意拓扑结构，函数式编程 （3）数据流和控制流 控制流 主要问题是控制点control怎么在程序或者系统之间移动 数据可能跟着控制走，但是并不起到推动系统运转的作用 关注的核心是计算顺序 eg：冯诺依曼结构 数据流 主要问题是数据怎么在运算单元之间流动 数据到了，计算单元便工作 我们关心数据是否可用，转换，延迟 2.2.2 Three Examples of Data Flow 2.2.2.1 Batch Sequential 批处理 （1）图 每一个处理步骤是一个独立的程序，每一步在上一步结束后才能开始，数据必须是完整的，以整体的方式传送。 （2）应用 典型应用： 编译器 case工具 2.2.2.2 Pipe-and-Filter 管道过滤器 （1）图 （2）管道与过滤器 fliter 功能：将数据流作为输入，经过处理后输出 进行流到流的转换： \\begin{cases}丰富数据\\\\精炼数据\\\\转换数据\\end{cases} 数据不再是自包含的 fliter是无状态的计算。没有上下文，状态保存等。 pipe 将数据流从一个过滤器传递到另一个过滤器 数据传送引起动作 （3）优点 隐蔽性，高内聚，低耦合 可支持并发，多个过滤器并发执行 系统容易维护和扩展 （4）缺点 不适合交互性很强的应用——计算过程事先确定 数据传输没有通用标准，每个过滤器需要额外解析和合成数据 （5）数据流与管道过滤器的区别 2.2.2.3 Proccess Control 控制 开环控制 Open loop Control 闭环控制Close Loop Process Control 闭环控制有两种形式：反馈控制和前馈控制 当软件系统的运行受到外部干扰时，需要为软件体系结构考虑一种过程控制范例 2.2.3 选择数据流方式的方针 任务由数据主导 事先知道数据的流向 数据流动带来性能损坏 2.3 Call/Return 2.3.1 风格类型 经典的例子： 主程序和子程序 main program and subroutines 经典编程范式：函数分解 面向对象的抽象数据类型 信息的隐藏 层次化结构 每一层只和他的近邻通信 其他 客户机-服务器 2.3.2 历史过程 主程序（子程序）\\rightarrow 函数模块\\rightarrow ADT\\rightarrow Object\\rightarrow OO架构\\rightarrow Component 2.3.3 Call/Return的具体风格类型 2.3.3.1 Main Program and Subroutine （1）示意图 Problem：适用于通过过程定义层次结构适当定义计算的应用程序 Context：命名空间局部性 Solution： 系统模型：调用和定义层次结构，子系统通常模块化定义 组件：过程和显式可见数据 所有数据对外完全可见 连接器：过程调用和显式数据共享 控制结构：单线程 （2）Pipe Versus Procedures 2.3.3.2 Data Abstaction or Object-Oriented 系统模型：局部化状态保持 组件：对象 连接件：过程调用 控制结构：去中心化，通常是单线程 （1）模块分解 隐藏细节： 数据+策略 隐藏可能改变的细节，接口中公开不太可能改变的假设 （2）封装和信息隐藏 对象有状态和操作，但是也有完整性。 对象被外界知道的是他的接口 对象从模板产生 （3）示意图 对象架构的元素： \\begin{cases}封装：限制信息的访问\\\\交互：过程调用或其他协议\\\\多态：运行时选择具体的操作\\\\继承：对共享的功能保持一致的接口\\\\复用和维护：封装和聚合提高生产力\\end{cases} （4）优缺点 管理大量的对象 对象的海洋需要额外结构容纳 管理很多交互 单一的接口能力有限且笨拙（友元） 分散的行为责任 系统的功能难以理解 捕获关联的设计 类和类型通常是不够的，设计模式是发展 2.3.3.3 Layered system （1）OSI模型的例子 （2）概述 适用问题 包含可以按层次结构安排的不同服务类别 系统模型 不透明的层次结构 构件 各层次内部的构件，过程的集合 连接件 取决于组件的结构;在受限的可见性下，过程调用通常也可能是客户机/服务器 限制 控制结构 单线程 （3）层次风格的特点 每一层为上一层提供服务，使用下一层的服务，只能见到与自己相邻的层 大问题逐渐分解成为若干个渐进的小问题，逐步解决，隐藏了很多复杂度 修改一层，最多影响两层，而通常影响上层，接口稳固，则对谁都不影响 上层必须知道下层的身份，不能调整层次之间的顺序 层层相调，影响性能 2.3.3.4 Client/Server 分类： \\begin{cases}两层CS结构\\\\三层CS结构\\\\BS结构\\end{cases} （1）两层CS 客户机应用程序、数据库服务器、网络 特点：瘦服务器，胖客户机 缺点： 客户端对硬件软件配置要求高，客户机臃肿 升级维护较为困难 数据不安全，客户端可以直接访问服务器数据 信息内容和形式单一 客户端程序编写困难 （2）三层CS 客户机、数据库服务器、应用服务器、网络 特点：瘦客户机 应用功能划分：功能层、表示层、数据层 （3）BS架构 三层CS的特例 客户端使用http浏览器即可，使用http协议，省去了很多麻烦 只能拉，不能推 客户端之间的通信只能通过服务器进行中转 对客户机和其他网络资源的利用受限 客户端资源浪费，服务器压力较大 BS的速度相对于CS慢 2.4 Data Center / Data Sharing var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件体系结构/CH4：理解质量属性.html":{"url":"软件体系结构/CH4：理解质量属性.html","title":"CH4：理解质量属性","keywords":"","body":"1.质量属性场景的概念 质量属性场景： 源 刺激物 制品 环境 响应 响应衡量 2.六大质量属性 2.1 可用性 故障，相关后果 定义：在需要是可用的概率，停机不算 α的定义 \\alpha = \\frac{平均无故障时间}{平均无故障时间 + 故障修复时间} failure的特性：可感知的，未达到声称级别的功能即为错误。 可用性的质量属性场景： 源：系统内部或者外部故障迹象 刺激物：系统崩溃，系统错误，给出结果不准时，错误结果 制品：系统处理器，通信信道，存储，进程 环境：正常、亚健康 响应：记录错误日志，传回；通知管理员或者其他系统；关闭系统 响应测量：平均无故障时间，修复时间，故障时间百分比，可用时间百分比 2.2 可修改性 关注：改什么，谁改，什么时候改，改的代价 质量属性场景 源：谁去修改（开发者，系统管理员，用户） 刺激物：要进行的具体修改 制品：要修改哪一部分的内容：修改系统的功能 or UI 或者其他部分 环境：在什么时间进行修改，设计or开发or运行时间 响应：操作员怎么理解修改，部署，运行 度量：改的时间和成本 2.3 性能 主要是系统响应事件的花费时间，事件数量，到来形式 质量属性场景 源：可能来自系统外部（可能多个）也可能来自系统内部 刺激物：事件的到达，到达的形式（周期性，随机，偶发） 制品：系统提供的服务 环境：系统处于不同的环境——正常，紧急，超载 响应：系统必须处理到来的事件，可能导致系统的环境的变化 响应度量： 处理事件花费的时间 单位时间内处理事件的数量 出错的错误率，丢失率 2.4 安全性 保证正常用户，阻挡非法攻击 安全性的不同类型 不可抵赖性 机密性 完整性 保证性 审计 可用性 质量属性场景 源：攻击可能由人或者其他系统发起；可能先前被识别，或者当前未知。 刺激物 对系统的攻击（或者试图破坏系统安全保护），常见的形式： 数据 超过权限的服务 影响可用性 制品：系统所提供的服务或系统中的数据 环境：系统可能处于不同的情况下——联网/未联网，在线/下线，在防火墙外/在防火墙内 响应： 合法用户正常使用，拒绝非法用户的使用 对攻击有威慑 度量 发起攻击的难度 从攻击中恢复的难度 2.5 可测试性 软件测试为了发现bug 测试的重要性 测试的质量属性场景 源：测试可能由不同的角色发起（开发者、单元测试人员、集成测 试人员、系统管理员、用户……） 刺激物：里程碑 制品：程序，设计，系统 环境：设计阶段、开发阶段、编译时，部署阶段、正常运行时 响应 理想的响应是可以进行测试，并且可以观察到测试结果 当测试结果无法被观察到时，测试难度很大 响应的衡量标准 白盒测试的覆盖率 未来继续发现Bug的概率 最长测试链的长度 2.6 易用性 用户希望完成任务有多容易 质量属性场景 源：终端用户 刺激物 终端用户希望学会使用，提高效率，减少错误 制品：整个系统 环境：运行时或者部署时 响应 系统响应用户的需求 响应度量 用户完成任务的时间 用户出错的概率 用户满意程度 用户操作的成功率 3.从架构上设计质量属性的策略 3.1 可用性 \\begin{cases}错误检测\\begin{cases}ping/echo\\\\Heartbeats：被监控组件向监控组件发出周期性信号\\\\异常\\end{cases} \\\\错误恢复\\begin{cases}投票机制\\\\主动冗余\\\\被动冗余\\\\内测\\\\检查点/回滚\\end{cases}\\\\错误避免\\begin{cases}事务\\\\关闭服务\\\\进程监控\\end{cases}\\end{cases} 3.2 可修改性 \\begin{cases}局部化修改\\begin{cases}保持语义的高内聚性\\\\考虑未来可能会发生的改变\\\\模块泛化\\\\选项变少\\\\抽象公共服务\\end{cases}\\\\避免连锁反应\\begin{cases}保持已有的接口\\\\使用中间层\\\\信息隐藏\\end{cases}\\\\延迟绑定时间\\begin{cases}运行时注册\\\\配置文件\\\\多态\\end{cases}\\end{cases} 3.3 性能 \\begin{cases}资源需求\\begin{cases}提升计算能力\\\\减少处理的数据数量\\\\管理事件达到的频率\\\\限制采样率\\end{cases}\\\\资源管理\\begin{cases}长任务设置上限执行时间\\\\限制事务队列的长度\\\\利用并发机制\\end{cases}\\\\资源仲裁：使用调度策略\\begin{cases}FIFO\\\\固定优先级\\\\动态优先级\\end{cases}\\end{cases} 3.4 安全性 \\begin{cases}抵御攻击\\begin{cases}用户认证\\\\用户授权\\\\保证数据的机密性\\\\保证数据的完整性\\\\限制访问：防火墙\\end{cases}\\\\攻击检测：入侵检测系统\\\\攻击恢复\\begin{cases}数据备份\\\\攻击者识别\\end{cases}\\end{cases} 3.5 可测试性 \\begin{cases}管理输入输出\\begin{cases}记录/回放，重演\\\\ 接口和实现分离\\end{cases}\\\\ 内部检测：内部监控器\\begin{cases}IDE断点\\end{cases}\\end{cases} 3.6 易用性 \\begin{cases}运行时策略\\begin{cases}保证用户模型\\\\保证系统模型\\\\保证任务模型\\end{cases}\\\\设计时策略\\begin{cases}UI界面与其他分离：MVC\\end{cases}\\\\具体：\\begin{cases}系统给与用户适当反馈\\\\系统猜测用户要完成的任务\\\\系统支持撤销\\\\系统给用户提供一致性体验\\\\用户接口分离\\end{cases}\\end{cases} var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"markdown 简洁优雅的排版语言,简化版的 HTML,加强版的 TXT,详情请参考 https://xinwuyun.github.io/markdown/ git 分布式版本控制系统,详情请参考 https://xinwuyun.github.io/git/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"}}