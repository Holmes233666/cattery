{"./":{"url":"./","title":"简介","keywords":"","body":"Summary 软工大三下笔记 算法分析与设计笔记 CH1：Introduction CH2：算法入门 CH2：算法入门_review CH3：Growth of Functions CH3：Growth of Functions_review CH4：Recurrences var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/about.html":{"url":"算法/about.html","title":"算法分析与设计","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH1：Introduction.html":{"url":"算法/CH1：Introduction.html","title":"CH1：Introduction","keywords":"","body":"CH1：Introduction 1.1 Factors of Programming programming language IDE software achitecture 架构： 架构的类型： \\begin{cases}C2\\ Style：conponent\\ \\& \\ connector\\\\Pipe-Fliter\\ Style:输入\\rightarrow 输出\\\\Repositories\\ Style：以某一数据源为中心的操作\\end{cases} 成熟的模式：逐步产生商业架构 Java EE CORBA .NET（与javaEE类似） 1.2 More Important 1.2.1 Transaction finish or null 1.2.2 Security 1.3 DS and Algorithm 1.3.1 Algorithm Concept：A well-Defined computational procedure that takes some value, or set of values, as input and proceduces some value, or set of values, as output. Broadly：a step-step procedure for solving a problem or accomplishing some end especially by a computer. issues： correctness efficiency(amount of work done and space used) storage(simplicity, clarity) optimality 1.3.2 Promblem that can be solved by algorithm 基因工程 网络 电子商务 生产 一个经典的问题：you are given n integers(there may be negative ones but not all) a1, a2, ..., an, determine i and j which maximize the sum from $a_i$ to $a_j$. Case：6 integers：(-2, 11, -4, 13, -5, -2) Ans：i = 2, j = 4, max sum is 20 1.3.3 Importance of algorithms 问题：给1000,000个整数排序 数据量 主频 算法时间复杂度 计算时间 1000000 1GHz $2n^2$ $2\\times 10^5\\ seconds$ 1000000 100MHz $50nlgn$ $105\\ seconds$ 加之主频的提升不大，算法更为重要 1.3.4 About course Design and Analysis 怎么找算法？ 评价算法，定量 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH2：算法入门.html":{"url":"算法/CH2：算法入门.html","title":"CH2：算法入门","keywords":"","body":"CH2：算法入门 The problem of sorting input：sequence of n natural numbers output：permutation such that $a_1'\\leq a_2'\\leq ....\\leq a_n'$ 2.1 Insert Sort 算法： for(i = 2; i = 1 and A[j] > key){ A[j+1] = A[j]; // 后移 j--; } A[j+1] = key; } 2.2 Kinds of Analysis worstest - case（usually）：最坏情况优先考虑 Average - case（sometimes） Best - case（bogus） 2.2.1 循环不变式 loop-invariants Proving correctness Using Loop-invariants【外层为循环】 需要证明的三个性质： 初始化：它在循环的第一轮迭代开始时，应该是正确的 保持：如果在某一次的迭代开始前是正确的，那么在下一次迭代开始前，他也应该保持正确 终止：不变式给了一个有用的性质，表明算法是正确的 2.2.2 运行时间 （1）Running Time 运行时间的取决因素： 输入序列：已经排列好的序列【数据特征】 数据规模：更短的序列更容易排好 通常，我们考虑运行时间的上界，因为这是一个保证 （2）Machine-independent time 插入排序的最差时间取决于计算机的速度： 相对速度（on the same machine）——关注算法 绝对速度（on different machine） 通常我们忽视机器相关时间的限制，关注“the growth of T(n) as n → ∞” 称为渐近分析“Asympotic Analysis” （3）$\\theta-$notation 关心增长率，低阶和常数丢弃 Drop low-order terms; ignore leading constants Example：$3n^3+90n^2-5n+6046 = \\theta(n^3)$ 当n变得足够大时，一个$\\theta(n^2)$的算法总会打败一个$\\theta(n^3)$的算法 2.2.3 Insertion Sort Analysis Worest case：Input reverse sorted【逆序的序列】 T(n) = \\sum\\limits_{j = 2,...,n}\\theta(j) = \\theta(n^2) Average case：All permutations equally likely T(n) = \\sum\\limits_{j = 2,...,n}\\theta(j/2)=\\theta(n^2) 2.3 Analysis Algorithm Analysis An Algorithm： 算法分析指的是对一个算法所需的资源进行分析，预测算法所需的资源，包括内存、通信带宽或计算机硬件等。 但是通常我们更想测量计算时间。 2.3.1 RAM RAM：单处理机，随机存储模型 random-access-machine（RAM） Model with no concurrent operations 不考虑并发 executed as an atom operation 不考虑中断，原子操作 每条指令需要固定时间 内存容量足够大 在RAM模型下，对基础的操作进行计数即可 count fundamental operation。 2.3.2 Analysis of Insert Operation 插入排序的时间计算如下： T(n) = c_1n+c_2(n-1) + c_4(n-1)+c_5\\sum\\limits_{j=2}^nt_j+c_6\\sum\\limits_{j=2}^n(t_j-1) + c_7\\sum\\limits_{j=2}^n(t_j-1)+c_8(n-1)\\\\ best case：数组是有序的 **$t_j = 1$，检查一次，不需要后移** T(n) = c_1n+c_2(n-1) + c_4(n-1)+c_5(n-1)+c_8(n-1)\\\\=(c_1+c_2+c_4+c_5+c_8)n-(c_2+c_4+c_5+c_8) 运行时间是n的线性函数 worest case：数组是倒序的 **$t_j = j$，检查一次，不需要后移** T(n) = c_1n+c_2(n-1)+c_4(n-1)+c_5(n(n+1)/2-1)+c_6(n(n-1)/2)+c_7(n(n-1)/2)+c_8(n-1)\\\\=(c_5/2+c_6/2+c_7/2)n^2+(c_1+c_2+c_4+c_5/2-c_6/2-c_7/2+c_8)n-(c_2+c_4+c_5+c_8) 运行时间是n的二次函数。 note： 对于某些算法来说，最坏情况经常发生 平均情况有时候和一般情况一样糟糕 2.3.3 Order of Growth 我们只考虑运行时间的增长顺序: 我们可以忽略低阶项，因为对于非常大的n，它们相对不重要。 我们也可以忽略前项的常系数，因为对于非常大的n，它们对计算效率的增长速度并不重要。 我们刚刚说过，最好的情况是n的线性而最坏/平均的情况是n的二次型。 2.4 Designing Algorithm 2.4.1 Divide and Conquer To solve P： Divide P into smaller problems P_1, P_2, ... , P_k Conquer by solving the (smaller) subproblems recursively Combine the solutions to P_1,P_2,...,P_k into the solution for P （1）Merge Sort Using Divide and Conquer, we can obtain a merge sort algorithm Divide：divide n elements into two subsequences of n/2 elements each Conquer：Solve the two subsequences recursively Combine：Merge the two sorted subsequences to produce the sorted answer Merge-Sort(A，p，r) INPUT: a sequence of n numbers stored in array A OUTPUT: an ordered sequence of n numbers MergeSort(A,p,r) if p Actions of Merge Sort： 2.4.2 Analysis divide and conquer Algorithm $T(n)$ running time on a problem of size n 【n ：问题规模】 假设把原问题分成a个子问题，每个子问题是原问题规模的$1/b$ 对于MergeSort来说，a = 2，每个问题的规模是原问题的1/b $D(n)$ 分解的开销 $C(n)$ 合并的开销 子问题 --合并-->原问题 MergeSort Recurrence Equation T(n) = \\begin{cases}\\Theta(1)\\quad if\\ n≤c\\\\ aT(n/b)+D(n) + C(n)\\quad otherwise\\end{cases} 对于MergeSort来说，递归式如下： T(n) = \\begin{cases}\\Theta(1)\\quad if\\ n≤c\\\\ 2T(n/2)+\\Theta(n)\\quad otherwise\\end{cases} Claim： T(n) = nlog_2^n 所有情况下均为nlog_2^n 最好 最坏 平均 $log_2^n+1$是针对结点的，若是针对边则是$log_2^n$。每层的和是一定的，都是cn 所以总的花费时间为： \\sum_{i=1}^{log_2^n} cn = cn·log_2^n Proof by Telescoping T(n) = 2T(n/2)+n = 2(2T(n/4) + n/2)+n = 4T(n/4)+2n\\\\ =......=nT(n/n)+log_2^n n=nT(1)+nlog_2^n var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH2：算法入门_review.html":{"url":"算法/CH2：算法入门_review.html","title":"CH2：算法入门_review","keywords":"","body":"CH2 算法入门 MindMap 排序问题： 输入：序列$$ 输出：非降序排列：$$，满足$a_1'\\leq a_2'\\leq...\\leq a_n'$ 2.1 Insert Sort 程序： void insertSort(vector& vec) { for (int i = 2; i 0 && vec[j] > key) { vec[j+1] = vec[j]; // 后移操作 j--; } vec[j+1] = key; } } 注意后移操作：A[j+1] = A[j] 若位置0处数字为负无穷，那么while循环中将不用写条件j>0。 2.2 Analysis of algorithms 2.2.1 运行时间 Running Time： 数据的初始特征 数据规模 we seek upper bounds on the running time Kinds of Analysis： Worst - case（usually 最坏情况最优先考虑） Average - case（sometimes） Best - case（bogus） 2.2.2 loop-invariant Proving correctness using loop-invariant：最外层必须是循环，证明某一性质每一次循环都不变 需要证明的三个性质 初始化：他在循环的第一轮迭代开始前，应该是正确的 保持：如果在某一次的迭代开始前是正确的，那么在下一次的迭代开始前他也应该保持正确 终止：循环结束时，不变式给了一个有用的性质，表明算法是正确的 使用循环不变式证明插入排序 证明：在每次迭代开始前子数组A[1...j-1]中元素为原数组中的A[1...j-1]，但是是有序的 初始化 j = 2 保持：A[j - 1], A[j - 2],… are moved one at a time till the proper position for A[j] is found. 结束：当j=n+1时，整个序列有序 2.2.3 机器独立时间 machine independent time relative time：在相同的机器上——关注算法 absolute time：在不同的机器上 忽略机器相关的约束，直接考虑 $n\\rightarrow \\infty$时的$T(n)$ —— 渐近分析 Asymptotic Analysis 2.2.4 $\\Theta-Notation$ （1）定义 $\\Theta$表示法的定义： 数学定义：$\\Theta(g(n)) = {存在正整数c_1和c_2，并且n_0>0，满足当所有的n\\geq n_0时，0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n)}$ 工程上：关心增长率，低阶和常数项丢弃 Example：$3n^3 + 9n^2-5n+8344 = \\Theta(n^3)$ （2）Asyptotic Performance 当n变得足够大的时候，一个$\\Theta(n^2)$的算法一定比一个$\\theta(n^3)$的算法要好 2.2.5 Insertion sort analysis 最差情况：输入是逆序的——每个数都要前移 T(n) = \\sum_{j=2..n}\\Theta(j)=\\Theta(n^2) 平均情况： T(n) = \\sum_{j=2..n}\\Theta(j/2)=\\Theta(n^2) 2.3 算法分析的入门 2.3.1 算法分析的概念 算法分析指的是对一个算法所需的资源进行分析，内存，通信带宽或者计算机硬件是主要关心的，但通常希望测量计算时间。 在我们分析算法之前，我们必须有一个将要使用的实现技术的模型，包括该技术的资源及其成本的模型 算法实现的技术模型：单处理器，随机存储模型[RAM] 2.3.2 Random Access Model 不考虑并发 不考虑中断，原子操作 假设每条指令花费常数时间 内存足够大 …… 在RAM模型下，需要考虑的是基本操作的次数 counting fundamental operations 2.3.3 Analysis of insert operation $cost$：每次基本操作花费的代价 $t_j$：假设第$j$次迭代需要检查$while$循环条件的次数为$t_j$ T(n) = c_1n+c_2(n-1) + c_4(n-1) +c_5\\sum_{j=2}^n t_j+c_6\\sum_{j=2}^n (t_j-1)+c_7\\sum_{j=2}^n (t_j-1)+c_8(n-1) best-case：数组是有序的，$t_j=1$检查一次while，不需要后移 T(n) = c_1n+c_2(n-1) + c_4(n-1) +c_5(n-1)+c_8(n-1) = (c_1+c_2+c_4+c_5+c_8)n -(c_2+c_4+c_5+c_8) 即，最好情况下插入排序开销为线性开销。 worest-case：数组是逆序的，那么$t_j = j$（$i=0$也会检查） \\begin{aligned} T(n)=& c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5}(n(n+1) / 2-1)+c_{6}(n(n-1) / 2) \\\\ & c_{7}(n(n-1) / 2)+c_{8}(n-1) \\\\ =&\\left(c_{5} / 2+c_{6} / 2+c_{7} / 2\\right) n^{2} \\\\ &+\\left(c_{1}+c_{2}+c_{4}+c_{5} / 2-c_{6} / 2-c_{7} / 2+c_{8}\\right) n-\\left(c_{2}+c_{4}+c_{5}+c_{8}\\right) \\end{aligned} 运行时间是平方级开销。 在一些算法中，最坏情况经常发生，比如查询数据库 有时候平均情况和最差情况一样糟糕 Order of Growth 忽略低阶项 忽略常数项 2.4 Designing Algorithms Insert Sort：增量法 2.4.1 Divide-and-Conquer To solve P: Divide P into smaller problems P1 , P2 , …, Pk . Conquer by solving the (smaller) subproblems recursively. Combine the solutions to P1 , P2 , …, Pk into the solution for P. note：解决问题前想一想：该问题难以解决是否是因为规模太大了，若是规模足够小，那么是不是可以解决 2.4.2 Merge Sort 使用分治策略，我们首先分析归并排序。 Divide：把n个元素分成两个子序列，每个子序列有$n/2$个元素 Conquer：递归求解两个子问题 Solve the two subsequences recursively Combine：合并两个子序列，得到有序的结果 （1）Merge-Sort函数 假设我们有一个Merge(A,p,q,r)函数，他把两个有序的数组A[p……q]和A[q+1……r]合并 Merge-Sort 输入：需要排序的n个数序列A 输出：有序序列 #include #include #include using namespace std; void Merge_Sort(vector& vec, int start, int end); // 分治算法主体 void Merge(vector& A, int start, int mid, int end); // 合并的过程，重点在合并 void printVec(vector& vec); int main() { vector nums = {8,5,9,10,3,6,2,7}; Merge_Sort(nums, 0, nums.size()-1); printVec(nums); return 0; } void Merge_Sort(vector& vec, int start, int end) { if (start & A, int start, int mid, int end) { int n1 = mid - start + 1; // 数组1个数 int n2 = end - (mid + 1) + 1; // 数组2元素个数 vector vec1(n1+1), vec2(n2+1); // 临时数组初始化 // 数组末尾设为无穷大简化了扫尾工作 vec1[n1] = 99999; vec2[n2] = 99999; // 数组赋值 for (int i = start; i & vec) { for (int i = 0; i 注意分治时采取自上而下的递归处理时，每个分支执行的顺序，如下： 2.4.3 Analysis divide-and-conquer Algorithm （1）符号定义 $T(n)$：$\\text{running time on a problem of size n}$， 问题的运行时间，n为问题规模 $D(n)$：分解的时间开销 $C(n)$：合并的开销 $子问题\\rightarrow 原问题$ 统一模式： T(n)=\\begin{cases}\\Theta(1)&& if\\ n\\leq c\\\\ D(n) + aT(n/b) + C(n)&& otherwise\\end{cases} 当问题规模足够小时，不需要分治。 否则递归求解 （2）MergeSort Analysis T(n)=\\begin{cases}\\Theta(1)&& if\\ n\\leq c\\\\ 2T(n/2) + C(n)=2T(n/2) + \\Theta(n)&& otherwise\\end{cases} 在归并排序中，分解时分解为2个子问题，每个问题的规模是原来的$n/2$。 Claim：$T(n) = nlog2^n$，所有情况下均为$nlgn$【平均、最好、最坏】 证明： 递归到何时终止？$n/x == 1$时终止，次数：除法$log_2^n$，树高$log_2^n+1$ T(n) = cn·lg^n + c'n 代入法证明 Proof by Telescoping T(n) =2T(n/2) + n\\\\ =2(2T(n/4)+n/2) +n=4T(n/4)+2n\\\\ =4(2T(n/8) + n/4) + 2n = 8T(n/8) + 3n\\\\ =……\\\\=nT(n/2^k) + kn\\\\=……\\\\ =nT(n/2^{lgn}) + nlgn 数学归纳法证明 T(n) = nlgn var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH3：Growth_of_Functions.html":{"url":"算法/CH3：Growth_of_Functions.html","title":"CH3：Growth of Functions","keywords":"","body":"CH3：Growth of Functions Topics： Growth of Functions O/\\Theta/\\Omega notations Asymptotic Growth： We want to express rate of growth of standard functions: the leading term with respect to n 【第一项】 ignoring constants in front of it 【忽略常数项】 3.1 Asymptotic Notation 3.1.1 O-notation O(g(n)) = {f(n) ：There exist positive constants c and n_0 such that 0≤f(n) ≤cg(n) for all $n≥n_0$} O(.) 用来渐近表示计算时间的上届 —— 【最坏情况】 O(.) is used to bound worest-case running time 将f(n)用简洁的O(.)来表示 任何一个二次多项式都是$O(n^2)$ Note： When we say \"the running time is O(n)\"：the worest case running time is O(n) We often write f(n) = O(g(n)), instead of f(n) ∈ O(g(n)) Use O(n) in equations：2n^2+3n+1 = 2n^2+O(n) 3.1.2 $\\Omega-notation$ \\Omega(g(n)) = \\{\\text{There exist positive constants c and n0 such that 0=n0}\\} 【大于g（n）的整数倍】 \\Omega-notation用于给出函数的下界 任何一个二次多项式都是\\Omega(n^2)的。 3.1.3 \\Theta-notation \\Theta(g(n)) = \\{\\text{There exist positive constants c and n0 such that } 0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n)\\ \\text{for all n>=n0}\\} \\Theta(g(n))提供了函数的一个tight bound 紧致界 $f(n) = \\Theta(g(n))$当且仅当f(n) = O(g(n))并且f(n) =\\Omega(g(n)) 只要最高次项，那就是$\\Theta(.)$ Note： We often think of f(n) = O(g(n)) as corresponding to f(n)≤ g(n) f(n) = \\Theta(g(n)) corresponds to f(n) = g(n) f(n) = \\Omega(g(n)) corresponds to f(n) ≥ g(n) Example： 4n^3 + 3n^2 + 2n + 1 = 4n^3 + 3n^2 + Θ(n)= 4n^3 + Θ(n^2) = Θ(n^3) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH3：Growth_of_Functions_review.html":{"url":"算法/CH3：Growth_of_Functions_review.html","title":"CH3：Growth of Functions_review","keywords":"","body":"CH3：Growth of Functions MindMap Asymptotic Growth 分析算法时我们对算法输入规模为n时的最坏情况下运行时间函数感兴趣 不考虑常数项 不考虑低阶项 3.1 Asymptotic Notation 3.1.1 O-Notation （1）定义 O(g(n)) = \\{f(n):\\text{There exists positive c and }n_0\\text{ such that } 0\\leq f(n)\\leq cg(n)\\text{ for all }n\\geq n_0\\} 正整数c 正整数n0 g(n)是最高次项 exists：存在即可 **$O(g(n))$是一个满足上述条件的运行时间函数的集合** $O(.)$：用于渐进上界函数 $\\text{is used to asymptotic upper bound a function}$ $O(.)$：用来表示最坏情况的运行时间$\\text{is used to bound worst-case running time}$ （2）Example （3）使用情况 当我们说道“运行时间是O(n)”时，我们指的是最坏情况下的运行时间是O(n) 通常写为：$f(n) = O(g(n))$，而不是$f(n)\\in O(g(n))$——虽然是个集合 我们也在等式中使用$O(n)$，例子： 2n^2+3n +1 = 2n^2 +O(n) $O(1)$表示常数时间 3.1.2 $\\Omega-Notation$ （1）定义 \\Omega(g(n)) = \\{f(n):\\text{There exists positive c and }n_0\\text{ such that } 0\\leq cg(n)\\leq f(n) \\text{ for all }n\\geq n_0\\} 我们使用$\\Omega(.)$来表示运行时间的下界 （2）Example when we say “the running time is $Ω(n^2 )$” we mean that the best-case running time is $Ω(n^2)$ ——the worst case might be worse. 3.1.3 $\\Theta-Notation$ （1）定义 \\Theta(g(n)) = \\{f(n):\\text{There exists positive }c_1，c_2\\text{ and }n_0\\text{ such that } 0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n) \\text{ for all }n\\geq n_0\\} 我们使用$\\Theta-Notation$来表示紧致界 充要条件：$f(n) = Θ(g(n))\\ if\\ and\\ only\\ if\\ f(n) =O(g(n))\\ \\ and\\ \\ f(n) = Ω(g(n))$ （2）Example 3.1.4 总结 （1）表示法 （2）在等式中的使用 使用$O、\\Theta、\\Omega$在函数中替换低阶项简化函数表达 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH4：Recurrences.html":{"url":"算法/CH4：Recurrences.html","title":"CH4：Recurrences","keywords":"","body":"CH4：Recurrences MindMap Review： MergeSort 分析MergeSort的时间复杂度 递归树 Picture of Recursion Tree 迭代法 Telescoping 数学归纳法 Mathematical Induction 渐近分析 $O-Notation$ $\\Omega-Notation$ $\\Theta-Notation$ 算法包含对自身的调用时，其运行时间可以用递归式表示： $MergeSort：T(n) = aT(n/b) +D(n) +C(n) = 2T(n/2) + O(n)$ 3种求解递归函数的方法： 代换法-------------Substitution 递归树法----------Recursion Tree 主方法-------------Master Method 4.1 Substitution Method 代换法 （1）步骤 步骤： 猜测一个解的形式 Guess the form of solution 使用数学归纳法证明 Verify by induction 求解常数项 Solve for constants （2）例子 Example1：$T(n) = 4T(n/2) + 100n$ 猜测：$O(n^3)$（如果要证明$\\Theta$的话，那么要分别证明O和$\\Omega$） 归纳基础：$T(1) = \\Theta(1)$ 归纳假设：$T(k) \\leq ck^3 $在$k 使用数学归纳法证明：$T(n) \\leq cn^3$ 证明： \\begin{aligned} \\mathrm{T}(\\mathrm{n}) &=4 \\mathrm{~T}(\\mathrm{n} / 2)+100 n \\\\ & \\leq 4 \\mathrm{c}(\\mathrm{n} / 2)^{3}+100 n \\\\ &=(\\mathrm{c} / 2) n^{3}+100 n \\\\ &=\\mathrm{cn}^{3}-\\left((\\mathrm{c} / 2) n^{3}-100 n\\right)\\\\ &\\leq\\mathrm{cn}^{3} \\end{aligned} 最后确定c和n的值即可： Example2：$T(n) = 2T(\\lfloor n/2\\rfloor) + n$ 要严格遵守证明的结果的模式，下面的证明是错误的： Example3：尝试变量替换 考虑：$T(n) = 2T(\\sqrt{n}) + lgn$ Rename：$m = lgn\\Rightarrow T(2^m) = 2T(2^{\\frac{m}{2}})+m$ 令$S(m) = T(2^m)$，则有：$S(m) = 2S(m/2) + m$ 设当$m_0\\leq m$时有：$S(m_0)\\leq cm_0lgm_0$ S(m) = 2S(m/2) + m\\\\ \\leq 2c(m/2)lg(m/2) + m\\\\ =cmlg(m/2)+m\\\\=cmlgm-cm + m\\\\ =cmlgm-(c-1)m\\\\=O(mlgm) 转换回来 $T(2^m) = S(m) = O(mlgm)$ $T(m) = O(lgmlgm)$ $T(n) = O(lgnlglgn)$ （3）猜测方法 使用代换法的一个重要技巧是要猜测 猜测的方式： 递归树的方法帮助猜测 与先前见过的相似 先整较松的上届然后缩小区间 降低上届，提高下界，缩小不确定区间 4.2 Recursion-tree Method 递归树是一个好的猜测的直接方法 递归树方法可能不可靠，就像任何使用省略号的方法一样 4.2.1 例子说明 $T(n) = 3T(n/4) + \\Theta(n^2)$ （1）递归树猜测上界 最后一层叶子数：$3^{log_4^n} = n^{log_4^3}$ 每层开销：$((\\frac{3}{16})^icn^2)$ 总开销：$cn^2 + (\\frac{3}{16})cn^2+(\\frac{3}{16})^2cn^2+......+(\\frac{3}{16})^{log_4^n-1}cn^2 + O(n^{log_4^3})=\\frac{1\\times (1-(\\frac{3}{16})^{log_4^n+1})}{1-\\frac{3}{16}}+O(n^{log_4^3})$ 使用等比数列的上界作为上限： cn^2\\sum_{i=0}^{log_4^n-1}(\\frac{3}{16})^i = \\frac{cn^2}{1-\\frac{3}{16}}=\\frac{13}{16}cn^2 所以： T(n) =cn^2 + (\\frac{3}{16})cn^2+(\\frac{3}{16})^2cn^2+......+(\\frac{3}{16})^{log_4^n-1}cn^2 + O(n^{log_4^3})=\\frac{1\\times (1-(\\frac{3}{16})^{log_4^n+1})}{1-\\frac{3}{16}}+O(n^{log_4^3})\\\\ \\leq \\frac{13}{16}cn^2 +O(n^{log_4^3}) = O(n^2) （2）迭代法证明 递归基础：$T(1) = O(1)$ 归纳假设：$T(k) \\leq ck^2，当k 证明：$T(n) \\leq cn^2$ T(n) = 3T(n/4) + d(n^2)\\\\ \\leq 3c(n/4)^2 + d(n^2)\\\\ =\\frac{3}{16}cn^2 + d(n^2)\\\\ \\leq cn^2 当$d\\geq \\frac{16}{13}c$时成立。 4.3 Master Method “cook book” Method for solving recurrences of the form: T(n) = aT(n/b) + f(n)\\\\ 其中a \\geq 1 , b >1 叶子的个数：$a^h = a^{log_b^n} = n^{log_b^a}$ 比较树根$f(n)$和$n^{log_b^a}$ 三种情况： 由根到叶子\\begin{cases}减少\\\\不变\\\\增大\\end{cases} 4.3.1 Compare f(n) with $n^{log_b^a}$ （1）$f(n) = O(n^{log_{b}^{a}-\\epsilon})$ 叶子开销严格大于树根 $f(n)$多项式增长慢于$n^{log_b^a}(by\\ an\\ n^{\\epsilon}\\ factor)$ $Solution:T(n) = \\Theta(n^{log_b^a})$ 注意是$\\Theta$ （2）$f(n) = O(n^{log_{b}^{a}}(lgn)^k)$ 树根开销为叶子开销的$lgn$的$k$次方倍 其中$k\\geq 0$，整数 $Solution:T(n) = \\Theta(n^{log_b^a}lgn^{k+1})$最终结果多乘以一个树高的k次方 （3）$f(n) = O(n^{log_{b}^{a}+\\epsilon})$ 叶子开销小于树根开销 需要额外满足$af(n/b)\\leq cf(n)$ $T(n)=\\Theta(f(n))$树根量级 4.3.2 Conclusion （1）方法总结 树根和叶子比较，同时要注意什么时候写$O$，什么时候写$\\Omega$，什么时候 例题： Example1 T(n) = 9T(n/3) + n $f(n) = n = O(n^{log_b^{a}-\\epsilon})= n^{2-\\epsilon}$，其中$\\epsilon = 1$ 所以$T(n) = \\Theta(n^2)$ Example2 T(n) = T(2n/3) + 1 $f(n) = 1 = \\Theta(n^{log_{\\frac{3}{2}}^1}lg^kn)$，其中$k=1$ 所以$T(n) = \\Theta(lgn)$ Example3 T(n) = 3T(n/4) +nlgn $f(n) = nlgn = \\Omega(n^{log_4^3}+\\epsilon)$，其中$\\epsilon ≈ 0.2$ 且$af(n/b) = 3f(n/4) = 3\\frac{n}{4}lg{\\frac{n}{4}}=\\frac{3n}{4}(lgn-2)\\leq cnlgn$ 当$c = \\frac{3}{4}, n\\geq 1$时成立。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH6：HeapSort.html":{"url":"算法/CH6：HeapSort.html","title":"CH6：HeapSort","keywords":"","body":"CH6：HeapSort MindMap Topics： Heaps HeapSort Priority queue Recap and Overview 强调稳定性时多关注的是多关键字排序。 插入排序 时间复杂度是$O(n^2)$，原地排序 归并排序 时间复杂度是$O(nlgn)$，需要辅助存储空间 堆排序 时间复杂度是$\\Theta(nlgn)$，原地排序 快排 平均情况的时间复杂度是$O(nlgn)$，原地排序 线性时间的排序 6.1 Heap 6.1.1 堆存储和堆数据结构 （1）堆内存的使用 堆的使用： 内存的分类 \\begin{cases}栈内存：局部变量，方法和函数\\\\ 堆内存：malloc\\ new\\\\ 静态方法区：全局变量\\end{cases} （2）堆数据结构的使用 堆数据结构： 元素按照下标索引——堆数据结构的实现是一个一维数组 每个元素支持：PARENT，LEFT和RIGHT操作 父子关系的映射逻辑为： 若数组下标从1开始，那么父子映射关系函数为： $PARENT(i) = \\lfloor i/2 \\rfloor$ $LEFT(i) = 2i$ $RIGHT(i) = 2i+1$ 若数组下标从0开始，那么父子映射关系函数为： $PARENT(i) = \\lceil i/2 \\rceil -1$ $LEFT(i) = 2i+1$ $RIGHT(i) = 2i+2$ int getParent(int child) { return ceil(child / 2.0) - 1; } int getLeft(int parent) { return parent * 2 + 1; } int getRight(int parent) { return parent * 2 + 2; } 堆中父子的大小关系 \\begin{cases}大顶堆：A[PARENT(i)]\\geq A[i]\\\\ 小顶堆：A[PARENT(i)]\\leq A[i]\\end{cases} 堆中的第一个元素是$A[0]$或者$A[1]$，对应两种不同的情况 结点的高度是从该结点到叶子结点的最长路径。 堆的高度是树根的高度。 叶子结点的高度为0，树根的高度为树的高度。 有n个结点的树的高度为$\\lfloor lgn\\rfloor$ （3）时间复杂度概述 MAX-HEAPIFY：保证堆是一个大顶堆，时间复杂度是$O(lgn)$ Build-Max-Heap：建堆，时间复杂度是$O(n)$ 堆排序：堆排序时，我们首先要建成一个大顶堆，然后反复执行，取下结点后调用MAX-HEAPIFY的过程，时间复杂度是$O(nlgn)$ 6.1.2 堆的建立 建堆两种方式：递归建堆和非递归建堆 （1）递归建堆 递归建堆三个步骤：分、治、合并 分：分解成子树 治：递归处理左子树和右子树 合并：MaxHeapify void buildMaxHeap(int parent, vector& vec) { if (parent （2）非递归建堆 非递归建堆过程采用循环的建堆方式，从最后一个非叶子结点开始，逐步建堆 最后一个非叶子结点的下标：$\\lfloor vec.size()/2\\rfloor$ void buildMaxHeap_iteration(vector& vec) { int last_non_leaf = vec.size() / 2; for (int i = last_non_leaf; i >= 0; i--) { maxHeapify(vec, i); } } （3）合并过程：MAXHEAPIFY MaxHeapify()时间复杂度为$O(h)$，其中$h$是树的高度，$h = \\lfloor lgn \\rfloor $ 递归写法 写成递归处理的形式如下： void maxHeapify(vector& vec, int parent) { int largest = parent; int left = getLeft(parent); int right = getRight(parent); // 找到父子之间最大值的位置 if (left vec[largest]) { // 注意短路判决 largest = left; } if (right vec[largest]) { // 注意短路判决 largest = right; } // 更换位置 if (largest != parent) { int temp = vec[largest]; vec[largest] = vec[parent]; vec[parent] = temp; // 接着maxheapify处理子树 maxHeapify(vec, largest); } } 循环写法 上述的写法是在结束的时候调用递归处理，这种写法很容易改成循环的形式。如下： void maxHeapify(vector& vec, int parent) { int largest = parent; bool ifChange = true; while(ifChange) { int left = getLeft(parent); int right = getRight(parent); // 找到父子之间最大值的位置 if (left vec[largest]) { // 注意短路判决 largest = left; } if (right vec[largest]) { // 注意短路判决 largest = right; } // 更换位置 if (largest != parent) { // 需要交换 int temp = vec[largest]; vec[largest] = vec[parent]; vec[parent] = temp; ifChange = true; }else{ ifChange = false; } } } （4）运行时间分析 若采取直接的方式分析运行时间，那么时间将会是： T(n) = O(n/2)\\times O(lgn) = O(nlgn) **key observation：** T(n) = 2T(n/2) + O(lgn) $f(n) = lgn = O(n^{log_2^2-\\epsilon})=O(n^{1-\\epsilon})$ 所以堆排序的时间复杂度为$\\Theta(n)$ 6.1.3 堆排序 堆排序策略：每次取出堆顶的元素，使用堆中最后一个元素与堆顶元素交换，然后调用MaxHeapify void HeapSort(vector& vec) { int size = vec.size(); // 从0开始的 for (int i = size - 1; i >= 1; i--) { // 从最后一个结点开始 int temp = vec[i]; vec[i] = vec[0]; vec[0] = temp; size = size - 1; maxHeapify(vec, 0, size); } } 时间复杂度：$O(nlgn)$ 原地排序 inplace 不稳定排序 6.2 PriorityQueue 6.2.1 应用 最大值优先队列的应用： 在共享计算机上调度工作 实现优先队列 最小值优先队列应用： 迪杰特斯拉算法 Prim 最小生成树算法 哈夫曼编码 6.2.2 优先队列 操作： 插入一个元素Insert(S, x) 获得最大值MAXIMUM(S) 取出最大值EXTRACT-MAX(S) INCREASE-KEYS(S, x, k) 将位置x的元素正大为key （1）获得最大元素 MAXMUM(A) return A[0]; （2）去除最大元素 先检查溢出 最后一个元素与第一个元素交换 maxHeapify调整 int PriorityQueue::extract_max() { if (vec.size() （3）增大元素 首先判断是否是增大 一直和父亲换，直到父亲的值更大 void PriorityQueue::increase_key(int index, int key) { if (key 0 && vec[parent(index)] （4）插入元素 堆大小加一 将末尾元素设置为无穷小 调用增大元素的函数进行处理 void PriorityQueue::insert(int key) { // 放到最后 vec.push_back(key); // 向上比较调整 increase_key(vec.size()-1, key); } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH7：QuickSort.html":{"url":"算法/CH7：QuickSort.html","title":"CH7：QuickSort","keywords":"","body":"CH7：QuickSort 7.1 Description of QuickSort 7.1.1 Randomized algorithm 随机的应用： QuickSort rand()：产生0~1之间随机数 为什么使用随机？——没有更好的解决方法 7.1.2 快排的概述 分治的结果：分解时做得少，那么合并时就要做的多。反之，分解时做得多，那么合并时做得少。 Divide：利用pivot将数组分为两半，一半比pivot大，一半比pivot小 Conquer：递归求解子数组 Combine：Trival 7.1.2.1 Divide and Conquer （1）QuickSort 主算法：quickSort(A, p, r) 主要做分治，分解问题时做较多的石墙：每次确定pivot的位置 pivot位置确定后，分别递归求解左边和右边的数组 算法为原地排序，不需要合并 void quickSort(vector& vec, int start, int end) { if (start （2）Partition 注意i的初始化 注意各个区间的表示含义： 程序如下： int partition(vector& vec, int start, int end) { // pivot的选择 int pivot = vec[end]; // 选择最后一个元素充当pivot int i = start - 1; for (int j = start; j 有多少个比pivot小的，那么就加几次1 7.1.2.2 快排的分析 假设每个元素是不一样的，现实中，如果有重复的元素，那么有更好的算法存在。 （1）快排的最坏情况 我们假设$T(n)$是最坏情况下的运行时间，那么： 最坏情况发生在pivot是最大或者最小的元素时，此时，问题分解成两个问题，其中一个问题的规模为0，另一个问题的规模为n-1。 一次只会减少规模1. T(n) = T(n-1) + T(0) +\\Theta(n) 递归树如下： （2）快排的最好情况 快排的最好情况发生在每次选取的pivot为中位数时， T(n) = 2T(n/2) +\\Theta(n) 此时，递归树如下： 时间复杂度与归并相同。 （3）1:9情况 假设pivot每次把数组分为1:9的两个数组，那么递归式如下： T(n) = T(9n/10)+T(n/10) +\\Theta(n) 此时的递归树如下： 每次都除以$9/10$，那么树高为$log_{\\frac{10}{9}}^{n}$ 总代价小于$cnlog_{\\frac{10}{9}}^{n}$，所以时间复杂度$T(n) = O(nlgn)$ （4）引入随机的快排 随机选择一个元素作为Pivot。 // 引入随机 int RandomizedPartition(vector& vec, int start, int end) { int p = rand() % (end - start + 1) + start; // 随机选择一个作为pivot int temp = vec[p]; vec[p] = vec[end]; vec[end] = temp; return partition(vec, start, end); } 每次都选到最大或者最小的数的概率为： $\\frac{2}{100}\\times\\frac{2}{99}.......\\times \\frac{2}{2}$ excepted time 为$O(nlgn)$ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH8：Sorting in linear time.html":{"url":"算法/CH8：Sorting in linear time.html","title":"CH8：Sorting in linear time","keywords":"","body":"CH8：Sorting in linear time Comparision Sort 比较排序：在排序的最终结果中，各元素的次序依赖于他们之间的比较。 任何的比较排序最好的最坏情况下经过$\\Omega(nlgn)$次比较，归并，堆排都是最优的。 8.1 排序算法的下界 $Sort$ 判定树：Decision Tree 内部节点：$i：j$标识，满足$1\\leq i,j\\leq n$ 叶子结点为一个排序序列：$$ 算法的执行对应一条从根节点到叶子结点的路径，每个内部节点标识一次比较$a_i\\leq a_j$。 树包含所有可能出现的结果。 上树表示的是直接插入排序的结果。 从根节点到达任意一个可达叶子结点直接的最简单路径的长度：最坏情况下的比较次数。 所有情况：叶子数量为$n$的全排列，即$n!$ h\\geq lg(n!) \\geq lg(n/e)^n\\\\ =nlgn-nlge=\\Omega(nlgn) 归并排序和堆排序是渐进分析框架下的最优比较排序算法。 不可能比$\\Omega(nlgn)$更好 ------------------------------------------>不靠比大小排序，数据具有特殊性 8.2 Counting Sort 计数排序 8.1.1 算法思路 输入：小范围内整数，重复值较多。数据范围为$[1……n]$ 输出：另一个顺序数组$[1...n]$已排序 辅助数组：C[1...k] 算法思想： For x in A, if there are 17 elements less than x in A, then x belongs in output position 18. How if several elements in A have the same value? – Put the 1st in position 18, 2nd in position 19,3rd in position 20,… How if there are 17 elements not greater than x in A? – Put the last one in position 17, the penultimate one in position 16,… 利用数据特殊性，使用k个计数器。 vector countingSort(vector& vec, int k) { // 计数器初始化为全0 vector C(k+1, 0); // 初始化计数器 vector result = vec; // 初始化结果数组 // 统计等于该数的数据数量 for (int i = 1; i = 1; i--) { // 从原数组的最后一个开始向前扫描：保证稳定排序 result[C[vec[i]]] = vec[i]; // 三重嵌套，注意 C[vec[i]]--; // 使用一次减一回 } return result; } 8.1.2 算法分析 （1）时间复杂度分析 该算法如果输入的数据是小范围的，k不超过n，那么时间复杂度为$\\Theta(n)$，最坏情况下也是$\\Theta(n)$ （2）偏移考虑 数组范围： 如果范围是$0……k$，那么计数器C[0]也使用即可 如果范围是$[2……k]$，那么计数器$C[1]$不用 如果范围是$[5000……5100]$，那么计数器所有的$C[vec[i]-偏移量]$ // 给定某个范围，比如5000~5015 void counting_sort2(vector& vec, vector& result, int start, int k) { vector counter(k - start + 1, 0); // 初始化为待排序数组的范围个0：0~k个0 for (int i = 0; i =0; i--) { result[counter[vec[i] - start]-1] = vec[i]; counter[vec[i] - start]--; } print(counter); } （3）扫描顺序 最后一步填入结果数组时，从原数组的最后向前扫描，保证稳定性。 8.3 Radix Sort 基数排序 8.3.1 算法思路 Digit by Digit Sort：按位排序 基数排序：使用辅助数组的稳定排序，首先对最低有效位进行排序 对每一位进行排序时使用的都是稳定排序，最后结果稳定。 RADIX-SORT(A, d) for (int i = 1; i 若位数不固定：采用最大的位数。 counting sort 合适。 8.2.2 时间复杂度分析 时间复杂度为$\\Theta(dO(n))$，其中$d$是一个常数，时间复杂度为$\\Theta(n)$ 8.4 BucketSort 8.4.1 算法思路 数据特殊性表现在：数据均匀分布。每个区间的数出现的概率相等。 （1）步骤 为每一个值分配一个桶 将$A[i]$插入到桶$B[\\lfloor nA[i]\\rfloor]$中，桶范围为$0~n-1$ 映射关系保证，桶n-k内的数一定比桶n-k-r内的数大 对于每一个桶，内部使用直接插入排序 满足均匀分布，数字较少，插入排序可以认为为常数时间 将各个桶合并 常数时间 （2）算法实现 实际实现时桶的数据结构需要考虑用链表数组来实现。首先给出伪代码： #include #include #include #include using namespace std; class LinkNode{ public: double val; LinkNode *next; LinkNode() : val(0), next(nullptr) {}; LinkNode(double x): val(x), next(nullptr) {} LinkNode(int x, LinkNode *next) : val(x), next(next) {} }; void printVec(vector& vec) { for(int i = 0; i& vec, int a, int b, int n) { // 产生a到b之间均匀分布的n个随机数 srand((unsigned int)time(NULL)); for(int i = 0; i & vec, vector& res, int start, int end) { vector linklist_vec; int n = vec.size(); // 处理链表数组的头结点，头结点不放置数据 for(int i = 0; i next != nullptr and head->next->valnext; } // 找到要插入的位置 LinkNode* next_Pointer = head->next; head->next =new LinkNode(vec[i]); head->next->next = next_Pointer; } // 将非空桶中的数据取出，得到最终的顺序 // 扫描并连接链表 for(int i = 0; i next != nullptr) { head = head->next; res.push_back(head->val); } } } int main() { vector vec; int start = 2, end = 5, n = 30; // 准备随机数 random_generation(vec, start, end, n); // 桶排序 vector res; bucket_sort(vec, res, start, end); printVec(res); } 8.4.2 算法分析 算法的时间复杂度为$O(n)$，插入的时间和内部排序的时间都视作常数。 若区间不在0~1之间，那么要进行修改： [0~2]：$B[\\lfloor nA[i]/2\\rfloor]$ [a, b]：B[\\lfloor n(A[i]-a)/(b-a)\\rfloor] 想一下怎么把这个数变到0~1就行了。 8.5 总结 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH9：Medians and Order Statistics.html":{"url":"算法/CH9：Medians and Order Statistics.html","title":"CH9：Medians and Order Statistics","keywords":"","body":"CH10：Medians and Order Statistics 9.1 Order Statistics 9.1.1 背景介绍 OrderStatistics 排位统计：集合中第i小的元素 中位数：快排中找中位数，代价大 寻找集合中第i小的元素： 最大：i = n 最小：i = 1 中位数 我们可以多快解决这个问题？ 最大或者最小：O(n) 排序：O(nlgn) 下面尝试用O(n)解决 9.1.2 Randomized algorithm for finding the i th element 随机算法 （1）算法思路 算法思路： 利用带有随机的partition算法确定pivot的位置，按照pivot位置和要找的元素的排名对对应的部分进行递归 终止条件：区间长度为1或者是pivot位置就是rank位置 递归找左还是右不要搞错 算法实现： int randomizedSelect(vector& vec, int start, int end, int rank) { if (start == end) return vec[start]; int pivot_index = randomizedPartition(vec, start, end); int pivot_rank = pivot_index - start + 1; if (pivot_rank == rank) { return vec[pivot_index]; } if (rank （2）算法分析 最坏情况下时间复杂度：$T(n) = T(n-1) +\\Theta(n) = \\Theta(n^2)$ 与快排区别，快排是两个子问题。 9.1.3 对于快排的优化 对于快排的时间复杂度，若找中值是线性开销，那么： T(n) = 2T(n/2) + O(n) + O(n) =\\Theta(nlgn) 若找中值是最坏情况： T(n) = 2T(n/2) + O(n) +O(n^2) 线性的找中值： 每5个一组，快速通过直接插入排序找到中值，每组中值的中值作为pivot。 T(n) = T(n/5) + \\Theta(n) + T(7n/10) = \\Theta(n) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"markdown 简洁优雅的排版语言,简化版的 HTML,加强版的 TXT,详情请参考 https://xinwuyun.github.io/markdown/ git 分布式版本控制系统,详情请参考 https://xinwuyun.github.io/git/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"}}