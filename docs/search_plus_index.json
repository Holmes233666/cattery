{"./":{"url":"./","title":"简介","keywords":"","body":"Summary 软工大三下笔记 算法分析与设计笔记 CH1：Introduction CH2：算法入门 CH2：算法入门_review CH3：Growth of Functions CH3：Growth of Functions_review CH4：Recurrences CH6：HeapSort CH7：QuickSort CH8：Sorting in linear time CH9：Medians and Order Statistics CH10：Divide and Conquer：More Algorithms CH15：Dynamic_Programming CH16：Greedy_Algorithms CH24：Shorest_Path CH25：Back-Tracking 软件体系结 CH1：Introduction CH2：Achitecture_Style CH3：UML CH4：理解质量属性 CH5：ATMA 软件过程与项目管理 PART1-判断题错误总结 PART2-选择题答案整理 PART3-填空题 PART4-简答题 保研算法练习AcWing训练 基础算法.md var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/about.html":{"url":"算法/about.html","title":"算法分析与设计","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH1：Introduction.html":{"url":"算法/CH1：Introduction.html","title":"CH1：Introduction","keywords":"","body":"CH1：Introduction 1.1 Factors of Programming programming language IDE software achitecture 架构： 架构的类型： \\begin{cases}C2\\ Style：conponent\\ \\& \\ connector\\\\Pipe-Fliter\\ Style:输入\\rightarrow 输出\\\\Repositories\\ Style：以某一数据源为中心的操作\\end{cases} 成熟的模式：逐步产生商业架构 Java EE CORBA .NET（与javaEE类似） 1.2 More Important 1.2.1 Transaction finish or null 1.2.2 Security 1.3 DS and Algorithm 1.3.1 Algorithm Concept：A well-Defined computational procedure that takes some value, or set of values, as input and proceduces some value, or set of values, as output. Broadly：a step-step procedure for solving a problem or accomplishing some end especially by a computer. issues： correctness efficiency(amount of work done and space used) storage(simplicity, clarity) optimality 1.3.2 Promblem that can be solved by algorithm 基因工程 网络 电子商务 生产 一个经典的问题：you are given n integers(there may be negative ones but not all) a1, a2, ..., an, determine i and j which maximize the sum from $a_i$ to $a_j$. Case：6 integers：(-2, 11, -4, 13, -5, -2) Ans：i = 2, j = 4, max sum is 20 1.3.3 Importance of algorithms 问题：给1000,000个整数排序 数据量 主频 算法时间复杂度 计算时间 1000000 1GHz $2n^2$ $2\\times 10^5\\ seconds$ 1000000 100MHz $50nlgn$ $105\\ seconds$ 加之主频的提升不大，算法更为重要 1.3.4 About course Design and Analysis 怎么找算法？ 评价算法，定量 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH2：算法入门.html":{"url":"算法/CH2：算法入门.html","title":"CH2：算法入门","keywords":"","body":"CH2：算法入门 The problem of sorting input：sequence of n natural numbers output：permutation such that $a_1'\\leq a_2'\\leq ....\\leq a_n'$ 2.1 Insert Sort 算法： for(i = 2; i = 1 and A[j] > key){ A[j+1] = A[j]; // 后移 j--; } A[j+1] = key; } 2.2 Kinds of Analysis worstest - case（usually）：最坏情况优先考虑 Average - case（sometimes） Best - case（bogus） 2.2.1 循环不变式 loop-invariants Proving correctness Using Loop-invariants【外层为循环】 需要证明的三个性质： 初始化：它在循环的第一轮迭代开始时，应该是正确的 保持：如果在某一次的迭代开始前是正确的，那么在下一次迭代开始前，他也应该保持正确 终止：不变式给了一个有用的性质，表明算法是正确的 2.2.2 运行时间 （1）Running Time 运行时间的取决因素： 输入序列：已经排列好的序列【数据特征】 数据规模：更短的序列更容易排好 通常，我们考虑运行时间的上界，因为这是一个保证 （2）Machine-independent time 插入排序的最差时间取决于计算机的速度： 相对速度（on the same machine）——关注算法 绝对速度（on different machine） 通常我们忽视机器相关时间的限制，关注“the growth of T(n) as n → ∞” 称为渐近分析“Asympotic Analysis” （3）$\\theta-$notation 关心增长率，低阶和常数丢弃 Drop low-order terms; ignore leading constants Example：$3n^3+90n^2-5n+6046 = \\theta(n^3)$ 当n变得足够大时，一个$\\theta(n^2)$的算法总会打败一个$\\theta(n^3)$的算法 2.2.3 Insertion Sort Analysis Worest case：Input reverse sorted【逆序的序列】 T(n) = \\sum\\limits_{j = 2,...,n}\\theta(j) = \\theta(n^2) Average case：All permutations equally likely T(n) = \\sum\\limits_{j = 2,...,n}\\theta(j/2)=\\theta(n^2) 2.3 Analysis Algorithm Analysis An Algorithm： 算法分析指的是对一个算法所需的资源进行分析，预测算法所需的资源，包括内存、通信带宽或计算机硬件等。 但是通常我们更想测量计算时间。 2.3.1 RAM RAM：单处理机，随机存储模型 random-access-machine（RAM） Model with no concurrent operations 不考虑并发 executed as an atom operation 不考虑中断，原子操作 每条指令需要固定时间 内存容量足够大 在RAM模型下，对基础的操作进行计数即可 count fundamental operation。 2.3.2 Analysis of Insert Operation 插入排序的时间计算如下： T(n) = c_1n+c_2(n-1) + c_4(n-1)+c_5\\sum\\limits_{j=2}^nt_j+c_6\\sum\\limits_{j=2}^n(t_j-1) + c_7\\sum\\limits_{j=2}^n(t_j-1)+c_8(n-1)\\\\ best case：数组是有序的 **$t_j = 1$，检查一次，不需要后移** T(n) = c_1n+c_2(n-1) + c_4(n-1)+c_5(n-1)+c_8(n-1)\\\\=(c_1+c_2+c_4+c_5+c_8)n-(c_2+c_4+c_5+c_8) 运行时间是n的线性函数 worest case：数组是倒序的 **$t_j = j$，检查一次，不需要后移** T(n) = c_1n+c_2(n-1)+c_4(n-1)+c_5(n(n+1)/2-1)+c_6(n(n-1)/2)+c_7(n(n-1)/2)+c_8(n-1)\\\\=(c_5/2+c_6/2+c_7/2)n^2+(c_1+c_2+c_4+c_5/2-c_6/2-c_7/2+c_8)n-(c_2+c_4+c_5+c_8) 运行时间是n的二次函数。 note： 对于某些算法来说，最坏情况经常发生 平均情况有时候和一般情况一样糟糕 2.3.3 Order of Growth 我们只考虑运行时间的增长顺序: 我们可以忽略低阶项，因为对于非常大的n，它们相对不重要。 我们也可以忽略前项的常系数，因为对于非常大的n，它们对计算效率的增长速度并不重要。 我们刚刚说过，最好的情况是n的线性而最坏/平均的情况是n的二次型。 2.4 Designing Algorithm 2.4.1 Divide and Conquer To solve P： Divide P into smaller problems P_1, P_2, ... , P_k Conquer by solving the (smaller) subproblems recursively Combine the solutions to P_1,P_2,...,P_k into the solution for P （1）Merge Sort Using Divide and Conquer, we can obtain a merge sort algorithm Divide：divide n elements into two subsequences of n/2 elements each Conquer：Solve the two subsequences recursively Combine：Merge the two sorted subsequences to produce the sorted answer Merge-Sort(A，p，r) INPUT: a sequence of n numbers stored in array A OUTPUT: an ordered sequence of n numbers MergeSort(A,p,r) if p Actions of Merge Sort： 2.4.2 Analysis divide and conquer Algorithm $T(n)$ running time on a problem of size n 【n ：问题规模】 假设把原问题分成a个子问题，每个子问题是原问题规模的$1/b$ 对于MergeSort来说，a = 2，每个问题的规模是原问题的1/b $D(n)$ 分解的开销 $C(n)$ 合并的开销 子问题 --合并-->原问题 MergeSort Recurrence Equation T(n) = \\begin{cases}\\Theta(1)\\quad if\\ n≤c\\\\ aT(n/b)+D(n) + C(n)\\quad otherwise\\end{cases} 对于MergeSort来说，递归式如下： T(n) = \\begin{cases}\\Theta(1)\\quad if\\ n≤c\\\\ 2T(n/2)+\\Theta(n)\\quad otherwise\\end{cases} Claim： T(n) = nlog_2^n 所有情况下均为nlog_2^n 最好 最坏 平均 $log_2^n+1$是针对结点的，若是针对边则是$log_2^n$。每层的和是一定的，都是cn 所以总的花费时间为： \\sum_{i=1}^{log_2^n} cn = cn·log_2^n Proof by Telescoping T(n) = 2T(n/2)+n = 2(2T(n/4) + n/2)+n = 4T(n/4)+2n\\\\ =......=nT(n/n)+log_2^n n=nT(1)+nlog_2^n var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH2：算法入门_review.html":{"url":"算法/CH2：算法入门_review.html","title":"CH2：算法入门_review","keywords":"","body":"CH2 算法入门 MindMap 排序问题： 输入：序列$$ 输出：非降序排列：$$，满足$a_1'\\leq a_2'\\leq...\\leq a_n'$ 2.1 Insert Sort 程序： void insertSort(vector& vec) { for (int i = 2; i 0 && vec[j] > key) { vec[j+1] = vec[j]; // 后移操作 j--; } vec[j+1] = key; } } 注意后移操作：A[j+1] = A[j] 若位置0处数字为负无穷，那么while循环中将不用写条件j>0。 2.2 Analysis of algorithms 2.2.1 运行时间 Running Time： 数据的初始特征 数据规模 we seek upper bounds on the running time Kinds of Analysis： Worst - case（usually 最坏情况最优先考虑） Average - case（sometimes） Best - case（bogus） 2.2.2 loop-invariant Proving correctness using loop-invariant：最外层必须是循环，证明某一性质每一次循环都不变 需要证明的三个性质 初始化：他在循环的第一轮迭代开始前，应该是正确的 保持：如果在某一次的迭代开始前是正确的，那么在下一次的迭代开始前他也应该保持正确 终止：循环结束时，不变式给了一个有用的性质，表明算法是正确的 使用循环不变式证明插入排序 证明：在每次迭代开始前子数组A[1...j-1]中元素为原数组中的A[1...j-1]，但是是有序的 初始化 j = 2 保持：A[j - 1], A[j - 2],… are moved one at a time till the proper position for A[j] is found. 结束：当j=n+1时，整个序列有序 2.2.3 机器独立时间 machine independent time relative time：在相同的机器上——关注算法 absolute time：在不同的机器上 忽略机器相关的约束，直接考虑 $n\\rightarrow \\infty$时的$T(n)$ —— 渐近分析 Asymptotic Analysis 2.2.4 $\\Theta-Notation$ （1）定义 $\\Theta$表示法的定义： 数学定义：$\\Theta(g(n)) = {存在正整数c_1和c_2，并且n_0>0，满足当所有的n\\geq n_0时，0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n)}$ 工程上：关心增长率，低阶和常数项丢弃 Example：$3n^3 + 9n^2-5n+8344 = \\Theta(n^3)$ （2）Asyptotic Performance 当n变得足够大的时候，一个$\\Theta(n^2)$的算法一定比一个$\\theta(n^3)$的算法要好 2.2.5 Insertion sort analysis 最差情况：输入是逆序的——每个数都要前移 T(n) = \\sum_{j=2..n}\\Theta(j)=\\Theta(n^2) 平均情况： T(n) = \\sum_{j=2..n}\\Theta(j/2)=\\Theta(n^2) 2.3 算法分析的入门 2.3.1 算法分析的概念 算法分析指的是对一个算法所需的资源进行分析，内存，通信带宽或者计算机硬件是主要关心的，但通常希望测量计算时间。 在我们分析算法之前，我们必须有一个将要使用的实现技术的模型，包括该技术的资源及其成本的模型 算法实现的技术模型：单处理器，随机存储模型[RAM] 2.3.2 Random Access Model 不考虑并发 不考虑中断，原子操作 假设每条指令花费常数时间 内存足够大 …… 在RAM模型下，需要考虑的是基本操作的次数 counting fundamental operations 2.3.3 Analysis of insert operation $cost$：每次基本操作花费的代价 $t_j$：假设第$j$次迭代需要检查$while$循环条件的次数为$t_j$ T(n) = c_1n+c_2(n-1) + c_4(n-1) +c_5\\sum_{j=2}^n t_j+c_6\\sum_{j=2}^n (t_j-1)+c_7\\sum_{j=2}^n (t_j-1)+c_8(n-1) best-case：数组是有序的，$t_j=1$检查一次while，不需要后移 T(n) = c_1n+c_2(n-1) + c_4(n-1) +c_5(n-1)+c_8(n-1) = (c_1+c_2+c_4+c_5+c_8)n -(c_2+c_4+c_5+c_8) 即，最好情况下插入排序开销为线性开销。 worest-case：数组是逆序的，那么$t_j = j$（$i=0$也会检查） \\begin{aligned} T(n)=& c_{1} n+c_{2}(n-1)+c_{4}(n-1)+c_{5}(n(n+1) / 2-1)+c_{6}(n(n-1) / 2) \\\\ & c_{7}(n(n-1) / 2)+c_{8}(n-1) \\\\ =&\\left(c_{5} / 2+c_{6} / 2+c_{7} / 2\\right) n^{2} \\\\ &+\\left(c_{1}+c_{2}+c_{4}+c_{5} / 2-c_{6} / 2-c_{7} / 2+c_{8}\\right) n-\\left(c_{2}+c_{4}+c_{5}+c_{8}\\right) \\end{aligned} 运行时间是平方级开销。 在一些算法中，最坏情况经常发生，比如查询数据库 有时候平均情况和最差情况一样糟糕 Order of Growth 忽略低阶项 忽略常数项 2.4 Designing Algorithms Insert Sort：增量法 2.4.1 Divide-and-Conquer To solve P: Divide P into smaller problems P1 , P2 , …, Pk . Conquer by solving the (smaller) subproblems recursively. Combine the solutions to P1 , P2 , …, Pk into the solution for P. note：解决问题前想一想：该问题难以解决是否是因为规模太大了，若是规模足够小，那么是不是可以解决 2.4.2 Merge Sort 使用分治策略，我们首先分析归并排序。 Divide：把n个元素分成两个子序列，每个子序列有$n/2$个元素 Conquer：递归求解两个子问题 Solve the two subsequences recursively Combine：合并两个子序列，得到有序的结果 （1）Merge-Sort函数 假设我们有一个Merge(A,p,q,r)函数，他把两个有序的数组A[p……q]和A[q+1……r]合并 Merge-Sort 输入：需要排序的n个数序列A 输出：有序序列 #include #include #include using namespace std; void Merge_Sort(vector& vec, int start, int end); // 分治算法主体 void Merge(vector& A, int start, int mid, int end); // 合并的过程，重点在合并 void printVec(vector& vec); int main() { vector nums = {8,5,9,10,3,6,2,7}; Merge_Sort(nums, 0, nums.size()-1); printVec(nums); return 0; } void Merge_Sort(vector& vec, int start, int end) { if (start & A, int start, int mid, int end) { int n1 = mid - start + 1; // 数组1个数 int n2 = end - (mid + 1) + 1; // 数组2元素个数 vector vec1(n1+1), vec2(n2+1); // 临时数组初始化 // 数组末尾设为无穷大简化了扫尾工作 vec1[n1] = 99999; vec2[n2] = 99999; // 数组赋值 for (int i = start; i & vec) { for (int i = 0; i 注意分治时采取自上而下的递归处理时，每个分支执行的顺序，如下： 2.4.3 Analysis divide-and-conquer Algorithm （1）符号定义 $T(n)$：$\\text{running time on a problem of size n}$， 问题的运行时间，n为问题规模 $D(n)$：分解的时间开销 $C(n)$：合并的开销 $子问题\\rightarrow 原问题$ 统一模式： T(n)=\\begin{cases}\\Theta(1)&& if\\ n\\leq c\\\\ D(n) + aT(n/b) + C(n)&& otherwise\\end{cases} 当问题规模足够小时，不需要分治。 否则递归求解 （2）MergeSort Analysis T(n)=\\begin{cases}\\Theta(1)&& if\\ n\\leq c\\\\ 2T(n/2) + C(n)=2T(n/2) + \\Theta(n)&& otherwise\\end{cases} 在归并排序中，分解时分解为2个子问题，每个问题的规模是原来的$n/2$。 Claim：$T(n) = nlog2^n$，所有情况下均为$nlgn$【平均、最好、最坏】 证明： 递归到何时终止？$n/x == 1$时终止，次数：除法$log_2^n$，树高$log_2^n+1$ T(n) = cn·lg^n + c'n 代入法证明 Proof by Telescoping T(n) =2T(n/2) + n\\\\ =2(2T(n/4)+n/2) +n=4T(n/4)+2n\\\\ =4(2T(n/8) + n/4) + 2n = 8T(n/8) + 3n\\\\ =……\\\\=nT(n/2^k) + kn\\\\=……\\\\ =nT(n/2^{lgn}) + nlgn 数学归纳法证明 T(n) = nlgn var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH3：Growth_of_Functions.html":{"url":"算法/CH3：Growth_of_Functions.html","title":"CH3：Growth of Functions","keywords":"","body":"CH3：Growth of Functions Topics： Growth of Functions O/\\Theta/\\Omega notations Asymptotic Growth： We want to express rate of growth of standard functions: the leading term with respect to n 【第一项】 ignoring constants in front of it 【忽略常数项】 3.1 Asymptotic Notation 3.1.1 O-notation O(g(n)) = {f(n) ：There exist positive constants c and n_0 such that 0≤f(n) ≤cg(n) for all $n≥n_0$} O(.) 用来渐近表示计算时间的上届 —— 【最坏情况】 O(.) is used to bound worest-case running time 将f(n)用简洁的O(.)来表示 任何一个二次多项式都是$O(n^2)$ Note： When we say \"the running time is O(n)\"：the worest case running time is O(n) We often write f(n) = O(g(n)), instead of f(n) ∈ O(g(n)) Use O(n) in equations：2n^2+3n+1 = 2n^2+O(n) 3.1.2 $\\Omega-notation$ \\Omega(g(n)) = \\{\\text{There exist positive constants c and n0 such that 0=n0}\\} 【大于g（n）的整数倍】 \\Omega-notation用于给出函数的下界 任何一个二次多项式都是\\Omega(n^2)的。 3.1.3 \\Theta-notation \\Theta(g(n)) = \\{\\text{There exist positive constants c and n0 such that } 0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n)\\ \\text{for all n>=n0}\\} \\Theta(g(n))提供了函数的一个tight bound 紧致界 $f(n) = \\Theta(g(n))$当且仅当f(n) = O(g(n))并且f(n) =\\Omega(g(n)) 只要最高次项，那就是$\\Theta(.)$ Note： We often think of f(n) = O(g(n)) as corresponding to f(n)≤ g(n) f(n) = \\Theta(g(n)) corresponds to f(n) = g(n) f(n) = \\Omega(g(n)) corresponds to f(n) ≥ g(n) Example： 4n^3 + 3n^2 + 2n + 1 = 4n^3 + 3n^2 + Θ(n)= 4n^3 + Θ(n^2) = Θ(n^3) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH3：Growth_of_Functions_review.html":{"url":"算法/CH3：Growth_of_Functions_review.html","title":"CH3：Growth of Functions_review","keywords":"","body":"CH3：Growth of Functions MindMap Asymptotic Growth 分析算法时我们对算法输入规模为n时的最坏情况下运行时间函数感兴趣 不考虑常数项 不考虑低阶项 3.1 Asymptotic Notation 3.1.1 O-Notation （1）定义 O(g(n)) = \\{f(n):\\text{There exists positive c and }n_0\\text{ such that } 0\\leq f(n)\\leq cg(n)\\text{ for all }n\\geq n_0\\} 正整数c 正整数n0 g(n)是最高次项 exists：存在即可 **$O(g(n))$是一个满足上述条件的运行时间函数的集合** $O(.)$：用于渐进上界函数 $\\text{is used to asymptotic upper bound a function}$ $O(.)$：用来表示最坏情况的运行时间$\\text{is used to bound worst-case running time}$ （2）Example （3）使用情况 当我们说道“运行时间是O(n)”时，我们指的是最坏情况下的运行时间是O(n) 通常写为：$f(n) = O(g(n))$，而不是$f(n)\\in O(g(n))$——虽然是个集合 我们也在等式中使用$O(n)$，例子： 2n^2+3n +1 = 2n^2 +O(n) $O(1)$表示常数时间 3.1.2 $\\Omega-Notation$ （1）定义 \\Omega(g(n)) = \\{f(n):\\text{There exists positive c and }n_0\\text{ such that } 0\\leq cg(n)\\leq f(n) \\text{ for all }n\\geq n_0\\} 我们使用$\\Omega(.)$来表示运行时间的下界 （2）Example when we say “the running time is $Ω(n^2 )$” we mean that the best-case running time is $Ω(n^2)$ ——the worst case might be worse. 3.1.3 $\\Theta-Notation$ （1）定义 \\Theta(g(n)) = \\{f(n):\\text{There exists positive }c_1，c_2\\text{ and }n_0\\text{ such that } 0\\leq c_1g(n)\\leq f(n)\\leq c_2g(n) \\text{ for all }n\\geq n_0\\} 我们使用$\\Theta-Notation$来表示紧致界 充要条件：$f(n) = Θ(g(n))\\ if\\ and\\ only\\ if\\ f(n) =O(g(n))\\ \\ and\\ \\ f(n) = Ω(g(n))$ （2）Example 3.1.4 总结 （1）表示法 （2）在等式中的使用 使用$O、\\Theta、\\Omega$在函数中替换低阶项简化函数表达 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH4：Recurrences.html":{"url":"算法/CH4：Recurrences.html","title":"CH4：Recurrences","keywords":"","body":"CH4：Recurrences MindMap Review： MergeSort 分析MergeSort的时间复杂度 递归树 Picture of Recursion Tree 迭代法 Telescoping 数学归纳法 Mathematical Induction 渐近分析 $O-Notation$ $\\Omega-Notation$ $\\Theta-Notation$ 算法包含对自身的调用时，其运行时间可以用递归式表示： $MergeSort：T(n) = aT(n/b) +D(n) +C(n) = 2T(n/2) + O(n)$ 3种求解递归函数的方法： 代换法-------------Substitution 递归树法----------Recursion Tree 主方法-------------Master Method 4.1 Substitution Method 代换法 （1）步骤 步骤： 猜测一个解的形式 Guess the form of solution 使用数学归纳法证明 Verify by induction 求解常数项 Solve for constants （2）例子 Example1：$T(n) = 4T(n/2) + 100n$ 猜测：$O(n^3)$（如果要证明$\\Theta$的话，那么要分别证明O和$\\Omega$） 归纳基础：$T(1) = \\Theta(1)$ 归纳假设：$T(k) \\leq ck^3 $在$k 使用数学归纳法证明：$T(n) \\leq cn^3$ 证明： \\begin{aligned} \\mathrm{T}(\\mathrm{n}) &=4 \\mathrm{~T}(\\mathrm{n} / 2)+100 n \\\\ & \\leq 4 \\mathrm{c}(\\mathrm{n} / 2)^{3}+100 n \\\\ &=(\\mathrm{c} / 2) n^{3}+100 n \\\\ &=\\mathrm{cn}^{3}-\\left((\\mathrm{c} / 2) n^{3}-100 n\\right)\\\\ &\\leq\\mathrm{cn}^{3} \\end{aligned} 最后确定c和n的值即可： Example2：$T(n) = 2T(\\lfloor n/2\\rfloor) + n$ 要严格遵守证明的结果的模式，下面的证明是错误的： Example3：尝试变量替换 考虑：$T(n) = 2T(\\sqrt{n}) + lgn$ Rename：$m = lgn\\Rightarrow T(2^m) = 2T(2^{\\frac{m}{2}})+m$ 令$S(m) = T(2^m)$，则有：$S(m) = 2S(m/2) + m$ 设当$m_0\\leq m$时有：$S(m_0)\\leq cm_0lgm_0$ S(m) = 2S(m/2) + m\\\\ \\leq 2c(m/2)lg(m/2) + m\\\\ =cmlg(m/2)+m\\\\=cmlgm-cm + m\\\\ =cmlgm-(c-1)m\\\\=O(mlgm) 转换回来 $T(2^m) = S(m) = O(mlgm)$ $T(m) = O(lgmlgm)$ $T(n) = O(lgnlglgn)$ （3）猜测方法 使用代换法的一个重要技巧是要猜测 猜测的方式： 递归树的方法帮助猜测 与先前见过的相似 先整较松的上届然后缩小区间 降低上届，提高下界，缩小不确定区间 4.2 Recursion-tree Method 递归树是一个好的猜测的直接方法 递归树方法可能不可靠，就像任何使用省略号的方法一样 4.2.1 例子说明 $T(n) = 3T(n/4) + \\Theta(n^2)$ （1）递归树猜测上界 最后一层叶子数：$3^{log_4^n} = n^{log_4^3}$ 每层开销：$((\\frac{3}{16})^icn^2)$ 总开销：$cn^2 + (\\frac{3}{16})cn^2+(\\frac{3}{16})^2cn^2+......+(\\frac{3}{16})^{log_4^n-1}cn^2 + O(n^{log_4^3})=\\frac{1\\times (1-(\\frac{3}{16})^{log_4^n+1})}{1-\\frac{3}{16}}+O(n^{log_4^3})$ 使用等比数列的上界作为上限： cn^2\\sum_{i=0}^{log_4^n-1}(\\frac{3}{16})^i = \\frac{cn^2}{1-\\frac{3}{16}}=\\frac{13}{16}cn^2 所以： T(n) =cn^2 + (\\frac{3}{16})cn^2+(\\frac{3}{16})^2cn^2+......+(\\frac{3}{16})^{log_4^n-1}cn^2 + O(n^{log_4^3})=\\frac{1\\times (1-(\\frac{3}{16})^{log_4^n+1})}{1-\\frac{3}{16}}+O(n^{log_4^3})\\\\ \\leq \\frac{13}{16}cn^2 +O(n^{log_4^3}) = O(n^2) （2）迭代法证明 递归基础：$T(1) = O(1)$ 归纳假设：$T(k) \\leq ck^2，当k 证明：$T(n) \\leq cn^2$ T(n) = 3T(n/4) + d(n^2)\\\\ \\leq 3c(n/4)^2 + d(n^2)\\\\ =\\frac{3}{16}cn^2 + d(n^2)\\\\ \\leq cn^2 当$d\\geq \\frac{16}{13}c$时成立。 4.3 Master Method “cook book” Method for solving recurrences of the form: T(n) = aT(n/b) + f(n)\\\\ 其中a \\geq 1 , b >1 叶子的个数：$a^h = a^{log_b^n} = n^{log_b^a}$ 比较树根$f(n)$和$n^{log_b^a}$ 三种情况： 由根到叶子\\begin{cases}减少\\\\不变\\\\增大\\end{cases} 4.3.1 Compare f(n) with $n^{log_b^a}$ （1）$f(n) = O(n^{log_{b}^{a}-\\epsilon})$ 叶子开销严格大于树根 $f(n)$多项式增长慢于$n^{log_b^a}(by\\ an\\ n^{\\epsilon}\\ factor)$ $Solution:T(n) = \\Theta(n^{log_b^a})$ 注意是$\\Theta$ （2）$f(n) = O(n^{log_{b}^{a}}(lgn)^k)$ 树根开销为叶子开销的$lgn$的$k$次方倍 其中$k\\geq 0$，整数 $Solution:T(n) = \\Theta(n^{log_b^a}lgn^{k+1})$最终结果多乘以一个树高的k次方 （3）$f(n) = O(n^{log_{b}^{a}+\\epsilon})$ 叶子开销小于树根开销 需要额外满足$af(n/b)\\leq cf(n)$ $T(n)=\\Theta(f(n))$树根量级 4.3.2 Conclusion （1）方法总结 树根和叶子比较，同时要注意什么时候写$O$，什么时候写$\\Omega$，什么时候 例题： Example1 T(n) = 9T(n/3) + n $f(n) = n = O(n^{log_b^{a}-\\epsilon})= n^{2-\\epsilon}$，其中$\\epsilon = 1$ 所以$T(n) = \\Theta(n^2)$ Example2 T(n) = T(2n/3) + 1 $f(n) = 1 = \\Theta(n^{log_{\\frac{3}{2}}^1}lg^kn)$，其中$k=1$ 所以$T(n) = \\Theta(lgn)$ Example3 T(n) = 3T(n/4) +nlgn $f(n) = nlgn = \\Omega(n^{log_4^3}+\\epsilon)$，其中$\\epsilon ≈ 0.2$ 且$af(n/b) = 3f(n/4) = 3\\frac{n}{4}lg{\\frac{n}{4}}=\\frac{3n}{4}(lgn-2)\\leq cnlgn$ 当$c = \\frac{3}{4}, n\\geq 1$时成立。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH6：HeapSort.html":{"url":"算法/CH6：HeapSort.html","title":"CH6：HeapSort","keywords":"","body":"CH6：HeapSort MindMap Topics： Heaps HeapSort Priority queue Recap and Overview 强调稳定性时多关注的是多关键字排序。 插入排序 时间复杂度是$O(n^2)$，原地排序 归并排序 时间复杂度是$O(nlgn)$，需要辅助存储空间 堆排序 时间复杂度是$\\Theta(nlgn)$，原地排序 快排 平均情况的时间复杂度是$O(nlgn)$，原地排序 线性时间的排序 6.1 Heap 6.1.1 堆存储和堆数据结构 （1）堆内存的使用 堆的使用： 内存的分类 \\begin{cases}栈内存：局部变量，方法和函数\\\\ 堆内存：malloc\\ new\\\\ 静态方法区：全局变量\\end{cases} （2）堆数据结构的使用 堆数据结构： 元素按照下标索引——堆数据结构的实现是一个一维数组 每个元素支持：PARENT，LEFT和RIGHT操作 父子关系的映射逻辑为： 若数组下标从1开始，那么父子映射关系函数为： $PARENT(i) = \\lfloor i/2 \\rfloor$ $LEFT(i) = 2i$ $RIGHT(i) = 2i+1$ 若数组下标从0开始，那么父子映射关系函数为： $PARENT(i) = \\lceil i/2 \\rceil -1$ $LEFT(i) = 2i+1$ $RIGHT(i) = 2i+2$ int getParent(int child) { return ceil(child / 2.0) - 1; } int getLeft(int parent) { return parent * 2 + 1; } int getRight(int parent) { return parent * 2 + 2; } 堆中父子的大小关系 \\begin{cases}大顶堆：A[PARENT(i)]\\geq A[i]\\\\ 小顶堆：A[PARENT(i)]\\leq A[i]\\end{cases} 堆中的第一个元素是$A[0]$或者$A[1]$，对应两种不同的情况 结点的高度是从该结点到叶子结点的最长路径。 堆的高度是树根的高度。 叶子结点的高度为0，树根的高度为树的高度。 有n个结点的树的高度为$\\lfloor lgn\\rfloor$ （3）时间复杂度概述 MAX-HEAPIFY：保证堆是一个大顶堆，时间复杂度是$O(lgn)$ Build-Max-Heap：建堆，时间复杂度是$O(n)$ 堆排序：堆排序时，我们首先要建成一个大顶堆，然后反复执行，取下结点后调用MAX-HEAPIFY的过程，时间复杂度是$O(nlgn)$ 6.1.2 堆的建立 建堆两种方式：递归建堆和非递归建堆 （1）递归建堆 递归建堆三个步骤：分、治、合并 分：分解成子树 治：递归处理左子树和右子树 合并：MaxHeapify void buildMaxHeap(int parent, vector& vec) { if (parent （2）非递归建堆 非递归建堆过程采用循环的建堆方式，从最后一个非叶子结点开始，逐步建堆 最后一个非叶子结点的下标：$\\lfloor vec.size()/2\\rfloor$ void buildMaxHeap_iteration(vector& vec) { int last_non_leaf = vec.size() / 2; for (int i = last_non_leaf; i >= 0; i--) { maxHeapify(vec, i); } } （3）合并过程：MAXHEAPIFY MaxHeapify()时间复杂度为$O(h)$，其中$h$是树的高度，$h = \\lfloor lgn \\rfloor $ 递归写法 写成递归处理的形式如下： void maxHeapify(vector& vec, int parent) { int largest = parent; int left = getLeft(parent); int right = getRight(parent); // 找到父子之间最大值的位置 if (left vec[largest]) { // 注意短路判决 largest = left; } if (right vec[largest]) { // 注意短路判决 largest = right; } // 更换位置 if (largest != parent) { int temp = vec[largest]; vec[largest] = vec[parent]; vec[parent] = temp; // 接着maxheapify处理子树 maxHeapify(vec, largest); } } 循环写法 上述的写法是在结束的时候调用递归处理，这种写法很容易改成循环的形式。如下： void maxHeapify(vector& vec, int parent) { int largest = parent; bool ifChange = true; while(ifChange) { int left = getLeft(parent); int right = getRight(parent); // 找到父子之间最大值的位置 if (left vec[largest]) { // 注意短路判决 largest = left; } if (right vec[largest]) { // 注意短路判决 largest = right; } // 更换位置 if (largest != parent) { // 需要交换 int temp = vec[largest]; vec[largest] = vec[parent]; vec[parent] = temp; ifChange = true; }else{ ifChange = false; } } } （4）运行时间分析 若采取直接的方式分析运行时间，那么时间将会是： T(n) = O(n/2)\\times O(lgn) = O(nlgn) **key observation：** T(n) = 2T(n/2) + O(lgn) $f(n) = lgn = O(n^{log_2^2-\\epsilon})=O(n^{1-\\epsilon})$ 所以堆排序的时间复杂度为$\\Theta(n)$ 6.1.3 堆排序 堆排序策略：每次取出堆顶的元素，使用堆中最后一个元素与堆顶元素交换，然后调用MaxHeapify void HeapSort(vector& vec) { int size = vec.size(); // 从0开始的 for (int i = size - 1; i >= 1; i--) { // 从最后一个结点开始 int temp = vec[i]; vec[i] = vec[0]; vec[0] = temp; size = size - 1; maxHeapify(vec, 0, size); } } 时间复杂度：$O(nlgn)$ 原地排序 inplace 不稳定排序 6.2 PriorityQueue 6.2.1 应用 最大值优先队列的应用： 在共享计算机上调度工作 实现优先队列 最小值优先队列应用： 迪杰特斯拉算法 Prim 最小生成树算法 哈夫曼编码 6.2.2 优先队列 操作： 插入一个元素Insert(S, x) 获得最大值MAXIMUM(S) 取出最大值EXTRACT-MAX(S) INCREASE-KEYS(S, x, k) 将位置x的元素正大为key （1）获得最大元素 MAXMUM(A) return A[0]; （2）去除最大元素 先检查溢出 最后一个元素与第一个元素交换 maxHeapify调整 int PriorityQueue::extract_max() { if (vec.size() （3）增大元素 首先判断是否是增大 一直和父亲换，直到父亲的值更大 void PriorityQueue::increase_key(int index, int key) { if (key 0 && vec[parent(index)] （4）插入元素 堆大小加一 将末尾元素设置为无穷小 调用增大元素的函数进行处理 void PriorityQueue::insert(int key) { // 放到最后 vec.push_back(key); // 向上比较调整 increase_key(vec.size()-1, key); } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH7：QuickSort.html":{"url":"算法/CH7：QuickSort.html","title":"CH7：QuickSort","keywords":"","body":"CH7：QuickSort 7.1 Description of QuickSort 7.1.1 Randomized algorithm 随机的应用： QuickSort rand()：产生0~1之间随机数 为什么使用随机？——没有更好的解决方法 7.1.2 快排的概述 分治的结果：分解时做得少，那么合并时就要做的多。反之，分解时做得多，那么合并时做得少。 Divide：利用pivot将数组分为两半，一半比pivot大，一半比pivot小 Conquer：递归求解子数组 Combine：Trival 7.1.2.1 Divide and Conquer （1）QuickSort 主算法：quickSort(A, p, r) 主要做分治，分解问题时做较多的石墙：每次确定pivot的位置 pivot位置确定后，分别递归求解左边和右边的数组 算法为原地排序，不需要合并 void quickSort(vector& vec, int start, int end) { if (start （2）Partition 注意i的初始化 注意各个区间的表示含义： 程序如下： int partition(vector& vec, int start, int end) { // pivot的选择 int pivot = vec[end]; // 选择最后一个元素充当pivot int i = start - 1; for (int j = start; j 有多少个比pivot小的，那么就加几次1 7.1.2.2 快排的分析 假设每个元素是不一样的，现实中，如果有重复的元素，那么有更好的算法存在。 （1）快排的最坏情况 我们假设$T(n)$是最坏情况下的运行时间，那么： 最坏情况发生在pivot是最大或者最小的元素时，此时，问题分解成两个问题，其中一个问题的规模为0，另一个问题的规模为n-1。 一次只会减少规模1. T(n) = T(n-1) + T(0) +\\Theta(n) 递归树如下： （2）快排的最好情况 快排的最好情况发生在每次选取的pivot为中位数时， T(n) = 2T(n/2) +\\Theta(n) 此时，递归树如下： 时间复杂度与归并相同。 （3）1:9情况 假设pivot每次把数组分为1:9的两个数组，那么递归式如下： T(n) = T(9n/10)+T(n/10) +\\Theta(n) 此时的递归树如下： 每次都除以$9/10$，那么树高为$log_{\\frac{10}{9}}^{n}$ 总代价小于$cnlog_{\\frac{10}{9}}^{n}$，所以时间复杂度$T(n) = O(nlgn)$ （4）引入随机的快排 随机选择一个元素作为Pivot。 // 引入随机 int RandomizedPartition(vector& vec, int start, int end) { int p = rand() % (end - start + 1) + start; // 随机选择一个作为pivot int temp = vec[p]; vec[p] = vec[end]; vec[end] = temp; return partition(vec, start, end); } 每次都选到最大或者最小的数的概率为： $\\frac{2}{100}\\times\\frac{2}{99}.......\\times \\frac{2}{2}$ excepted time 为$O(nlgn)$ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH8：Sorting_in_linear_time.html":{"url":"算法/CH8：Sorting_in_linear_time.html","title":"CH8：Sorting in linear time","keywords":"","body":"CH8：Sorting in linear time Comparision Sort 比较排序：在排序的最终结果中，各元素的次序依赖于他们之间的比较。 任何的比较排序最好的最坏情况下经过$\\Omega(nlgn)$次比较，归并，堆排都是最优的。 8.1 排序算法的下界 $Sort$ 判定树：Decision Tree 内部节点：$i：j$标识，满足$1\\leq i,j\\leq n$ 叶子结点为一个排序序列：$$ 算法的执行对应一条从根节点到叶子结点的路径，每个内部节点标识一次比较$a_i\\leq a_j$。 树包含所有可能出现的结果。 上树表示的是直接插入排序的结果。 从根节点到达任意一个可达叶子结点直接的最简单路径的长度：最坏情况下的比较次数。 所有情况：叶子数量为$n$的全排列，即$n!$ h\\geq lg(n!) \\geq lg(n/e)^n\\\\ =nlgn-nlge=\\Omega(nlgn) 归并排序和堆排序是渐进分析框架下的最优比较排序算法。 不可能比$\\Omega(nlgn)$更好 ------------------------------------------>不靠比大小排序，数据具有特殊性 8.2 Counting Sort 计数排序 8.1.1 算法思路 输入：小范围内整数，重复值较多。数据范围为$[1……n]$ 输出：另一个顺序数组$[1...n]$已排序 辅助数组：C[1...k] 算法思想： For x in A, if there are 17 elements less than x in A, then x belongs in output position 18. How if several elements in A have the same value? – Put the 1st in position 18, 2nd in position 19,3rd in position 20,… How if there are 17 elements not greater than x in A? – Put the last one in position 17, the penultimate one in position 16,… 利用数据特殊性，使用k个计数器。 vector countingSort(vector& vec, int k) { // 计数器初始化为全0 vector C(k+1, 0); // 初始化计数器 vector result = vec; // 初始化结果数组 // 统计等于该数的数据数量 for (int i = 1; i = 1; i--) { // 从原数组的最后一个开始向前扫描：保证稳定排序 result[C[vec[i]]] = vec[i]; // 三重嵌套，注意 C[vec[i]]--; // 使用一次减一回 } return result; } 8.1.2 算法分析 （1）时间复杂度分析 该算法如果输入的数据是小范围的，k不超过n，那么时间复杂度为$\\Theta(n)$，最坏情况下也是$\\Theta(n)$ （2）偏移考虑 数组范围： 如果范围是$0……k$，那么计数器C[0]也使用即可 如果范围是$[2……k]$，那么计数器$C[1]$不用 如果范围是$[5000……5100]$，那么计数器所有的$C[vec[i]-偏移量]$ // 给定某个范围，比如5000~5015 void counting_sort2(vector& vec, vector& result, int start, int k) { vector counter(k - start + 1, 0); // 初始化为待排序数组的范围个0：0~k个0 for (int i = 0; i =0; i--) { result[counter[vec[i] - start]-1] = vec[i]; counter[vec[i] - start]--; } print(counter); } （3）扫描顺序 最后一步填入结果数组时，从原数组的最后向前扫描，保证稳定性。 8.3 Radix Sort 基数排序 8.3.1 算法思路 Digit by Digit Sort：按位排序 基数排序：使用辅助数组的稳定排序，首先对最低有效位进行排序 对每一位进行排序时使用的都是稳定排序，最后结果稳定。 RADIX-SORT(A, d) for (int i = 1; i 若位数不固定：采用最大的位数。 counting sort 合适。 8.2.2 时间复杂度分析 时间复杂度为$\\Theta(dO(n))$，其中$d$是一个常数，时间复杂度为$\\Theta(n)$ 8.4 BucketSort 8.4.1 算法思路 数据特殊性表现在：数据均匀分布。每个区间的数出现的概率相等。 （1）步骤 为每一个值分配一个桶 将$A[i]$插入到桶$B[\\lfloor nA[i]\\rfloor]$中，桶范围为$0~n-1$ 映射关系保证，桶n-k内的数一定比桶n-k-r内的数大 对于每一个桶，内部使用直接插入排序 满足均匀分布，数字较少，插入排序可以认为为常数时间 将各个桶合并 常数时间 （2）算法实现 实际实现时桶的数据结构需要考虑用链表数组来实现。首先给出伪代码： #include #include #include #include using namespace std; class LinkNode{ public: double val; LinkNode *next; LinkNode() : val(0), next(nullptr) {}; LinkNode(double x): val(x), next(nullptr) {} LinkNode(int x, LinkNode *next) : val(x), next(next) {} }; void printVec(vector& vec) { for(int i = 0; i& vec, int a, int b, int n) { // 产生a到b之间均匀分布的n个随机数 srand((unsigned int)time(NULL)); for(int i = 0; i & vec, vector& res, int start, int end) { vector linklist_vec; int n = vec.size(); // 处理链表数组的头结点，头结点不放置数据 for(int i = 0; i next != nullptr and head->next->valnext; } // 找到要插入的位置 LinkNode* next_Pointer = head->next; head->next =new LinkNode(vec[i]); head->next->next = next_Pointer; } // 将非空桶中的数据取出，得到最终的顺序 // 扫描并连接链表 for(int i = 0; i next != nullptr) { head = head->next; res.push_back(head->val); } } } int main() { vector vec; int start = 2, end = 5, n = 30; // 准备随机数 random_generation(vec, start, end, n); // 桶排序 vector res; bucket_sort(vec, res, start, end); printVec(res); } 8.4.2 算法分析 算法的时间复杂度为$O(n)$，插入的时间和内部排序的时间都视作常数。 若区间不在0~1之间，那么要进行修改： [0~2]：$B[\\lfloor nA[i]/2\\rfloor]$ [a, b]：B[\\lfloor n(A[i]-a)/(b-a)\\rfloor] 想一下怎么把这个数变到0~1就行了。 8.5 总结 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH9：Medians_and_Order_Statistics.html":{"url":"算法/CH9：Medians_and_Order_Statistics.html","title":"CH9：Medians and Order Statistics","keywords":"","body":"CH9：Medians and Order Statistics MindMap 9.1 Order Statistics 9.1.1 背景介绍 OrderStatistics 排位统计：集合中第i小的元素 中位数：快排中找中位数，代价大 寻找集合中第i小的元素： 最大：i = n 最小：i = 1 中位数 我们可以多快解决这个问题？ 最大或者最小：O(n) 排序：O(nlgn) 下面尝试用O(n)解决 9.1.2 Randomized algorithm for finding the i th element 随机算法 （1）算法思路 算法思路： 利用带有随机的partition算法确定pivot的位置，按照pivot位置和要找的元素的排名对对应的部分进行递归 终止条件：区间长度为1或者是pivot位置就是rank位置 递归找左还是右不要搞错 算法实现： int randomizedSelect(vector& vec, int start, int end, int rank) { if (start == end) return vec[start]; int pivot_index = randomizedPartition(vec, start, end); int pivot_rank = pivot_index - start + 1; if (pivot_rank == rank) { return vec[pivot_index]; } if (rank （2）算法分析 最坏情况下时间复杂度：$T(n) = T(n-1) +\\Theta(n) = \\Theta(n^2)$ 与快排区别，快排是两个子问题。 9.1.3 对于快排的优化 对于快排的时间复杂度，若找中值是线性开销，那么： T(n) = 2T(n/2) + O(n) + O(n) =\\Theta(nlgn) 若找中值是最坏情况： T(n) = 2T(n/2) + O(n) +O(n^2) 线性的找中值： 每5个一组，快速通过直接插入排序找到中值，每组中值的中值作为pivot。 T(n) = T(n/5) + \\Theta(n) + T(7n/10) = \\Theta(n) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH10：Divide_and_Conquer：More_Algorithms.html":{"url":"算法/CH10：Divide_and_Conquer：More_Algorithms.html","title":"CH10：Divide and Conquer：More Algorithms","keywords":"","body":"CH10：Divide and Conquer：More Algorithms 10.1 Square matrix multiplication 矩阵相乘 10.1.1 分治算法 $A = (a{ij})，B = (b{ij})$，都是n×n的矩阵 定义： $C = A\\times B, c{ij} = \\sum{k=1}^{n}a{i,k}b{k,j}$ 矩阵相乘的算法： 分治：partition 矩阵相乘符合标量乘法 矩阵乘法的分治：Square-Matrix-Multiply-Recursive(A,B) T(n) = 8T(n/2) + (\\frac{n}{2})^2\\\\ f(n) = \\Theta(n^2)\\\\ n^{log_2^8} = n^3\\\\ T(n) = O(n^3) 10.1.2 Strassen’s method 10.2 The Maximum - subarray problem 10.2.1 问题背景 要求最低点买入？最高点卖出？ 建模为最和子数组和问题： 10.2.2 暴力解法 暴力解法：穷举所有的子数组——穷举所有的下标可能情况，找出最大值的子数组. 暴力解法程序如下： // 暴力穷举子数组 int maxSum_brute(vector& vec) { int maxSum = -1; int besti = -1, bestj = -1; for (int i = 0; i maxSum) { maxSum = tempSum; besti = i; bestj = j; } } } return maxSum; } 时间复杂度是$O(n^2)$ 10.2.3 分治法 分治法需要额外考虑一个cross的情况：最优解可能是在两个子数组的中间得到。 \\begin{cases}二分\\\\n推n-1\\end{cases} Divide：把数组分成两个数组 Conquer：递归求解子问题，并额外求解跨越中间的情况 Combine：三挑一，找到最大和子数组 算法实现如下： // 分治法，含有cross int getMidMax(vector& vec, int start, int end, int mid) { int maxsum = vec[mid]; int maxNum = vec[mid]; for (int i = mid - 1; i >= start; i--) { maxsum += vec[i]; if (maxsum > maxNum) { maxNum = maxsum; } } maxsum = maxNum; for (int i = mid + 1; i maxNum) { maxNum = maxsum; } } return maxNum; } int maxSum(vector& vec, int start, int end) { if (start == end) return vec[start]; // 分 int mid = (start + end) / 2; // 治 int maxSumLeft = maxSum(vec, start, mid); int maxSumRight = maxSum(vec, mid + 1, end); int maxSumCross = getMidMax(vec, start, end, mid); // 合并 int maxNum = max(maxSumLeft, maxSumRight); maxNum = max(maxNum, maxSumCross); return maxNum; } 时间复杂度：$nlgn$ $T(n) = 2T(n/2) + \\Theta(n)$ $f(n) = n^{log_2^2} = n = \\Theta(nlg^0k)$ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH15：Dynamic_Programming.html":{"url":"算法/CH15：Dynamic_Programming.html","title":"CH15：Dynamic_Programming","keywords":"","body":"CH15：Dynamic Programming MindMap： 动态规划：分治应用在优化问题上 15.1 Optimization Problems 15.1.1 动态规划与DC 动态规划是一种算法设计策略，类似分治。 动态规划是自下而上的计算，而不是自上而下的计算。 bottom up rather than top down 15.1.2 动态规划求解问题的步骤 动态规划的方法有4个步骤： 刻画问题的最优解的结构，如何利用子问题求解父问题【最优子结构找出来】 问题的最优解一定使用子问题的最优解 递归定义最优解的值 区分最优解和最优解的值，动态规划求解问题时通常计算的是最优解的值，而不是最优解 递推式代表的是最优解的值，表示的是怎么用子问题的最优解 按照从下至上的模式求解 递归+备忘录 // 自下而上，计算次序需注意 重构最优解 最优解的值知道了，还需要计算最优解 怎么挑？过程需要保存。 15.2 装配线问题 Assembly Line Scheduling 15.2.1 背景 工厂中有两条平行的装配线，每条线n个站：$S{i,1},S{i,2},...,S_{i,n}$，$i=1,2$ 每个站$S{1,i}$和$S{2,j}$做的事情相同，但可能有不同的装配时间：$a_{i,j}$ 此外若是从装配线$i$到装配线$j$，需要花费传送时间：$t_{i,j}$ 流水线可以混用，切换流水线需要代价 开始时有准备时间$e_i$和最后的离开时间$x_i$ 如何选择调度，才能获得时间上最短的最优解？ 15.2.2 算法分析 （1）分析 对于当前站$S_{1,j}$，选择只有两种： if $j = 1$，那么只有一种 如果$j \\geq 2$，那么： 直接从$S_{1,j-1}$站到达 由$S{2,j-1}$站传递到$S{1,j-1}$ 依赖于最优子结构Optimal substructure：一个问题的最优解一定包含子问题的最优解 （2）递推式 分两个线路写递推式： 站点1： f_{1,j} = \\begin{cases}a_{1,1} + e_1&& if \\ j=1\\\\ min(f_{1,j-1}+a_{1,j}, f_{2,j-1}+t_{2,j-1}+a_{1,j})&& if \\ j\\geq2\\end{cases} 站点2： f_{2,j} = \\begin{cases}a_{2,1} + e_2&& if \\ j=1\\\\ min(f_{2,j-1}+a_{2,j}, f_{1,j-1}+t_{1,j-1}+a_{2,j})&& if \\ j\\geq2\\end{cases} Total Time： $min{f_1[n]+x_1, f_2[n]+x2}$ 15.2.3 算法实现 （1）直接实现 直接按照上述思路，实现程序如下： int fun1(int j) { if (j == 1) { return t1[0] + a1[1]; } return min(fun2(j-1) + t2[j-1] + a1[j], fun1[j-1] + a1[j]); } int fun2(int j) { if (j == 1) { return t2[0] + a2[1]; } return min(fun1(j-1) + t1[j-1] + a2[j], fun2[j-1] + a2[j]); } int main() { int time = min(fun1(n) + t1[j], f2(n) + t2[j]); return 0; } 算法时间复杂度为$T(n) = 2T(n-1) + O(1)$ 含有大量的重复计算的过程，时间复杂度为$O(2^n)$，可以使用备忘录的思路。 （2）自下而上 从1~n计算，非递归 j 1 2 3 4 5 6 f1[j] 9 18 20 24 32 35 f2[j] 12 16 22 25 30 37 $f^* = min(35+3, 37+2)$ 算法实现： 使用数组$L$记录本次选择。 打印站点的选择情况： 栈打印 递归打印 15.3 Matrix Chain Product 15.3.1 问题背景 n个矩阵，每个矩阵维度可能不同，保证能够连乘，求解链乘的最小代价。 代价的定义：使用标量乘法的次数表示代价scalar multiplications $A_1:p\\times q\\quad A_2:q\\times r$ 那么$A_1\\times A_2$的代价为：$p\\times q\\times r$ 非方阵，乘法的计算顺序导致最后的计算量不同。 Order1 15.3.2 求解 15.3.2.1 暴力解法 穷举加括号的方式，多少种加括号方式？ 15.3.2.2 分治 （1）刻画最优解结构 考虑常见的两种分治方法： 二分： 不一定分成中间两半：最优解不一定用到子问题的最优解 n推n-1： 99个知道---->100个：不一定用第99个的最优解 上述两种情况：二分和n推n-1提供的都是子问题的一种可能，需要列举所有的子问题，划分很重要，所有的划分都要列举。 需要列举所有的可能的子问题：n-1个子问题，原问题的最优解一定用的是n-1个子问题中的一个。 子问题如何求解：递归求解。 （2）递归定义最优解的值 最优解：怎么加括号 最优解的值：最小的计算量 首先描述该问题需要左括号位置和右括号位置两个维度，所以该递归式的公共样式必然是一个二维表达式，不妨用𝑚[𝑖,𝑗]表示： 其中𝑖是右括号的位置 𝑗是左括号的位置 𝑚[𝑖,𝑗]为规模为𝑖 ∼ 𝑗的矩阵链乘问题的最小代价值 其次，结合上图的加括号的方式，规模为𝑛时是从𝑛 − 1个子问题中挑选。我们可以推得，对于任意一个规模为𝑖 ∼ 𝑗的问题，其子问题的个数为𝑗 − 𝑖个。 对应的子问题可以描述为𝑖 ∼ 𝑘个矩阵作为子问题计算，𝑘 + 1 ∼ 𝑗个矩阵作为另一个子问题计算，𝑘的取值范围应该满足𝑖 ≤ 𝑘 最后，需要注意父问题的代价不仅仅是两个子问题的最小代价相加，还包括两个子问 题合并的代价，以代价数组的形式描述合并的代价即为：𝑃[𝑖 − 1]𝑃[𝑘]𝑃[𝑗] 递归式： m[i,j] = \\min_{i\\leq k （3）自下而上计算 ①递归算法 终止条件： i==j：开销为0 因为重复计算存在，所以，需要打备忘录 备忘录结果如下： // 递归写法的初始化备忘录 void init_memo(vector>& res, vector& p) { for(int i = 0; i & cost, int start, int end, vector>& choose, vector>& res) { if (res[start][end] != 999999) return res[start][end]; for (int k = start; k new_cost) { res[start][end] = new_cost; choose[start][end] = k; } } return res[start][end]; } ② 自下而上 注意规模： 初始化，矩阵规模为1时，计算量为0；规模为其他时，初始将计算量置为无穷 起始矩阵确定，规模确定，那么末尾矩阵确定 在起始和末尾之间遍历k，选择最小的 程序实现： // 自下而上的求解 int matrix_chain_product_down_top(vector& p, int start, int end, vector>& choose, vector>& res) { for (int l = 2; l = cost) { res[i][j] = cost; choose[i][j] = k; } } } } return res[start][end]; } 时间复杂度是$O(n^3)$ Example： （4）重构最优解 p[i,j] = \"(\" p[i, s[i,j]] p[s[i,j]+1, j] \")\" // 打印加括号的方法 void printBracket(vector> s, int i, int j) { if(i == j){ cout 15.3 动态规划原理 最优子结构 optimal substructure 满足：可用DC---->DP Q： 是否一定用子问题的最优解？怎么用？ 维数 最优解的值：几挑一 15.3.1 Optimal substructure 不一定能应用在所有问题上，有些问题只能穷举：TSP 不满足最优子结构的例子：最长/短简单路径Longest simple path 简单路径：不能绕环 15.4 Longest Common Subsequence 子序列：不一定连续，但是顺序一定 15.4.1 算法分析 暴力求解：首先找到较短串的所有子序列$O(2^m)$，然后在在较长串中比较$O(n)$，总时间复杂度为$O(n2^m)$ 分治： 串变短方式： 二分 n推n-1 串末尾比较 \\begin{cases}末尾相同：最优解一定会用该字母，最终解为子问题最优解 + 1\\\\ 末尾不同：不可能两个字母都用，只有一个可用，挑一个最优的\\end{cases} 递归式： c[i,j] = \\begin{cases}c[i-1,j-1]+1&& x[i]==y[j]\\\\ max(c[i-1,j],c[i,j-1])&& x[i]\\neq y[j]\\end{cases} 边界条件： $j==0或i==0$，某一串为空，那么最长公共子序列长度为0 15.4.2 算法实现 （1）直接实现 时间复杂度较高，重复子问题 // 递归-无备忘录 int LCS_recursive(string& x, string& y, int i, int j) { if (j == -1 || i == -1) { return 0; } if (x[i] == y[j]) return LCS_recursive(x, y, i-1, j-1) + 1; return max(LCS_recursive(x, y, i-1, j), LCS_recursive(x, y, i, j-1)); } （2）递归+备忘录 /** 递归写法，带备忘录 **/ int recursive_LCS_Memoization(string& x, string& y, int i, int j, vector>& res, vector>& s) { if(res[i+1][j+1] != -999999) { // 自己不为空，那么直接返回即可。 return res[i+1][j+1]; } if(x[i] == y[j]) { int num = recursive_LCS_Memoization(x, y, i - 1, j - 1, res, s); res[i+1][j+1] = num + 1; }else{ int num1 = recursive_LCS_Memoization(x, y, i-1, j, res, s); int num2 = recursive_LCS_Memoization(x, y, i, j-1, res, s); res[i+1][j+1] = max(num1, num2); } return res[i+1][j+1]; } /* 备忘录的初始化 */ void init_memoization(vector>& res, string& x, string& y) { // 第0行和第0列初始化为0 for(int i = 0; i （3）自下而上 /** 递归写法，带备忘录 **/ int recursive_LCS_Memoization(string& x, string& y, int i, int j, vector>& res, vector>& s) { if(res[i+1][j+1] != -999999) { // 自己不为空，那么直接返回即可。 return res[i+1][j+1]; } if(x[i] == y[j]) { int num = recursive_LCS_Memoization(x, y, i - 1, j - 1, res, s); res[i+1][j+1] = num + 1; }else{ int num1 = recursive_LCS_Memoization(x, y, i-1, j, res, s); int num2 = recursive_LCS_Memoization(x, y, i, j-1, res, s); res[i+1][j+1] = max(num1, num2); } return res[i+1][j+1]; } /* 备忘录的初始化 */ void init_memoization(vector>& res, string& x, string& y) { // 第0行和第0列初始化为0 for(int i = 0; i void printLongest(vector>& s, string& x, string& y, int i, int j) { if (i == -1 or j == -1) return; string last = s[i][j]; if(last == \"↖\") { printLongest(s, x, y, i-1, j-1); cout 15.5 最大子数组和 漏掉不能递归，是不愿看到的。 改变建模方式：以$a_k$结尾的最大和子数组 $b[j] = max(b[j-1]+a[j], a[j])$ 子问题是不是正数？正数就加 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH16：Greedy_Algorithms.html":{"url":"算法/CH16：Greedy_Algorithms.html","title":"CH16：Greedy_Algorithms","keywords":"","body":"CH16：Greedy Algorithms MindMap： DC---优化--->DP----->Greedy DP：有时overkill Greedy：认准一种 16.1 Activity-Selection Problem 活动集合：$A = {a_1,a_2,...,a_n}$ 不同的活动持续时间不同，开始时间和结束时间：$(s_i,f_i)\\qquad 1\\leq i\\leq n$ 目标：最大不冲突活动集合 \"non-overlapping\" activities Selection \\begin{cases}按结束时间排序√\\\\按开始时间排序？\\end{cases} 16.1.1 例子分析 若穷举：$2^n$种选择 16.1.1.1 分治 （1）二分 $a1,a_2,……,a_k$|$a{k+1},……,a_n$ ​ 3 4 ​ 3+4 ？ 不一定，可能冲突 从合并的角度看，两个子问题不相互独立，可能冲突，无法合并。 （2）n推n-1 与二分问题相同，也可能冲突 （3）cross 需要子问题提供所有的最优解，次优解……规模失控 （4）建模子问题：活动集 s_{ij} = \\{a_k\\in S: f_i\\leq s_k 活动i结束后开始，活动j开始前结束的活动集合。 将活动作为隔离： 使用一个集合$s{0,n+1}$，其中$s_0$的结束时间为0时刻，$s{n+1}$的开始时间为无穷 最终的答案是$S_{0,n+1}$ 使用某一个活动作为隔离， 中间的终止条件：$s_{i,j}$为空，如：a_i的结束比a_j的开始要晚 $A{i,j} = A{i,k}\\cup {ak}\\cup A{k,j}$ 那么，问题的最优解的值可以递归定义为： c[i,j]=\\begin{cases}0&&if\\ S_{i,j}=\\empty\\\\ \\max\\limits_{i 16.1.1.2 Greedy （1）k的挑选 是否真的要挑所有的k？ 冲突的活动不需要作为k进行挑选 问题特殊性：知道k=?时最优？ 最优解中一定包含结束最早的。——不用穷举所有的k，直接找结束时间最早的。 （2）求解实现 递归实现 没有要和j比的，aj的开始时间是无穷大，肯定满足。 迭代实现 按照结束时间排序，进行扫描即可。 时间复杂度为$O(n)$ void iterate_AS(vector acts, vector& res) { sort(acts.begin(), acts.end(), Activity::cmp); res.push_back(acts[0]); int last_act = 0; for (int i = 1; i = acts[last_act].end) { res.push_back(acts[i]); last_act = i; } } } 16.1.2 贪心策略分析 贪心策略何时满足： Greedy Choice property 一个问题的全局最优解能够通过该局部最优解得到 Optimal subtructure 一个问题一定使用子问题的最优解 16.2 Knapsack Problem \\begin{cases}0-1背包：要么拿，要么不拿，穷举2^n种可能性\\\\ 分数背包：拿多少，穷举可能性为无穷大\\end{cases} 最优子结构的判定：是否一定使用子问题的最优解？ 子问题：是否剩下的容量一定用其最大价值？是 ——满足最优子结构，推给子问题。 16.2.1 Fractional Knapsack 无法推给子问题。 最优解一定装满性价比最高的。 16.2.2 0-1 Knapsack Problem （1）分治思路分析 寻找规模压缩的方法 规模\\begin{cases}背包的容量\\\\物品的数量\\end{cases}\\qquad 任何一个减少都是规模压缩 思路： ① 二分容量和物品：经常不对，子问题的情况太多 ② n推n-1 那么推给子问题有两种情况： \\begin{cases}容量全给子问题\\\\容量自己留一部分，剩余部分给子问题\\end{cases} 子问题递归求解 最优解的值：能得到的最大价值： $c[i,j]：前i个物品，背包容量为j$： c[i,j] = max(c[i-1, j], c[i-1,j-w[i]] + v[i]) 对物品的顺序无要求，实际逻辑就是要列举每个物品装入或者不装入 实际上递归比两个for要快，：只会调部分，不是所有的子问题都要计算。 初始的条件：背包容量为空和可选物品为空时，代价均为0 // 0-1背包，递归求解前item_num个物品在背包容量为capacity时的最大价值 // 使用备忘录 double knapstack_dp(vector& items, int item_num, int capacity, vector>& result, vector& choose) { // 查看备忘录 if(result[item_num][capacity] != -99999) { return result[item_num][capacity]; } // 当前物品的重量已经超过背包容量，直接返回给子问题 if(items[item_num-1].weight > capacity) { result[item_num][capacity] = knapstack_dp(items, item_num-1, capacity, result, choose); // 打备忘录 choose[item_num - 1] = false; return knapstack_dp(items, item_num-1, capacity, result, choose); // 返回 } // 否则两个子问题中挑出更优的 double with_now = knapstack_dp(items, item_num - 1, capacity - items[item_num-1].weight, result, choose) + items[item_num-1].value; // 装入当前的物品 double without_now = knapstack_dp(items, item_num - 1, capacity, result, choose); // 不装当前的物品 // 二挑一 if(with_now >= without_now) { result[item_num][capacity] = with_now; choose[item_num - 1] = true; }else{ result[item_num][capacity] = without_now; choose[item_num - 1] = false; } return result[item_num][capacity]; } // 初始化备忘录 void init_memoization(vector>& result, int item_num, int capacity) { for (int i = 0; i & items, int capacity, vector>& result, vector& choose) { init_memoization(result, items.size(), capacity); // 初始化表格 for (int i = 1; i = items[i-1].weight && result[i-1][j - items[i-1].weight] + items[i-1].value > result[i-1][j]) { choose[i-1] = true; result[i][j] = result[i-1][j - items[i-1].weight] + items[i-1].value; }else{ choose[i-1] = false; result[i][j] = result[i-1][j]; } } } return result[items.size()][capacity]; } 16.3 Huffman codes 16.3.1 应用背景 定长编码和变长编码效率不同： 16.3.2 Prefix-free Code 无前缀码，解码结果是唯一的。 哈夫曼编码的求解过程： var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH24：Shorest_Path.html":{"url":"算法/CH24：Shorest_Path.html","title":"CH24：Shorest_Path","keywords":"","body":"CH24：Shorest Path MindMap： 24.1 定义 最短路径问题： 最优解：最短路径，怎么走 最优解的值：最短路径的长度 最短路径的权重定义为： 最短路径的权重定义为：\\begin{cases}min(\\{w(p)：\\text{if there is a path p from u to v}\\} \\\\ \\infty\\quad otherwise\\end{cases} 一般使用有向图，无向图视作双向。 最短路径一定满足最优子结构（不可用simple约束） 三角不等式： \\sigma (u,v)\\leq \\sigma(u,x)+\\sigma(x,v) 如果图中包含负权环，那么最短路径可能不存在。 24.2 Single-Source shortest path 单源：源点的位置固定，source固定 每对$\\sigma(u,v)$：每一对结点之间 24.2.1 算法分析 满足最优子结构：一定使用子问题的最优解 二分 k是中间的一个结点，找u->k + k->v，穷举所有的k，挑一个最小的 无法计算：可能存在子问题互相包含。 n推n-1 一样的问题。 计算次序的确定是最短路径的关键。 计算次序是否存在? \\begin{cases}无顺序：人为的增加一个顺序\\\\ 有顺序：尝试，分别做子问题的尝试\\end{cases} 24.2.2 dijkstra算法 （1）思路分析 顺序是否真的不存在？考虑下面的图： 特点：无负权，可能存在计算次序 无负权值的图有特点：越往后走路径只能越长，所以对于从A到其余的点，C离A更近，只可能C是别的问题的子问题，不可能别的问题是C的子问题。于是： 尝试让C当别的问题的子问题 尝试让E当别的问题的子问题 尝试让B充当别的问题的子问题 …… 与前面的DP逻辑的不同： DP：父问题找子问题 现在：子问题找父问题 即dijkstra算法 （2）程序实现 （3）时间复杂度分析 最坏的情况下，每条边都会用来做松弛，时间复杂度为： T(n) = \\Theta(VT_{EXTRACT\\_MIN} +ET_{DECREASE\\_KEY}) Q $T_{EXTRACT_MIN}$ $T_{DECREASE_KEY}$ Total array O(V) O(1) O(v2) Binary Heap O(lgV) O(lgV) O(ElgV) Fibonacci Heap O(lgV) O(1) O(E+VlgV) 24.2.3 其他边权的情况 24.2.3.1 无权图 使用广度优先搜索，堆数据结构换为队列即可。 时间复杂度$Time=O(V+E)$ 24.2.4 Bellman-Ford 如果真的含有负权值边，那么之前的计算次序将不可用，使用Bellman-Ford 其思想在于：若子问题嵌套，那么多使用几次。只要有一条边就拿来尝试更新，但不是只使用一次。 本质：穷举所有的前驱 循环次数：|V|-1 程序实现： 算法实现时，可以为遍历边的次序进行规定。按照次序利用每条边尝试进行松弛。 /*** Bellman-Ford算法 ***/ void Graph::bellman_ford(char s) { int source = s - 'A'; // 源点的下标 vector distance(vexnum, 999999); // 距离数组的初始化 distance[source] = 0; vector pre(vexnum, '@'); int iternum = vexnum - 1; for (int i = 0; i distance[j] + arcList[j][k].weight) { distance[target] = distance[j] + arcList[j][k].weight; pre[target] = j + 'A'; } } } } // 再松弛一次，若有负环则报错 for (int i = 0; i distance[i] + arcList[i][j].weight) { cout 思考，为什么进行n-1轮即可。 一个无负环的图，最短路径的边的最多条数为n-1条，否则会出现环。 不绕环的最短路径，边数最多是n-1 24.3 All-pairs shorest path 所有结点对之间的最短路径： 无负权：跑n遍dijkstra $O(V^2lgV + EVlgV)$ 含负权：跑n遍Bellman-Ford 24.3.1 用边数做约束的DP （1）算法思想 Dynamic Programming 规模变小：边数变少 限制边的数量——n推n-1 定义： d_{ij}^m:从i→j最多过m条边的最短路径 那么有： d_{ij}^0 =\\begin{cases}0&& if \\ i=j\\\\ \\infty&& if\\ i\\neq j\\end{cases} 松弛为： 求 k ---> v的最短路径，过100条边的最短路径，求99条，穷举k d_{ij}^{(m)}=\\min_{k}\\{d_{i,k}^{(m-1)} + a_{k,j}\\} 最终刻画问题为最多过x条边的最短路径。 自上而下：推到m=0时就有答案了。 自下而上：从m=0开始推，m从小到大计算 d_{ij}^0：i到j最多0条边\\rightarrow d_{ij}^1：i到j最多1条边\\rightarrow……d_{ij}^{n-1}：i到j最多n-1条边 无负环，最短路径最多n-1条边。 假设使用迭代的方式： for m = 1~n-1 // 每个m计算一个二维数组 for i = 1~n for j = 1~n for k = 1~n // 所有前驱 需要使用三维数组，逻辑上是一个二维数组 实际的操作没有标m： 计算的过程可能被加速： 无负环： \\sigma(i,j) = d_{ij}^{(n-1)} = d_{ij}^{(n)}=d_{ij}^{(n+1)}…… 故m在工程中可以省略。 负环如何检测？ 再计算一轮未必能检测出来 解决：i=j的场景，检查对角线是否有负值，并将m算到n 将该算法应用到单源点，即为Bellman-Ford算法。 （2）改进：Matrix multiplication 每次使用上一次计算的结果和邻接矩阵计算一个新的矩阵。上述思想的伪代码表示如下： for m = 1 ~ n-1 for i = 1 ~ n for j = 1 ~ n for k = 1 ~ n if d_ij^m >= d_ik^m + a_{k,j} d_ij^m = d_ik^m + a_{k,j} 需要穷举所有的k，所以使用的是结果矩阵的第i行去加上邻接矩阵的第j列。——类似于矩阵相乘的逻辑 C_{ij} = \\min\\{a_{ik}+b_{kj}\\} 24.3.2 用顶点数做约束的DP：Folyed Warshell （1）算法思路 定义： c_{ij}^k表示从i到j最多经过前面k个顶点的最短路径 尝试n推n-1： 过前n个结点 尝试 推给过前n-1个结点，类比0-1背包，那么只有两种情况： c_{ij}^{(k)}\\begin{cases}过第k个顶点：c_{ik}^{(k-1) }+ c_{kj}^{(k-1)}\\\\ 不过第k个顶点：c_{ij}^{(k-1)}\\end{cases} 过0个结点时，$a_{ij}$的权值就是答案 c_{ij}^{(k)} = \\min_k\\{c_{ij}^{(k-1)}, c_{ik}^{(k-1)}+c_{kj}^{(k-1)}\\} 最终过不过第k个结点，比较进行确定。 伪代码： for k = 1 ~ n for i = 1 ~ n for j = 1 ~ n do if cij > cik + ckj // Relaxation then cij = cik + ckj 只用一个数组，和上述的用边约束相同，可能会加速计算，但结果不会出错。 Example： 一个结点都不过：原距离矩阵 过第1个结点 过第2个结点 过第3个结点 （2）负环检测 24.4 Johnson 算法 要是是正权值，那么可以使用dijkstra算法，如何重赋权？ 考虑下面的图，若顶点权值如下，使用$w(u,v)+h(u)-h(v)$得到一个新的权值，为正值： 运行一遍dijkstra，得到的最短路径值做reweighting 选择谁当source 数学性质上任何点都可以成立，但是要用于修改原来的权值 source到每个点的距离不能是无穷大 实际工程上，使用一个不存在的源点source，到任何点的距离为0 使用哪个算法？ Bellman-Ford 算法步骤： Bellman-Ford增加点的情况下跑最短路径值，作为顶点值 重赋权 跑dijkstra var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"算法/CH25：Back-Tracking.html":{"url":"算法/CH25：Back-Tracking.html","title":"CH25：Back-Tracking","keywords":"","body":"CH25：Back-Tracking MindMap： 15.1 Back-Tracking Paradigm 使用场景：无法使用最优子结构 问题特征： 算法使用策略 可以用来解优化问题也可以用来求解可行解 回溯\\begin{cases}寻找可行解\\\\ 寻找最优解\\end{cases} 将问题建模为n元组：$(x_1,x_2,...,x_n)$ 约束条件： \\begin{cases}显式约束：explict变量取值范围\\\\ 隐式约束：inplicit分量与分量之间的关系\\end{cases} 15.2 N-Queens 特征：寻找可行解 15.2.1 问题分析 若采用分治策略： 无法合并，子问题之间并不是相互独立的 n推n-1，仍无法解决子问题不相互独立的问题 求解？ ——暴力穷举【搜索是一种类似于穷举的方式】 每个棋盘8×8个位置不用都尝试，n×n棋盘一定每一行放一个，每一列放一个。 做法： 给行编号，第$i$个棋子放在第$i$行 给列编号，每个棋子做列的选择 候选解即一个8元组：$(x_1,x_2,...,x_8)$，$x_i$是棋子的列号 15.2.2 问题求解 （1）约束条件 显式约束：每个棋子的列号在1~8之间，即$x_i\\in{1,2,3,4,5,6,7,8},1\\leq i\\leq 8$ 隐式约束：棋子不能同行，同列，同斜线，即 x_i\\neq x_j且|x_i-x_j|\\neq |i-j| （2）求解空间树 所有的候选的解：从根到叶子的所有路径 每一个节点：问题解决的目前状态 节点的分类： Alive-Node：孩子节点还未生成完的结点——可能不止一个活结点 E-Node：孩子结点正在生成——只有一个E-结点 Dead-Node：孩子结点已经挑选完，或者人为去除 （3）搜索的DFS和分支限界 DFS 问题的深度优先搜索的过程： DFS：只有当深搜无法向下继续时，才会切换E-节点 分支限界 BFS是分支限界的一种，但分支限界不都是BFS 使用限界函数bound function去认为的标记活结点为死结点，是回溯和暴力搜索的区别。 15.2.3 回溯的一般写法 （1）一般写法 （2）N皇后问题求解 主程序 限界函数 15.3 0-1背包问题 背包类比皇后，背包问题中使用的限界函数为分数背包的思想。 // 回溯法求解背包问题-[迭代] vector knapsack_dfs(int capacity, vector& items, vector& res) { sort(items.begin()+1, items.end(), Item::cmp); int k = 1; int item_num = items.size() - 1; // 去除两个额外的位置 double max_v_w = items[1].v_w; res[0] = 0; // 初始化为0 res[item_num + 1] = 0; vector bestChoice = res; // 初始化什么物品都不装, 下标第一个位置放此时的物品总价值 while (k > 0) { // 回退到第0个物品，不存在第0个物品，终止 res[k] += 1; // 值递增 while (res[k] bestChoice[items.size()]) { bestChoice = res; // 重置最好的值。 } }else{ // 可以继续尝试 k++; res[k] = -1; } } else { // 该结点没有再被尝试的可能，回退 k--; // 做下一步的选择 } } return bestChoice; } 15.4 General Method 15.4.1 Branch & Bound Paradigm （1）D-Search 广搜使用队列 D-Search使用栈 （2）皇后问题使用分支限界 在展开时使用限界函数： 使用队列作为数据结构 分支限界需要把树保留下来。否则变量之间的关系会丢失 （3）分支限界的可优化性 分支限界与回溯的比较 若只找一个解，那么活结点的选择上，无论是回溯还是分支限界，选择活结点的方式过于死板 栈或者是队列都无助于找到answer 使用别的方式：活结点评价函数 利用评价函数选择更好的活结点，结点的代价：cost 以X为树根的树中需要生成多少个结点才能找到answer X离他最近的answer需要切换几次 此时活结点表应该使用堆，这种解法有些事后诸葛亮 （4）LC-Search 对代价进行估计：LC-Search 考虑因素：\\begin{cases}估计代价\\\\根到该结点的深度\\end{cases} g(x)：估计从结点到一个解的代价——引导我们做深度优先搜索 一般孩子结点代价 h(x)：该结点到根的深度 15.5 15-Puzzle 问题空间：16!种可能性 15.5.1 使用DFS或BFS （1）DFS （2）BFS 15迷问题使用回溯是不合适的 15.5.2 LCS 代价定为：有几块没摆好 但要加修正：深度+“估计代价” 未用先验知识： LC-Search的核心：设计c(x) var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件体系结构/about.html":{"url":"软件体系结构/about.html","title":"软件体系结构","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件体系结构/CH1：Introduction.html":{"url":"软件体系结构/CH1：Introduction.html","title":"CH1：Introduction","keywords":"","body":"CH1：Introduction Only one Point：软件体系结构的定义 不存在统一的定义 各个流派对软件体系结构的定义 重点关注： Garlan and Shaw对软件体系结构的定义 超越算法和数据结构的计算； 设计和确定系统的总体结构是一个新的课题。 结构问题包括组织和全局控制结构、通信协议、同步和数据访问、将功能分配给设计元素、物理分布 设计元素的构成 扩展和性能，设计方案的选择 概括为 体系结构 = 组件 + 连接件 + 约束 组件：一组代码，也可以是独立的程序 连接件：组件之间的相互关系，过程调用、管道和消息 约束：组件连接时的条件 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件体系结构/CH2：Achitecture_Style.html":{"url":"软件体系结构/CH2：Achitecture_Style.html","title":"CH2：Achitecture_Style","keywords":"","body":"CH2：Achitecture Style MindMap： 2.1 架构风格的定义 不存在统一的定义： 架构风格 Achitecture Style = 一组组件类型 component type / 连接件类型 connector type（交互机制） 组件的拓扑分布 一组对拓扑和行为的约束 一些对风格的代价和益处的非正式描述 如何描述的？重点要看 分类法： 纯粹的体系结构在现实中很难遇到，实际上的系统通常： 经常偏离学术定义 典型的，融合很多的体系风格的特色 作为一个架构师，必须理解“纯”的风格，理解优点和缺点，理解背离这种风格会带来什么结果 没有完备的列表 风格彼此是重叠的 一个系统通常表现出来多种风格 2.2 Data Flow 2.2.1 数据流风格概述 （1）风格 数据流系统： 数据控制计算 the availability of data controls the computation 系统结构由数据在处理之间的有序移动决定 the structure of the design is dominated by orderly motion of data from process to process 数据流系统的结构是显而易见的 纯数据流系统中，处理之间除了数据交换，没有其他的别的交互，变化的是： 如何施加控制——数据的控制方式 pull 拉 消费者角度 push 推 从数据源角度 并行的程度 一条数据流，多条数据流 topology 顺序，循环 （2）Component & Connector & System Component 组件接口是输入端口和输出端口 Interfaces are input ports and output ports Connector：Data Stream 通常是异步的，有缓冲。同步的容易阻塞 System 任意拓扑结构，函数式编程 （3）数据流和控制流 控制流 主要问题是控制点control怎么在程序或者系统之间移动 数据可能跟着控制走，但是并不起到推动系统运转的作用 关注的核心是计算顺序 eg：冯诺依曼结构 数据流 主要问题是数据怎么在运算单元之间流动 数据到了，计算单元便工作 我们关心数据是否可用，转换，延迟 2.2.2 Three Examples of Data Flow 2.2.2.1 Batch Sequential 批处理 （1）图 每一个处理步骤是一个独立的程序，每一步在上一步结束后才能开始，数据必须是完整的，以整体的方式传送。 （2）应用 典型应用： 编译器 case工具 2.2.2.2 Pipe-and-Filter 管道过滤器 （1）图 （2）管道与过滤器 fliter 功能：将数据流作为输入，经过处理后输出 进行流到流的转换： \\begin{cases}丰富数据\\\\精炼数据\\\\转换数据\\end{cases} 数据不再是自包含的 fliter是无状态的计算。没有上下文，状态保存等。 pipe 将数据流从一个过滤器传递到另一个过滤器 数据传送引起动作 （3）优点 隐蔽性，高内聚，低耦合 可支持并发，多个过滤器并发执行 系统容易维护和扩展 （4）缺点 不适合交互性很强的应用——计算过程事先确定 数据传输没有通用标准，每个过滤器需要额外解析和合成数据 （5）数据流与管道过滤器的区别 2.2.2.3 Proccess Control 控制 开环控制 Open loop Control 闭环控制Close Loop Process Control 闭环控制有两种形式：反馈控制和前馈控制 当软件系统的运行受到外部干扰时，需要为软件体系结构考虑一种过程控制范例 2.2.3 选择数据流方式的方针 任务由数据主导 事先知道数据的流向 数据流动带来性能损坏 2.3 Call/Return 2.3.1 风格类型 经典的例子： 主程序和子程序 main program and subroutines 经典编程范式：函数分解 面向对象的抽象数据类型 信息的隐藏 层次化结构 每一层只和他的近邻通信 其他 客户机-服务器 2.3.2 历史过程 主程序（子程序）\\rightarrow 函数模块\\rightarrow ADT\\rightarrow Object\\rightarrow OO架构\\rightarrow Component 2.3.3 Call/Return的具体风格类型 2.3.3.1 Main Program and Subroutine （1）示意图 Problem：适用于通过过程定义层次结构适当定义计算的应用程序 Context：命名空间局部性 Solution： 系统模型：调用和定义层次结构，子系统通常模块化定义 组件：过程和显式可见数据 所有数据对外完全可见 连接器：过程调用和显式数据共享 控制结构：单线程 （2）Pipe Versus Procedures 2.3.3.2 Data Abstaction or Object-Oriented 系统模型：局部化状态保持 组件：对象 连接件：过程调用 控制结构：去中心化，通常是单线程 （1）模块分解 隐藏细节： 数据+策略 隐藏可能改变的细节，接口中公开不太可能改变的假设 （2）封装和信息隐藏 对象有状态和操作，但是也有完整性。 对象被外界知道的是他的接口 对象从模板产生 （3）示意图 对象架构的元素： \\begin{cases}封装：限制信息的访问\\\\交互：过程调用或其他协议\\\\多态：运行时选择具体的操作\\\\继承：对共享的功能保持一致的接口\\\\复用和维护：封装和聚合提高生产力\\end{cases} （4）优缺点 管理大量的对象 对象的海洋需要额外结构容纳 管理很多交互 单一的接口能力有限且笨拙（友元） 分散的行为责任 系统的功能难以理解 捕获关联的设计 类和类型通常是不够的，设计模式是发展 2.3.3.3 Layered system （1）OSI模型的例子 （2）概述 适用问题 包含可以按层次结构安排的不同服务类别 系统模型 不透明的层次结构 构件 各层次内部的构件，过程的集合 连接件 取决于组件的结构;在受限的可见性下，过程调用通常也可能是客户机/服务器 限制 控制结构 单线程 （3）层次风格的特点 每一层为上一层提供服务，使用下一层的服务，只能见到与自己相邻的层 大问题逐渐分解成为若干个渐进的小问题，逐步解决，隐藏了很多复杂度 修改一层，最多影响两层，而通常影响上层，接口稳固，则对谁都不影响 上层必须知道下层的身份，不能调整层次之间的顺序 层层相调，影响性能 2.3.3.4 Client/Server 分类： \\begin{cases}两层CS结构\\\\三层CS结构\\\\BS结构\\end{cases} （1）两层CS 客户机应用程序、数据库服务器、网络 特点：瘦服务器，胖客户机 缺点： 客户端对硬件软件配置要求高，客户机臃肿 升级维护较为困难 数据不安全，客户端可以直接访问服务器数据 信息内容和形式单一 客户端程序编写困难 （2）三层CS 客户机、数据库服务器、应用服务器、网络 特点：瘦客户机 应用功能划分：功能层、表示层、数据层 （3）BS架构 三层CS的特例 客户端使用http浏览器即可，使用http协议，省去了很多麻烦 只能拉，不能推 客户端之间的通信只能通过服务器进行中转 对客户机和其他网络资源的利用受限 客户端资源浪费，服务器压力较大 BS的速度相对于CS慢 2.4 Data Center / Data Sharing 2.4.1 Shared Information System 以数据为中心的体系结构风格概述 2.4.1.1 组件和风格特征 这种风格描述了很多系统，共同特点是共享数据 收集、操作、保存大量的数据 定义：以数据为中心的风格架构涉及到一种共享数据源方法来传递信息。 example： 剪切板 注册表 数据库 优点 系统耦合程度低 方便添加/删除/生产/消费/操纵数据 单个生产者的错误无影响 问题 同步问题——数据发生改变时，控制反转，数据仓库压力大 配置和管理 ACID特性 2.4.1.2 应用场合 早期的数据共享出现在批处理系统 迫切需要数据时即时存取 如今： 应用在各个场景，比如web就是一个巨大的分布式数据库 GitHub 2.4.2 Repository Architecture 2.4.2.1 概述 仓库是共享和维护信息中心的场所 组件： 中心数据结构，表示当前的数据状态 一组对中心数据结构进行操作的独立组件 连接件： 计算单元与中心数据结构之间通过之间数据访问或者过程调用的交互 控制结构： 典型应用场合： 数据库 如，编译器的符号表： 2.4.3 BlackBorad Repository 2.4.3.1 概述 问题： 问题特征： 多种方法可以解决问题，找不到确定的解决思路 求解的每个步骤都有可能产生多个可能的解，寻求最佳或者可接受的解。 需要多个领域的专门知识协作解决 eg： 自然语言处理 语音处理 模式识别 图像处理 如何求解此类问题？——黑板体系结构 一个大问题被分解成若干的子问题 每个子问题的解决需要不同的问题表达方式和求解模型，分别设计求解程序 2.4.3.2 黑板模型 知识元：问题分解成几个部分，每个部分独立计算——知识元对黑板进行修改，逐步找到问题的解 黑板数据结构：全局数据库包含解域的全部状态 控制：完全由黑板的状态驱动，黑板的状态的改变决定使用的特定知识 让知识元响应偶然事件 （1）知识源 目标： 提供解决问题的知识，分别存放且相互独立 动作： 只修改黑板，知识源之间的通讯交互只通过黑板进行 负责： 知道什么时候能发挥作用：“条件-动作”形式 （2）中心数据结构 目标： 保存知识源所需要的数据，保存来自解空间的数据 组织： 解决问题中的状态数据，以层次的形式组织起来 各个知识源只通过黑板进行交互 （3）控制 Control 时刻监控黑板的状态，对黑板上的当前信息进行判断和评价 满足知识源执行条件时，知识源被控制器触发，并进行计算，结果写在黑板上 这种更新又导致其他的知识源参与计算，直到找到问题的解为止 目标： 让知识源响应偶然事件，了解各个知识源的能力，决策解决问题的步骤 2.4.3.3 应用 信号处理、模式处理、模式识别 人工智能 2.5 Virtual Machine Interpreters：模拟不是硬件固有的功能 Rule-Based System：解释器的特例 2.5.1 Interpreter （1）应用问题 应用问题：应用的最佳的执行环境或者语言不能够得到直接的支持。 引入中间层\\begin{cases}应用不能直接支持\\\\环境不适合\\\\跨平台\\end{cases} 无法直接使用最合适的语言或者机器来执行解决方案 核心问题是定义解决方案的符号的应用程序，如脚本 有时以链的形式使用，在一系列阶段的过程中从需要的语言/机器翻译 上下文： 桥接需要的机器和语言与执行环境已经支持的机器（虚拟的）和语言 Solution： 系统模型：一个虚拟机 组件：一个状态机和三个存储 \\begin{cases}状态机：执行的引擎\\\\ 三个存储：\\begin{cases}执行引擎的当前状态\\\\被解释的程序\\\\被解释的程序目前所处的状态\\end{cases}\\end{cases} 连接件：数据访问和过程调用 控制结构：通过引擎状态转移，输入确定选择翻译什么 （2）优缺点 优点 功能性 functionality ：可以模拟非本机功能 测试性 testing ：可以模拟灾难模式（安全攸关的应用） 灵活性 flexibility ：非常通用的工具 缺点 效率：比硬件慢，慢两个数量级；比编译器慢 测试：需要测试额外的中间层 （3）解释器的应用 解释型语言 VB, JS, HTML, Java字节码 通信协议 用户输入 2.5.2 规则系统 （1）问题 根据当前的状态，基于事实，判断我需要的输出 知识库：要被执行的代码 规则引擎：翻译引擎 规则/数据选择：解释器的状态 工作存储：当前代码的状态 （2）理解 对于一个架构，可以从不同的架构去理解 eg：hearsay 2.6 Independent Component 2.6.1 进程间通信 2.6.1.1 背景概述 分布式环境，出现多进程多线程，节点之间相互独立。 已经广泛应用的： 操作系统 分布式应用 2.6.1.2 进程间通信 （1）应用问题 包含一系列不同的，在很大程度上独立的计算的应用程序，这些计算的执行应该独立进行。 计算涉及数据的协调或者对离散的时间点的控制。因此，系统的正确性需要注意消息的路由和同步。 eg：网络游戏的例子 （2）背景 通信策略的选择通常由可用操作系统提供的通信支持决定。 （3）解决方案solution 系统模型：独立交流的进程 组件：向明确接收方发送和接收消息的进程 连接件：离散的消息==（没有共享数据 important）== 控制结构：每个线程都有自己的线程控制 （4）重要变化 确保消息一定收到。 （5）设计需要考虑的问题 图的拓扑结构、失败模型、性能 2.7 事件系统 2.7.1 隐式调用和显式调用 显式调用：明确知道消息的接收者 隐式调用：中间层调用 2.7.1.1 隐式调用 implicit invocation （1）问题 适用于： 松耦合的组件集合应用程序，每个组件执行某些操作，并可能在流程中启用其他操作，通常是响应式系统。 对于必须动态进行，可重新配置的应用程序，该模式是有用的。 上下文： 需要事件处理程序，接收对事件的兴趣，并且在事件引发时通知组件。注册行为 （2）特点 构件不直接调用一个过程，而是触发广播或者多个事件 不能假定构件的处理顺序，甚至不知道哪些构件会被调用 各构件之间彼此无连接关系，相互独立存在 （3）解决方案 solution 系统模型：独立交互式进程 组件：在不知道接收方的情况下发送接收消息的进程 连接件：自动调用已对事件感兴趣的进程 控制：分散，单个组件不知道消息的接收方 （4）应用 Debugger-编辑器和变量监视器登记Debugger断点事件 在编程环境中集成各种工具 数据库管理系统中确保数据的一致性 用户管理界面系统中管理数据 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件体系结构/CH3：UML.html":{"url":"软件体系结构/CH3：UML.html","title":"CH3：UML","keywords":"","body":"CH3：软件体系结构建模和文档化 1.UML 1.1 Use Case 用例图：理解系统功能需求的宝贵工具 用于显示若干的角色与系统提供用例之间的关系，用例是系统的功能 是系统的外部视图，没有与系统内部的类的交互 1.2 Class Diagram 类图：表示类class和类class之间的联系，对系统静态结构的描述 1.3 Object Diagram 对象图：是系统在某一个时间点的对象的快照，表示的是实例instance而不是类，所以也叫Instance diagram 对象图展示对象之间的连接关系，显示连接在一起的对象的示例 1.4 Package Diagram 包图表示的是更高层次的单元： 使用包图可以将相关元素纳入一个系统 1.5 Sequence Diagram 多个对象之间随着时间推移的交互关系 序列图便于展示对象之间的协作。 如果想要看一个use case中的多个对象的行为，那么使用序列图 如果想看一个对象在多个use case中的行为，那么使用状态图 如果想看多个对象在多个线程中的行为，那么使用活动图。 1.6 Communication Diagram ==协作图（通信图）==：描述对象之间的动态协作 协作图（通信图）是一种交互图，强调的是发送和接收消息的对象之间的组织结构。一 个协作图显示了一系列的对象及对象之间的联系以及对象间发送和接收的消息。 强调时间：序列图 强调上下级关系：协作图 交互图\\begin{cases}协作图、通信图：强调上下级关系\\\\序列图：强调时间推移\\end{cases} 1.7 State Diagram 描述类的对象所有可能的状态以及事件发生时的状态的转移条件。通常状态图是对类图的补充。 1.8 Activity Diagram 满足用例要求所要进行的活动以及活动间的约束关系 重点：支持并行行为parallel 1.9 Component Diagram 组件图：描述代码构件的物理结构和各个构件之间的依赖关系 1.10 Deployment Diagram 软硬件的物理结构，硬件节点，软件视图。 1.11 Composite Structures 复合结构：分层地将类分解为内部结构 1.12 Interaction Diagram 交互概述图：活动图和序列图的结合 1.13 Timing Diagram 时序图：交互图的另一种形式，一般针对一个或者多个对象描述。 2. “4+1”视图 逻辑视图：支持行为要求。关键抽象，对象或者对象类 类图 对象图 状态图 协作图 过程视图：解决并发和分发 活动图 开发视图：组织软件 包图 组件图 物理视图：其他元素映射到处理和通信结点 部署图 用例视图（场景）：其他视图映射到重点的用例，帮助用户理解系统功能 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件体系结构/CH4：理解质量属性.html":{"url":"软件体系结构/CH4：理解质量属性.html","title":"CH4：理解质量属性","keywords":"","body":"CH4：理解质量属性 1.质量属性场景的概念 质量属性场景： 源 刺激物 制品 环境 响应 响应衡量 2.六大质量属性 2.1 可用性 Availability 故障，相关后果 定义：在需要是可用的概率，停机不算 α的定义 \\alpha = \\frac{平均无故障时间}{平均无故障时间 + 故障修复时间} failure的特性：可感知的，未达到声称级别的功能即为错误。 可用性的质量属性场景： 源：系统内部或者外部故障迹象 刺激物：系统崩溃，系统错误，给出结果不准时，错误结果 制品：系统处理器，通信信道，存储，进程 环境：正常、亚健康 响应：记录错误日志，传回；通知管理员或者其他系统；关闭系统 响应测量：平均无故障时间，修复时间，故障时间百分比，可用时间百分比 2.2 可修改性 Modifiablity 关注：改什么，谁改，什么时候改，改的代价 质量属性场景 源：谁去修改（开发者，系统管理员，用户） 刺激物：要进行的具体修改 制品：要修改哪一部分的内容：修改系统的功能 or UI 或者其他部分 环境：在什么时间进行修改，设计or开发or运行时间 响应：操作员怎么理解修改，部署，运行 度量：改的时间和成本 2.3 性能 Performance 主要是系统响应事件的花费时间，事件数量，到来形式 质量属性场景 源：可能来自系统外部（可能多个）也可能来自系统内部 刺激物：事件的到达，到达的形式（周期性，随机，偶发） 制品：系统提供的服务 环境：系统处于不同的环境——正常，紧急，超载 响应：==系统必须处理到来的事件，可能导致系统的环境的变化== 响应度量： 处理事件花费的时间 单位时间内处理事件的数量 出错的错误率，丢失率 2.4 安全性 保证正常用户，阻挡非法攻击 安全性的不同类型 不可抵赖性 机密性 完整性 保证性 审计 ==可用性== 质量属性场景 源：攻击可能由人或者其他系统发起；可能先前被识别，或者当前未知。 刺激物 ==对系统的攻击（或者试图破坏系统安全保护）==，常见的形式： 数据 超过权限的服务 影响可用性 制品：系统所提供的服务或系统中的数据 环境：系统可能处于不同的情况下——联网/未联网，在线/下线，在防火墙外/在防火墙内 响应： 合法用户正常使用，拒绝非法用户的使用 对攻击有威慑 度量 发起攻击的难度 从攻击中恢复的难度 2.5 可测试性 软件测试为了发现bug 测试的重要性 测试的质量属性场景 源：测试可能由不同的角色发起（开发者、单元测试人员、集成测试人员、系统管理员、用户……） 刺激物：里程碑 制品：程序，设计，系统 环境：设计阶段、开发阶段、编译时，部署阶段、正常运行时 响应 理想的响应是可以进行测试，并且可以==观察到==测试结果 当测试结果无法被观察到时，测试难度很大 响应的衡量标准 白盒测试的覆盖率 未来继续发现Bug的概率 ==最长测试链的长度== 2.6 易用性 用户希望完成任务有多容易 质量属性场景 源：终端用户 刺激物： 终端用户希望学会使用，提高效率，减少错误 制品：整个系统 环境：运行时或者部署时 响应： 系统响应用户的需求 响应度量 用户完成任务的时间 用户出错的概率 用户满意程度 用户操作的成功率 3.从架构上设计质量属性的策略 3.1 可用性 \\begin{cases}错误检测\\begin{cases}ping/echo\\\\Heartbeats：被监控组件向监控组件发出周期性信号\\\\异常\\end{cases} \\\\错误恢复\\begin{cases}投票机制\\\\主动冗余\\\\被动冗余\\\\内测\\\\检查点/回滚\\end{cases}\\\\错误避免\\begin{cases}事务\\\\关闭服务\\\\进程监控\\end{cases}\\end{cases} 3.2 可修改性 \\begin{cases}局部化修改\\begin{cases}保持语义的高内聚性\\\\考虑未来可能会发生的改变\\\\模块泛化\\\\选项变少\\\\抽象公共服务\\end{cases}\\\\避免连锁反应\\begin{cases}保持已有的接口\\\\使用中间层\\\\信息隐藏\\end{cases}\\\\延迟绑定时间\\begin{cases}运行时注册\\\\配置文件\\\\多态\\end{cases}\\end{cases} 3.3 性能 \\begin{cases}资源需求\\begin{cases}提升计算能力\\\\减少处理的数据数量\\\\管理事件达到的频率\\\\限制采样率\\end{cases}\\\\资源管理\\begin{cases}长任务设置上限执行时间\\\\限制事务队列的长度\\\\利用并发机制\\end{cases}\\\\资源仲裁：使用调度策略\\begin{cases}FIFO\\\\固定优先级\\\\动态优先级\\end{cases}\\end{cases} 3.4 安全性 \\begin{cases}抵御攻击\\begin{cases}用户认证\\\\用户授权\\\\保证数据的机密性\\\\保证数据的完整性\\\\限制访问：防火墙\\end{cases}\\\\攻击检测：入侵检测系统\\\\攻击恢复\\begin{cases}数据备份\\\\攻击者识别\\end{cases}\\end{cases} 3.5 可测试性 \\begin{cases}管理输入输出\\begin{cases}记录/回放，重演\\\\ 接口和实现分离\\end{cases}\\\\ 内部检测：内部监控器\\begin{cases}IDE断点\\end{cases}\\end{cases} 3.6 易用性 \\begin{cases}运行时策略\\begin{cases}保证用户模型\\\\保证系统模型\\\\保证任务模型\\end{cases}\\\\设计时策略\\begin{cases}UI界面与其他分离：MVC\\end{cases}\\\\具体：\\begin{cases}系统给与用户适当反馈\\\\系统猜测用户要完成的任务\\\\系统支持撤销\\\\系统给用户提供一致性体验\\\\用户接口分离\\end{cases}\\end{cases} var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件过程与项目管理/about.html":{"url":"软件过程与项目管理/about.html","title":"软件过程与项目管理","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件过程与项目管理/PART1-判断题错误总结.html":{"url":"软件过程与项目管理/PART1-判断题错误总结.html","title":"PART1-判断题错误总结","keywords":"","body":"PART1-判断题错误总结 4.triple contraints ：【scope】【time】【cost】 记住，填空也要答 7.Project managers work with the project sponsors to define success for particular projects. （T） 8.Individual projects always address strategic goals whereas portfolio management addresses tactical goals. （F） 13.The last phase of the traditional project life cycle is the implementation phase。 （F） 18.The level of activity and length of each process group varies for every project （T） 21.Monitoring and controlling processes overlap all of the other project management process groups. （T） 22.Many project management activities occur as part of the planning process group. （T） 24.The Rational Unified Process (RUP) framework is incompatible with the PMBOK process. (F) 25.The kick-off meeting is always held before the business case and project charter are completed. （F） 26.A milestone list is an output associated with the Project Scope Management knowledge area. (F) 28.The burndown chart is a Scrum created artifact that provides a list of features prioritized by business value. （F） 37.Project scope management includes the processes involved in defining and controlling what is or ​ is not included in a project （T） 40.Project scope statements must include the project boundaries, constraints, and assumptions. （F） 44.The scope baseline includes the approved project scope statement and its associated WBS and WBS dictionary （T） 45.The main purpose of the WBS is to define all of the work required to complete a project. （T） 46.A work package represents one component of the product that the project aims to deliver (F) 47.The tasks in a WBS must be developed as a sequential list of steps (F) A unit of work should appear at only one place in the WBS (T) 51.In project schedule management, the primary output of defining activities is a schedule management plan (F) 55.Network diagrams are the preferred technique for showing activity sequencing (T) 56.Start-to-finish relationships are the most frequently used dependencies between activities. (F) 57.In a critical path analysis, the shortest path is what drives the completion date for the project. (F) 58.A backward pass through the network diagram determines the early start and early finish dates for each activity (F) 59.The technique of fast tracking can result in lengthening the project schedule (T) 60.Critical chain scheduling assumes that resources multitask and maximizes multitasking. (F) 61.Overrun is the additional percentage amount by which estimates exceed actual costs. (F) 63.Contingency reserves are also known as unknown unknown （F） 67.The formulas for variances and indexes start with EV, the earn value （T） 68.Project stakeholder management has only been identified as an entire knowledge area by the Project Management Institute since 2013. (T) 75.Unknown risks can be managed proactively （F） 76.Risk events refer to specific, certain events that may occur to the detriment or enhancement of (F) 78.Top Ten Risk Item Tracking is a quantitative risk analysis tool. (F) ​ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件过程与项目管理/PART2-选择题答案整理.html":{"url":"软件过程与项目管理/PART2-选择题答案整理.html","title":"PART2-选择题答案整理","keywords":"","body":"PART2-选择题答案整理 1.易错题 What important Scrum artifact is used to graphically display progress on each sprint during the monitoring and controlling process? a. WBS b. sprint backlog c. burndown chart d. product backlog Answer C What is developed in the Project Integration Management knowledge area? a. schedule management plan b. project management plan c. WBS d. quality management 初始阶段：计划 Which activity is a part of the Scrum planning process? a. Determining how many sprints will compose each release b. Demonstrating the product during a sprint review meeting c. Completing tasks each day during sprints d. Creating sprint backlog The __ is responsible for maximizing return on investment (ROI) by identifying product features, translating these into a prioritized feature list, deciding which should be at the top of the list for the next Sprint, and continually re-prioritizing and refining the list. A) Scrum Master B) Product Owner C) Manager D) Team ANSWER: B Which information is included in a business case业务用例? ​ a. business need for the project ​ b. relevant government or industry standards ​ c. project objective, high-level requirements, and time and cost goals ​ 项目目标、高层次需求、时间和成本目标 ​ d. policies, procedures, guidelines, and systems that influence a project’s success What is the first step in the planning process? A ​ a. tie the information technology strategic plan to the organization’s overall strategic plan ​ b. perform a business area analysis ​ c. start defining potential IT projects in terms of their scope, benefits, and constraints ​ d. choose which projects to do and assigning resources to work on them ANSWER: a Which process includes defining project scope, benefits, and constraints? A ​ a. project planning b. business area analysis ​ c. resource allocation d. information technology strategy planning ANSWER: a Which process involves working with stakeholders to create the document that formally authorizes a project? ​ a. Developing the project charter[项目章程] ​ b. Developing the preliminary project scope statement ​ c. Developing the project management plan ​ d. Performing integrated change control Which technique is used for making cost and schedule trade-offs to obtain the greatest amount of schedule compression for the least incremental cost? ​ a. dependency b. crashing[崩溃！] ​ c. critical chain scheduling d. feeding buffers What term is used for the amount of time an activity can be delayed from its early start without delaying the planned project finish date【不延迟结束时间】? ​ a. total slack b. free float ​ c. backward pass d. forward pass ANSWER: a What term is used for the amount of time an activity can be delayed without delaying the early start date of any immediately following activities【不延迟开始时间】? ​ a. forward pass b. backward pass ​ c. fast tracking d. free slack ANSWER: d Which method is used for determining the estimated annual costs [年度成本]and benefits[和收益] for a project? ​ a. Critical path analysis b. Cash flow analysis 现金流分析 ​ c. Present value analysis d. Requirements analysis ANSWER: b Scope, time and cost goals in order of importance can be ranked on an expectations managementmatrix_. ​ a. requirements traceability matrix b. expectations management matrix ​ c. responsibility assignment matrix d. probability matrix Which process involves numerically estimating the effects of risks on project objectives? ​ a. performing qualitative risk analysis b. planning risk responses ​ c. identifying risks d. performing quantitative risk analysis 2.全部题目 During which phase must project teams address important considerations for managing information (and often end up updating business processes through improved communications)? 在哪个阶段，项目团队必须处理管理信息的重要考虑事项(并且经常通过改进的通信来更新业务流程)? b. execution An example of push communication is _. c. voice mails An example of pull communication is _. d. blogs Which document addresses where the project stands in terms of meeting scope, time, and cost goals? b. status reports Which process involves numerically estimating the effects of risks on project objectives? 哪个过程涉及到用数字估计风险对项目目标的影响? d. performing quantitative risk analysis _ are predefined actions that the project team will take if an identified risk event occurs. c. Contingency plans[应急计划] Which is a fact-finding technique that can be used for collecting information in face-to-face, phone, e-mail, or instant-messaging discussions? interviewing d. interviewing Which document contains results of various risk management processes; it is often displayed in a table or spreadsheet format? a. risk register The _ lists the relative probability of a risk occurring and the relative impact of the risk occurring. ​ c. probability/impact matrix Which diagramming technique is used to help select the best course of action in situations in which future outcomes are uncertain? a. decision tree Which action involves eliminating【消除】 a specific threat, usually by eliminating its causes【原因】? 哪个行动涉及消除特定的威胁，通常是通过消除其原因? ​ a. risk avoidance _ are unplanned responses to risk events used when project teams do not have contingency plans in place. ​ a. Workarounds In project procurement management, which is an output of the planning process? d. make-or-buy decisions A(n) _ is a document used to solicit proposals from prospective suppliers. _是一份用来向潜在供应商征求建议的文件。 c. RFP A document used to solicit quotes or bids from prospective suppliers is known as a(n) _. 用于从潜在供应商征求报价或投标的文件称为 _。 a. RFQ After planning for procurement management, the next process involves __. d. sending appropriate documentation to potential sellers What process involves determining everyone involved in the project or affected by it, and determining the best ways to manage relationships with them? ​ a. identifying stakeholders The main output of which process is the stakeholder register? b. identifying stakeholders Which is true about identifying stakeholders? a. External project stakeholders include the project’s customers. The project team must take corrective action if stakeholders with _ are categorized as resistant or unaware. b. high interest and high power Scope, time and cost goals in order of importance can be ranked on an ___. b. expectations management matrix A(n) _ is a tool used to document, monitor, and track problems that need resolution. d. issue log Which process involves allocating the overall cost estimate to individual work items to establish a baseline for measuring performance? 哪个过程涉及到将总体成本估计分配到单个工作项，以建立测量性能的基线? a. determining the budget Which process results in a cost baseline as a main output? c. cost budgeting Budget - - Base line for measuring performance or cost base line Which process helps develop an accurate projection of a project’s financial expenses and benefits? ​ c. life cycle costing Which method is used for determining the estimated annual costs [年度成本]and benefits[和收益] for a project? b. Cash flow analysis Which statement is true of contingency reserves? a. They allow for future situations that can be partially planned for. Which is most likely to be a reason for inaccuracies in information technology cost estimates? ​ b. People lack estimating experience. What is another term used for budget? d. planned value Which is true of earned value? ​ c. It is an estimate of the value of the physical work actually completed. During which relationship is the “from” activity unable start until the “to” activity is started? ​ a. start-to-start After working with key stakeholders to define activities and calculate their resources, what is the next process in project schedule management? d. estimate the duration of activities. Which provide a standard format for displaying project schedule information by listing project activities and their corresponding start and finish dates in a calendar format? ​ a. Gantt charts Which technique involves network diagramming[网络图] and is used primarily to predict total project duration? b. critical path analysis The critical path is the _ path through a network diagram, and it represents the _ amount of slack or float. b. longest; shortest What term is used for the amount of time an activity can be delayed without delaying the early start date of any immediately following activities【不延迟开始时间】? d. free slack What term is used for the amount of time an activity can be delayed from its early start without delaying the planned project finish date【不延迟结束时间】? ​ a. total slack Which technique involves doing activities in parallel that one would normally do in sequence? ​ c. Fast tracking Which technique is used for making cost and schedule trade-offs to obtain the greatest amount of schedule compression for the least incremental cost? b. crashing How does critical chain scheduling protect tasks on the critical chain from being delayed? b. feeding buffers Which law states that work expands to fill the time allowed? ​ c. Parkinson’s Law Which is a similarity between scope control and schedule control? ​ c. Both are portions【部分】 of the integrated change control process under project integration management. Which term describes a product produced as part of a project? ​ c. deliverable Which statement best describes scope? d. work involved in creating the products and the processes used to create them Which task is at the lowest level of the WBS? d. work package Which is recommended for the creation of a good WBS? ​ b. A unit of work should appear at only one place in the WBS. Which process involves working with stakeholders to create the document that formally authorizes a project? ​ a. Developing the project charter What is the first step in the planning process? a. tie the information technology strategic plan to the organization’s overall strategic plan Which process includes defining project scope, benefits, and constraints? ​ a. project planning What type of analysis involves calculating the expected net【净赚】 monetary gain or loss from a project by discounting all expected future cash inflows and outflows to the present point in time? b. Net present value In a weighted scoring model, what percent must the sum of the weights of all the criteria total? ​ c. 100 Which information is included in a business case业务用例? ​ c. project objective, high-level requirements, and time and cost goals Which section of the project management plan provides the planned cost of deliverables? b. budget The scrum approach originated with agile software development as practitioners looked for ways to .............. A) improve communication B) increase throughput Although Scrum was intended for management of software development projects, it can be used to run software maintenance teams, or as a general project/program management approach. A) True The main roles in Scrum are: A) ScrumMaster B) Product Owner C) Team Scrum eliminates many of the tasks required of a lead because teams become self-organizing. A) True In scrum the team activity is monitored and coordinated on ......... basis. B) daily Scrum is iterative. The iteration is called _ C) sprint The ................. is responsible for maximizing return on investment (ROI) by identifying product features, translating these into a prioritized feature list, deciding which should be at the top of the list for the next Sprint, and continually re-prioritizing and refining the list. B) Product Owner The team in Scrum is seven plus or minus two people. A) True The ScrumMaster and the Product Owner can be the same individual; B) False The first step in Scrum is for the Product Owner to articulate the product vision. Eventually, this evolves into a refined and prioritized list of features called the .......... C) Product Backlog The team meets daily for ...... minutes, where each member of the team discusses the work they’ve completed since the last meeting 15 12)................. are of scrum principles. A) Time-boxes B) Cross-functional teams C) Open communications within team. D) All of above Users & Stakeholders in scrum are Interested in results but not responsible for deliverables. False The organization recognizes that a new project exists and completes a project charter during which processes for a new project? a. initiating What is developed in the Project Integration Management knowledge area? b. project management plan What is the main purpose of project plans? d. guide project execution Which process includes measuring progress toward project objectives and taking corrective action to match progress with the plan? b. Monitoring and controlling Which is true about the agile method? c. It uses several iterations or deliveries of software instead of waiting until the end of the project to provide a product. Which project would be compatible with the use of the agile approach? d. Projects that have more flexible scheduling Which activity is a part of the Scrum planning process? d. Creating sprint backlog In the Scrum method, during which meeting is the improvement of the product and process discussed? a. sprint retrospective A _ is usually not necessary to the Scrum method, because Scrum implies that team members work as a self-directed group【不需要team charter】. a. team charter【团队宪章】 What important Scrum artifact is used to graphically display progress on each sprint during the monitoring and controlling process? c. burndown chart In what type of organizational structure do project managers have the most authority? b. Project In which product life cycle the scope, schedule, and cost are determined early, and changes to scope are carefully managed? C ​ c. Predictive In which development life cycle do stakeholders define and approve the detailed scope before the start on an iteration? ​ a. Adaptive Which observation is true of the agile approach to software development? ​ a. In the agile method, requirements and solutions evolve through collaboration. Which objective is true of projects? ​ b. They have a unique purpose. The role of a _ is to provide direction and funding for a project. ​ a. project sponsor Which knowledge area involves defining and managing all the work【要做什么提前准备好】 required to complete the project successfully? b. Project scope management Which project management knowledge area ensures that the project will satisfy the stated or implied needs for which it was undertaken? d. Project quality management Project procurement management mainly involves: b. buying goods and services for a project from outside the performing organization. An important tool for project scope management is _. d. a work breakdown structure Fast tracking is an example of a tool used in _ management. ​ a. schedule Which organization provides certification as a Project Management Professional? ​ c. PMI var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件过程与项目管理/PART3-填空题.html":{"url":"软件过程与项目管理/PART3-填空题.html","title":"PART3-填空题","keywords":"","body":"PART3-填空题易错整理 Agile software development can be used for software development or in any environment in which the requirements are unknown or change quickly. Agile，没有method Sprint planning is part of the basic Scrum framework___ project management process groups_ progress from initiation activities to planning activities, executing activities, monitoring and controlling activities, and closing activities. The ideal outcome of the monitoring and controlling_ process group is to complete a project successfully by delivering the agreed-upon project scope within time, cost, and quality constraints. A(n) _product owner is the person responsible for the business value of the project and for deciding what work to do and in what order when using a Scrum method. A(n) _scrum master is the person who ensures that the team is productive, facilitates the daily Scrum, enables close cooperation across all roles and functions, and removes barriers that prevent the team from being effective. A(n) scrum team development team_ is a cross-functional team of five to nine people who organize themselves and the work to produce the desired results for each sprint. If done well, the Agile approach_ can produce several releases of useful software. _Strategic planning involves determining long-term objectives by analyzing the strengths and weaknesses, studying opportunities and threats, predicting future trends, and projecting the need for new products and services. A(n) _weighted scoring model is a tool that provides a systematic process for selecting projects based on many criteria. A(n) _change control board is a formal group of people responsible for approving or rejecting changes to a project. A(n) rough order of man estimate is done very early in a project or even before a project is officially started. Function Ponits__ are a means of measuring software size based on what the software does for end users. A(n) _cost-baseline_ is a time-phased budget that project managers use to measure and monitor cost performance. _EVM_ is a project performance measurement technique that integrates scope, time, and cost data. The EV_ is the measure of work performed expressed in terms of the budget authorized for that work. artifacts var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"软件过程与项目管理/PART4-简答题.html":{"url":"软件过程与项目管理/PART4-简答题.html","title":"PART4-简答题","keywords":"","body":"1.What are the triple triple constraints? scope、cost 、time 2.What are the 49 Project Management Processes? Using a table. 3.What are 8 project management techniques WBS work breakdown structure CPM critical path method Scrum SAFe Kanban 看板 Gantt Chart PERT Waterfall 4.difference between scrum and waterfall ( at least 5 difference) 方面 Scrum Waterfall release scrum can have multiple releases waterfall has only one release customer scrum keeps customer informed about every stepduring project development Waterfall only contacts customerat the dilivery date changes scrum welcomes changes of requirements at early and latestages of the project Waterfall welcomes changes only at requirement phase and making changesis not allowed at late stage divide Scrum divide work into sprints and then assign work with the team members Waterfall divides work into stages(phases)and process continues one after another advantage srcum works well for difficult and complex projects, in which requiremnets are not entirely clear before development Waterfall model works well with smaller projects in which requirements are clear before development 5.difference project phase and 5 project management process groups. Processes are performed within Phases; and Phases are performed within the Lifecycle 6.Critical path methods, forward and backward pass, find critical path and slack or float of the activity, and find project duration critical path：F-G project duration：13 7.List and describe each of the 10 project management knowledge areas. Integrated management：its function is like the thread in the necklace Scope management：do and only do what should be done Time management：let everything proceed according to the established schedule Cost management：calculate and spend money properly Quality management：the purpose is to meet the demand Human resource management：let team members work with you efficiently Communication management：let the right person convey the right information to the right person at the right time in the right way Risk management：\"look for trouble without trouble\", so as to make the project \"trouble - free\" Procurement management：be Party A Stakeholder management：keep good relationship with the project stakeholders and make them saisfied 8.What are the phases in a traditional project life cycle initiating planning executing closing 9.What are the 4 scrum ceremonies Sprint planning Daily Scrum Sprint Review Sprint Retrospective 10.What is performance reporting? What are some methods used for performance reporting? Performance reporting keeps stakeholders informed about how resources are being used to achieve project objectives • Progress reports describe what the project team has accomplished during a certain period of time • Status reports describe where the project stands at a specific point in time • Forecasts predict future project status and progress based on past information and trends 11.What are the 12 principles behind the Agile Manifesto? satisfy the customer through early and continuous delivery of valuable software Welcome changing requirements, even late in development Deliver working software frequently Business people and developers must work together Build projects around motivated individuals. Give them the environment and support they need, and trust them. The most efficient and effective method of conveying information is face-to-face conversation Working software is the primary measure of progress. The sponsors, developers, and users should be able to maintain a constant pace indefinitely. Continuous attention to technical excellece and good design Simplicity–the art of maximizing the amount of work not done–is essential. The best architectures, requirements, and designs emerge from self-organizing teams. The team reflects on how to become more effective and adjusts its behavior accordingly. 12.What are the 5 stages of the Tuckman model？ Forming Storming Norming Performing Adjourning 13.What are the associated activities and deliverable along Project Process Groups？ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"保研算法练习AcWing训练/about.html":{"url":"保研算法练习AcWing训练/about.html","title":"保研算法练习AcWing训练","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"保研算法练习AcWing训练/基础算法.html":{"url":"保研算法练习AcWing训练/基础算法.html","title":"基础算法.md","keywords":"","body":"CH1：基础算法 1.1 排序 包含两个典型的排序算法 \\begin{cases}归并排序\\\\快速排序\\end{cases} 程序实现如下： // // Created by BlancheSun on 2022/8/4. // #include #include using namespace std; // 工具函数 void printVec(vector& vec); // 归并排序 void MergeSort(vector& vec, int start, int end); void Merge(vector& vec, int start, int mid, int end); // 快速排序 void quickSort(vector& vec, int start, int end); int partition(vector& vec, int start, int end); int main() { // 归并排序 vector vec = {1,6,4,9,10,2,-1,6,5,8,7}; MergeSort(vec, 0, vec.size()-1); printVec(vec); // 快速排序 vector vec2 = vec; quickSort(vec2, 0, vec2.size()-1); printVec(vec2); return 0; } // 归并排序 void MergeSort(vector& vec, int start, int end) { if(start & vec, int start, int mid, int end) { // 拷贝初始化 vector vec1(vec.begin()+start, vec.begin()+mid+1); vector vec2(vec.begin()+mid+1, vec.begin()+end+1); // 末尾置一无穷大值，方便扫尾 int infty = 999999; vec1.push_back(infty); vec2.push_back(infty); // merge的核心过程 int i = 0, j = 0, k = start; while(k & vec) { for (int i = 0; i & vec, int start, int end) { if (start & vec, int start, int end) { int pivot = vec[end]; int i = start - 1, j = start; while (j 1.1.1 归并排序 分、治、合并三个步骤，重点在于合并的步骤； 合并步骤采取的方法是使用两个临时数组，存储目前已经有序的两段，将这两段通过双指针的形式扫描后合并。 特别的合并时可以在两个临时数组末尾各插入一个无穷大的数字，这样扫尾只需要一个循环即可。 否则还需要额外的循环做扫尾工作：两个for，检验i和j是否有未到某尾的，将其直接续接即可。 1.1.2 快速排序 英语描述快排思想： 快排算法是基于分治思想的一种算法，包括基本的分、治、合并三个步骤。 与归并排序不同，快排的核心在于分解的过程。在算法中具体体现在partition的部分。paritition的过程本质是选择一个数，让数组以这个数所在的位置为界，左侧的数据小于该数字，右侧的数大于该数字。实现时常采用两个指针扫描的方式不断交换下标所在的数字来实现。“治”的步骤则是对数组中以该数分成的两段分别递归处理。算法不需要进行合并步骤。 Fast sort is a kind of algorithm based on divide and conquer idea, including three basic steps: divide, conquer and merge. Unlike merge sort, the key of quick sort is the devide step. The algorithm is embodied in the 'partition' part. The essence of the process of 'paritition' is to select a number, so that the array is bounded by the position of the number, the data on the left is less than the number, and the number on the right is greater than the number. The implementation often uses two pointer scanning method to constantly exchange the number of the subscript to achieve. The \"conquer\" step is to recursively process the two segments of the array divided by that number. The algorithm does not require a merge step. 快排的partition是核心，partition的实现方法有很多种： 暴力解法：辅助数组a[],b[]分别存储小于等于pivot和大于pivot的数 分别存储完毕后，将a[],b[]中的数字分别赋值给vector 这样求解需要额外的存储空间，但是时间复杂度上还是O(n) 常见解法：使用两个指针i,j，分别置于数组开始位置和末尾位置，向中间扫描 若出现vec[i]>pivot && vec[j]，那么交换vec[i]和vec[j]对应的数据 优雅解法 int partition(vector& vec, int start, int end) { int pivot = vec[end]; int i = start - 1, j = start; while (j 1.2 二分 \\begin{cases}整数二分\\\\浮点数二分\\end{cases} 二分的循环结束条件：r ，长度为1时循环结束； 性质一定是有边界的。通过性质判断有无解 1.2.1 整数二分 二分和单调性的关系：有单调性一定可以二分，没有单调性可能也可以使用二分。 二分的本质： 寻找区间边界 寻找两个区间的端点（绿色点和红色点）对应两个不同的算法模板： 1.2.1.1 二分下界：红色点 $mid = \\frac{l+r+1}{2}$ check函数检验是否满足红色部分的性质 if(check(mid))\\begin{cases}true：答案区间[mid, \\ r],l=mid\\\\ false：答案区间[l, mid-1],r=mid-1\\end{cases} 1.2.1.2 二分上界：绿色点 $mid = \\frac{l+r}{2}$ check函数检验是否满足绿色部分的性质 if(check(mid))\\begin{cases}true：答案区间[l, \\ mid]，\\ r=mid\\\\ false：答案区间[mid+1, r]，\\ l=mid+1\\end{cases} 1.2.1.3 具体应用 如在数组1 1 2 2 3 3 4中求解3的起始下标和终止下标 #include #include using namespace std; int main() { vector vec = {1, 1, 2, 2, 3, 3, 4}; int l = 0, r = vec.size()-1; int target = 3; // 寻找下界 while (l > 1; if (vec[mid] >= target) { r = mid; }else{ l = mid + 1; } } if (vec[l] != target) cout > 1; if (vec[mid] 1.2.2 浮点数二分 浮点数二分不需要处理边界，比如(r-l) ； 和整数二分一样，需要保证的是一定在区间内。 1.2.2.1 平方根的例子 浮点数二分，找到一个数的1/2的值，保证其精度为precision void floatBinarySearch(double x, double precision) { double l = 0, r = x; while (r - l > precision) { double mid = (l + r) / 2; if (mid * mid >= x) r = mid; else l = mid; } printf(\"%lf\\n\", l); } 习题练习 Day1 这里没有对应AcWing上习题练习，而是去力扣找了对应的题进行练习： 快速排序 剑指 Offer II 076. 数组中的第 k 大的数字 - 力扣（LeetCode） 剑指 Offer 40. 最小的k个数 - 力扣（LeetCode） 归并排序 剑指 Offer II 078. 合并排序链表 - 力扣（LeetCode） 剑指 Offer II 074. 合并区间 - 力扣（LeetCode） 剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode） 二分 34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode） 69. x 的平方根 - 力扣（LeetCode） // // Created by 孙蕴琦 on 2022/8/8 // 寻找乱序数组中第k大/小的数 // #include #include #include using namespace std; // 前k小的数 int randomizedPartition(vector&vec, int start, int end); int partition(vector& vec, int start, int end); int randomizedSelect(vector& vec, int start, int end, int k); // 逆序数 void Merge(vector& vec, int start, int mid, int end, int& count); void MergeSort(vector& vec, int start, int end, int& count); /****** partition算法的应用 ******/ class Solution { public: vector getLeastNumbers(vector& arr, int k) { vector res(0); if (k == 0) return res; int kIndex = randomizedSelect(arr, 0, arr.size()-1, k); for (int i = 0; i & nums) { int count = 0; MergeSort(nums, 0, nums.size()-1, count); return count; } }; /*** 二分：算术平方根 ***/ class Solution3 { public: int mySqrt(int x) { double l = 0, r = x; while (r - l >= 1e-6) { double mid = (r + l) / 2; if (mid * mid >= x) { r = mid; }else{ l = mid; } } return r; } }; class Solution4 { public: vector searchRange(vector& nums, int target) { vector res(0); int l = 0, r = nums.size() - 1; while (l > 1; if (nums[mid] >= target) { r = mid; }else{ l = mid + 1; } } if ( r> 1; if (nums[mid] nums = {1, 3, 2, 3, 1, 1}; // Solution2 s; // cout nums = {5,7,7,8,8,10}; int target = 8; vector res = s.searchRange(nums, target); cout & vec, int start, int end, int& count) { if (start & vec, int start, int mid, int end, int& count) { vector vec1(vec.begin() + start, vec.begin() + mid + 1); vector vec2(vec.begin()+ mid + 1, vec.begin() + end + 1); vec1.push_back(65536); vec2.push_back(65536); int k = start, i = 0, j = 0; while (k & vec, int start, int end) { int pivot = vec[end]; int i = start - 1, j = start; while (j &vec, int start, int end) { int pivot_index = rand() % (end - start + 1) + start; swap(vec[pivot_index], vec[end]); return partition(vec, start, end); } int randomizedSelect(vector& vec, int start, int end, int targetRank) { if (start == end) return start; int pivot_index = randomizedPartition(vec, start, end); int k = pivot_index - start + 1; if (k == targetRank) { return pivot_index; }else if (targetRank 1.3 高精度 C++考虑高精度，Java有大整数类，Python默认数的范围是无穷大 高精度考察的类型： 大整数相加 A和B的位数大概是10^6 大整数相减 A和B的位数大概是10^6 大整数乘以一个小整数 $len(A)\\leq 10^6,a\\leq10^9$ 一个大整数除以一个小整数 【不常用】：大整数相除，大整数相乘 1.3.1 大整数的存储和计算 1.3.1.1 存储 将大整数的每个位存在数组里面去 存储：个位放在数组的第一个元素，原因是考虑到高位的进位，数据结构是数组时方便在末尾加上进位数。 1.3.1.2 列竖式计算 加法的列竖式 计算公式：$A_i+B_i+t=C_i$，其中$t$代表进位，值为0或者1。 减法的列竖式 A_i-B_i-t=\\begin{cases}A_i-B_i-t,A_i-B_i-t\\geq 0\\\\ A_i-B_i+10-t,A_i-B_i-t\\leq 0\\end{cases} 乘法的列竖式 A2 A1 A0 * b —————————————— C2 C1 C0 \\begin{cases}t_0=0\\\\ C_0 = (3 \\times b +t_0) \\%10, t_1 = (3\\times b +t_0)/10\\\\ ...\\\\ C_i = (A_i \\times b + t_i)\\% 10,t_i = (A_i\\times b+t_{i})/10\\end{cases} 除法 1.3.2 高精度模板 1.3.2.1 高精度加法模板 class Solution { public: string addStrings(string num1, string num2) { vector Num1, Num2, Num3; // 字符串放入数组中： for (int i = num1.size() - 1; i >= 0 ; --i) { Num1.push_back(num1[i] - '0'); // 转换为数字放入数组中 } for (int i = num2.size() - 1; i >= 0 ; --i) { Num2.push_back(num2[i] - '0'); // 转换为数字放入数组中 } // 从数组第一位往后加 int t = 0; for (int i = 0; i = 0; --i) { num3 += Num3[i] + '0'; } return num3; } }; 1.3.2.2 高精度减法模板 步骤： 判断：若$A\\geq B$，那么正常计算，否则交换A和B，计算B-A A_i-B_i-t=\\begin{cases}A_i-B_i-t,A_i-B_i-t\\geq 0\\\\ A_i-B_i+10-t,A_i-B_i-t\\leq 0\\end{cases} 根据是否$A\\geq B$输出时考虑负号 // 高精度减法 // 判断是否有 A>=B bool cmp(vector& A, vector& B) { if (A.size() != B.size()) return A.size() > B.size(); // 否则长度不相等，从最高位开始判断 for (int i = A.size() - 1; i >= 0; --i) { if (A[i] != B[i]) return A[i] > B[i]; } return true; } vector gaoJingDuMinus(vector& A, vector& B) { vector C; int t = 0; for (int i = 0; i 1 && C.back() == 0) C.pop_back(); // 避免出现003的情况 return C; } string sub(string& a, string& b) { // 将字符串形式的数据存储在数组中 vector A, B, C; // 存储时数组的最低位存储数据的个位，以方便最高位的进位 for (int i = a.size() - 1; i >= 0; --i) { A.push_back(a[i] - '0'); // 减去偏移量得到数值 } for (int i = b.size() - 1; i >= 0 ; --i) { B.push_back(b[i] - '0'); // 减去偏移量得到数值 } // 首先要判断A B哪个大，返回的数组C是逆序的，即数组的第一位是个位 string c; if (cmp(A, B)) C = gaoJingDuMinus(A, B); else { C = gaoJingDuMinus(B, A); c.push_back('-'); // 结果应该是负数，添加一个符号 } for (int i = C.size()-1; i >= 0; --i) { c += C[i] + '0'; } return c; } 1.3.2.3 高精度乘法模板 vector mul(vector &A, int b) { vector C; int t = 0; for (int i = 0; i 1.3.2.4 高精度除法模板 // 高精度除法 A/b，商是C，余数是r A若正存储的话比较方便，此处为了一致，仍然采取最低为 vector div(vector& A, int b, int& r) { vector C; for (int i = A.size() - 1; i >= 0; ++i) { C.push_back((r * 10 + A[i]) / b); r = (r * 10 + A[i]) % b; } // 和A保持低位高位一样，所以reverse一下，其实不reverse的结果就是我们要输出的数据 reverse(C.begin(), C.end()); // 去除前导0 while (C.size() > 1 && C.back() == 0) C.pop_back(); return C; } 1.4 前缀和与差分 1.4.1 前缀和的概念与应用 1.4.1.1 一维前缀和 前缀和$S[i]$：数组中的前i个数的和 $a_1+a_2+...+a_3$ 两个问题： 如何求$S[i]$？：for循环一遍即可$S[i] = S[i-1] + a[i]$ 前缀和有什么作用：快速求出来原数组中一段数的和$[l,r]$的数和——$S[r]-S[l-1]$ 即用一次计算计算出任意一段的和 1.4.1.2 二维前缀和 主要是公式的推导，尝试题目： 剑指 Offer II 013. 二维子矩阵的和 题解 - 力扣（LeetCode） 304. 二维区域和检索 - 矩阵不可变 - 力扣（LeetCode） 注意多减的要加回来。 1.4.2 模板 #include #include using namespace std; int main() { int n, m; vector vec, S; vec.push_back(0); scanf(\"%d%d\", &n, &m); for (int i = 1; i 1.4.3 差分 差分是前缀和的逆过程。设有数组A，要求构造出一个数组B，使得数组A的元素$A[i]$是$B[1]，B[2],...,B[i]$的前缀和。 b称为A的差分，A是b的前缀和 所以对A求一遍差分可以得到数组b，对B求一遍前缀和得到数组A 时间复杂度都是$O(n)$ 1.4.3.1 差分数组的构造 输入数组A[i]:A[1],A[2],...,A[i]，构造其差分数组的步骤： 初始化b[i]为全0 插入A[i]等价于操作： b[i] = b[i] + A[i]; b[i+1] = b[i+1] - A[i] 每输入一个A[i]，进行一次B数组的对应操作 输入完成，A的差分数组构造完成 1.4.3.2 差分的应用 构造原始的数组b[i] 对于在区间[l, c]中每个数加上c等价于操作： b[l] += c b[c+1] -= c 对数组B求一次前缀和得到最终的序列 1.4.4 模板 #include #include using namespace std; // 注意书写前缀和和差分的代码时，数组下标从1开始存 int main() { int n, m; scanf(\"%d%d\", &n, &m); vector nums(n+1), res(n+2,0); // 在输入的同时构造差分数组 for (int i = 1; i 习题练习 Day2 对应力扣题目： 高精度 415. 字符串相加 - 力扣（LeetCode） 306. 累加数 - 力扣（LeetCode） 43. 字符串相乘 - 力扣（LeetCode） 前缀和 303. 区域和检索 - 数组不可变 - 力扣（LeetCode） 437. 路径总和 III - 力扣（LeetCode） 剑指 Offer II 013. 二维子矩阵的和 题解 - 力扣（LeetCode） 304. 二维区域和检索 - 矩阵不可变 - 力扣（LeetCode） 差分 1109. 航班预订统计 - 力扣（LeetCode） 1526. 形成目标数组的子数组最少增加次数 - 力扣（LeetCode） var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"markdown 简洁优雅的排版语言,简化版的 HTML,加强版的 TXT,详情请参考 https://xinwuyun.github.io/markdown/ git 分布式版本控制系统,详情请参考 https://xinwuyun.github.io/git/ var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}"}}