

## 1.质量属性场景的概念

质量属性场景：

- 源
- 刺激物
- 制品
- 环境
- 响应
- 响应衡量



## 2.六大质量属性

### 2.1 可用性

故障，相关后果

定义：在需要是可用的概率，停机不算

α的定义
$$
\alpha  = \frac{平均无故障时间}{平均无故障时间 + 故障修复时间}
$$
failure的特性：可感知的，未达到声称级别的功能即为错误。

可用性的质量属性场景：

- 源：系统内部或者外部故障迹象
- 刺激物：系统崩溃，系统错误，给出结果不准时，错误结果
- 制品：系统处理器，通信信道，存储，进程
- 环境：正常、亚健康
- 响应：记录错误日志，传回；通知管理员或者其他系统；关闭系统
- 响应测量：平均无故障时间，修复时间，故障时间百分比，可用时间百分比

### 2.2 可修改性

关注：改什么，谁改，什么时候改，改的代价

质量属性场景

- 源：谁去修改（开发者，系统管理员，用户）
- 刺激物：要进行的具体修改
- 制品：要修改哪一部分的内容：修改系统的功能 or UI 或者其他部分
- 环境：在什么时间进行修改，设计or开发or运行时间
- 响应：操作员怎么理解修改，部署，运行
- 度量：改的时间和成本

---

### 2.3 性能

主要是系统响应事件的花费时间，事件数量，到来形式

质量属性场景

- 源：可能来自系统外部（可能多个）也可能来自系统内部
- 刺激物：事件的到达，到达的形式（周期性，随机，偶发）
- 制品：系统提供的服务
- 环境：系统处于不同的环境——正常，紧急，超载
- 响应：系统必须处理到来的事件，可能导致系统的环境的变化
- 响应度量：
  - 处理事件花费的时间
  - 单位时间内处理事件的数量
  - 出错的错误率，丢失率

---

### 2.4 安全性

保证正常用户，阻挡非法攻击

安全性的不同类型

- 不可抵赖性
- 机密性
- 完整性
- 保证性
- 审计
- 可用性

质量属性场景

- 源：攻击可能由人或者其他系统发起；可能先前被识别，或者当前未知。

- 刺激物

  对系统的攻击（或者试图破坏系统安全保护），常见的形式：

  - 数据
  - 超过权限的服务
  - 影响可用性

- 制品：系统所提供的服务或系统中的数据

- 环境：系统可能处于不同的情况下——联网/未联网，在线/下线，在防火墙外/在防火墙内

- 响应：

  - 合法用户正常使用，拒绝非法用户的使用
  - 对攻击有威慑
  
- 度量

  - 发起攻击的难度
  - 从攻击中恢复的难度

---

### 2.5 可测试性

软件测试为了发现bug

测试的重要性

测试的质量属性场景

- 源：测试可能由不同的角色发起（开发者、单元测试人员、集成测 试人员、系统管理员、用户……）
- 刺激物：里程碑
- 制品：程序，设计，系统
- 环境：设计阶段、开发阶段、编译时，部署阶段、正常运行时
- 响应
  - 理想的响应是可以进行测试，并且可以观察到测试结果
  - 当测试结果无法被观察到时，测试难度很大

- 响应的衡量标准
  - 白盒测试的覆盖率
  - 未来继续发现Bug的概率
  - 最长测试链的长度

---

### 2.6 易用性

用户希望完成任务有多容易

质量属性场景

- 源：终端用户

- 刺激物

  终端用户希望学会使用，提高效率，减少错误

- 制品：整个系统

- 环境：运行时或者部署时

- 响应

  系统响应用户的需求

- 响应度量

  - 用户完成任务的时间
  - 用户出错的概率
  - 用户满意程度
  - 用户操作的成功率

## 3.从架构上设计质量属性的策略

### 3.1 可用性

$$
\begin{cases}错误检测\begin{cases}ping/echo\\Heartbeats：被监控组件向监控组件发出周期性信号\\异常\end{cases}
\\错误恢复\begin{cases}投票机制\\主动冗余\\被动冗余\\内测\\检查点/回滚\end{cases}\\错误避免\begin{cases}事务\\关闭服务\\进程监控\end{cases}\end{cases}
$$

### 3.2 可修改性

$$
\begin{cases}局部化修改\begin{cases}保持语义的高内聚性\\考虑未来可能会发生的改变\\模块泛化\\选项变少\\抽象公共服务\end{cases}\\避免连锁反应\begin{cases}保持已有的接口\\使用中间层\\信息隐藏\end{cases}\\延迟绑定时间\begin{cases}运行时注册\\配置文件\\多态\end{cases}\end{cases}
$$

### 3.3 性能

$$
\begin{cases}资源需求\begin{cases}提升计算能力\\减少处理的数据数量\\管理事件达到的频率\\限制采样率\end{cases}\\资源管理\begin{cases}长任务设置上限执行时间\\限制事务队列的长度\\利用并发机制\end{cases}\\资源仲裁：使用调度策略\begin{cases}FIFO\\固定优先级\\动态优先级\end{cases}\end{cases}
$$

### 3.4 安全性

$$
\begin{cases}抵御攻击\begin{cases}用户认证\\用户授权\\保证数据的机密性\\保证数据的完整性\\限制访问：防火墙\end{cases}\\攻击检测：入侵检测系统\\攻击恢复\begin{cases}数据备份\\攻击者识别\end{cases}\end{cases}
$$

### 3.5 可测试性

$$
\begin{cases}管理输入输出\begin{cases}记录/回放，重演\\ 接口和实现分离\end{cases}\\
内部检测：内部监控器\begin{cases}IDE断点\end{cases}\end{cases}
$$

### 3.6 易用性

$$
\begin{cases}运行时策略\begin{cases}保证用户模型\\保证系统模型\\保证任务模型\end{cases}\\设计时策略\begin{cases}UI界面与其他分离：MVC\end{cases}\\具体：\begin{cases}系统给与用户适当反馈\\系统猜测用户要完成的任务\\系统支持撤销\\系统给用户提供一致性体验\\用户接口分离\end{cases}\end{cases}
$$



